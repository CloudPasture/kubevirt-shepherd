// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: approval.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allocateServiceInstance = `-- name: AllocateServiceInstance :one
WITH allocated AS (
    UPDATE services AS s
    SET
        next_instance_index = s.next_instance_index + 1,
        updated_at = NOW()
    WHERE s.id = $1
    RETURNING s.id, s.name, s.system_services, s.next_instance_index - 1 AS allocated_index
)
SELECT
    allocated.id AS service_id,
    allocated.name AS service_name,
    systems.name AS system_name,
    allocated.allocated_index
FROM allocated
JOIN systems ON systems.id = allocated.system_services
`

type AllocateServiceInstanceRow struct {
	ServiceID      string `db:"service_id" json:"service_id"`
	ServiceName    string `db:"service_name" json:"service_name"`
	SystemName     string `db:"system_name" json:"system_name"`
	AllocatedIndex int32  `db:"allocated_index" json:"allocated_index"`
}

func (q *Queries) AllocateServiceInstance(ctx context.Context, id string) (AllocateServiceInstanceRow, error) {
	row := q.db.QueryRow(ctx, allocateServiceInstance, id)
	var i AllocateServiceInstanceRow
	err := row.Scan(
		&i.ServiceID,
		&i.ServiceName,
		&i.SystemName,
		&i.AllocatedIndex,
	)
	return i, err
}

const approveCreateTicket = `-- name: ApproveCreateTicket :execrows
UPDATE approval_tickets
SET
    status = 'APPROVED',
    approver = $1,
    selected_cluster_id = $2,
    selected_template_version = CASE
        WHEN $3::int IS NULL THEN selected_template_version
        ELSE $3::int
    END,
    selected_storage_class = CASE
        WHEN $4::text = '' THEN selected_storage_class
        ELSE $4::text
    END,
    template_snapshot = COALESCE($5::jsonb, template_snapshot),
    instance_size_snapshot = COALESCE($6::jsonb, instance_size_snapshot),
    modified_spec = COALESCE($7::jsonb, modified_spec),
    updated_at = NOW()
WHERE
    id = $8
    AND event_id = $9
    AND status = 'PENDING'
    AND operation_type = 'CREATE'
`

type ApproveCreateTicketParams struct {
	Approver                pgtype.Text `db:"approver" json:"approver"`
	SelectedClusterID       pgtype.Text `db:"selected_cluster_id" json:"selected_cluster_id"`
	SelectedTemplateVersion pgtype.Int4 `db:"selected_template_version" json:"selected_template_version"`
	SelectedStorageClass    string      `db:"selected_storage_class" json:"selected_storage_class"`
	TemplateSnapshot        []byte      `db:"template_snapshot" json:"template_snapshot"`
	InstanceSizeSnapshot    []byte      `db:"instance_size_snapshot" json:"instance_size_snapshot"`
	ModifiedSpec            []byte      `db:"modified_spec" json:"modified_spec"`
	ID                      string      `db:"id" json:"id"`
	EventID                 string      `db:"event_id" json:"event_id"`
}

func (q *Queries) ApproveCreateTicket(ctx context.Context, arg ApproveCreateTicketParams) (int64, error) {
	result, err := q.db.Exec(ctx, approveCreateTicket,
		arg.Approver,
		arg.SelectedClusterID,
		arg.SelectedTemplateVersion,
		arg.SelectedStorageClass,
		arg.TemplateSnapshot,
		arg.InstanceSizeSnapshot,
		arg.ModifiedSpec,
		arg.ID,
		arg.EventID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const approveDeleteTicket = `-- name: ApproveDeleteTicket :execrows
UPDATE approval_tickets
SET
    status = 'APPROVED',
    approver = $1,
    updated_at = NOW()
WHERE
    id = $2
    AND event_id = $3
    AND status = 'PENDING'
    AND operation_type = 'DELETE'
`

type ApproveDeleteTicketParams struct {
	Approver pgtype.Text `db:"approver" json:"approver"`
	ID       string      `db:"id" json:"id"`
	EventID  string      `db:"event_id" json:"event_id"`
}

func (q *Queries) ApproveDeleteTicket(ctx context.Context, arg ApproveDeleteTicketParams) (int64, error) {
	result, err := q.db.Exec(ctx, approveDeleteTicket, arg.Approver, arg.ID, arg.EventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const insertVM = `-- name: InsertVM :exec
INSERT INTO vms (
    id,
    created_at,
    updated_at,
    name,
    instance,
    namespace,
    cluster_id,
    status,
    hostname,
    created_by,
    ticket_id,
    service_vms
) VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3,
    $4,
    $5,
    'CREATING',
    $6,
    $7,
    $8,
    $9
)
`

type InsertVMParams struct {
	ID         string      `db:"id" json:"id"`
	Name       string      `db:"name" json:"name"`
	Instance   string      `db:"instance" json:"instance"`
	Namespace  string      `db:"namespace" json:"namespace"`
	ClusterID  pgtype.Text `db:"cluster_id" json:"cluster_id"`
	Hostname   pgtype.Text `db:"hostname" json:"hostname"`
	CreatedBy  string      `db:"created_by" json:"created_by"`
	TicketID   pgtype.Text `db:"ticket_id" json:"ticket_id"`
	ServiceVms string      `db:"service_vms" json:"service_vms"`
}

func (q *Queries) InsertVM(ctx context.Context, arg InsertVMParams) error {
	_, err := q.db.Exec(ctx, insertVM,
		arg.ID,
		arg.Name,
		arg.Instance,
		arg.Namespace,
		arg.ClusterID,
		arg.Hostname,
		arg.CreatedBy,
		arg.TicketID,
		arg.ServiceVms,
	)
	return err
}

const setDomainEventStatus = `-- name: SetDomainEventStatus :execrows
UPDATE domain_events
SET status = $2
WHERE id = $1
`

type SetDomainEventStatusParams struct {
	ID     string `db:"id" json:"id"`
	Status string `db:"status" json:"status"`
}

func (q *Queries) SetDomainEventStatus(ctx context.Context, arg SetDomainEventStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, setDomainEventStatus, arg.ID, arg.Status)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setVMStatus = `-- name: SetVMStatus :execrows
UPDATE vms
SET
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type SetVMStatusParams struct {
	ID     string `db:"id" json:"id"`
	Status string `db:"status" json:"status"`
}

func (q *Queries) SetVMStatus(ctx context.Context, arg SetVMStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, setVMStatus, arg.ID, arg.Status)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
