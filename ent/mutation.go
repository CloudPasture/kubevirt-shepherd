// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"kv-shepherd.io/shepherd/ent/approvalpolicy"
	"kv-shepherd.io/shepherd/ent/approvalticket"
	"kv-shepherd.io/shepherd/ent/auditlog"
	"kv-shepherd.io/shepherd/ent/authprovider"
	"kv-shepherd.io/shepherd/ent/batchapprovalticket"
	"kv-shepherd.io/shepherd/ent/cluster"
	"kv-shepherd.io/shepherd/ent/domainevent"
	"kv-shepherd.io/shepherd/ent/externalapprovalsystem"
	"kv-shepherd.io/shepherd/ent/idpgroupmapping"
	"kv-shepherd.io/shepherd/ent/idpsyncedgroup"
	"kv-shepherd.io/shepherd/ent/instancesize"
	"kv-shepherd.io/shepherd/ent/namespaceregistry"
	"kv-shepherd.io/shepherd/ent/notification"
	"kv-shepherd.io/shepherd/ent/pendingadoption"
	"kv-shepherd.io/shepherd/ent/predicate"
	"kv-shepherd.io/shepherd/ent/ratelimitexemption"
	"kv-shepherd.io/shepherd/ent/ratelimituseroverride"
	"kv-shepherd.io/shepherd/ent/resourcerolebinding"
	"kv-shepherd.io/shepherd/ent/role"
	"kv-shepherd.io/shepherd/ent/rolebinding"
	"kv-shepherd.io/shepherd/ent/service"
	"kv-shepherd.io/shepherd/ent/system"
	"kv-shepherd.io/shepherd/ent/systemsecret"
	"kv-shepherd.io/shepherd/ent/template"
	"kv-shepherd.io/shepherd/ent/user"
	"kv-shepherd.io/shepherd/ent/vm"
	"kv-shepherd.io/shepherd/ent/vmrevision"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApprovalPolicy         = "ApprovalPolicy"
	TypeApprovalTicket         = "ApprovalTicket"
	TypeAuditLog               = "AuditLog"
	TypeAuthProvider           = "AuthProvider"
	TypeBatchApprovalTicket    = "BatchApprovalTicket"
	TypeCluster                = "Cluster"
	TypeDomainEvent            = "DomainEvent"
	TypeExternalApprovalSystem = "ExternalApprovalSystem"
	TypeIdPGroupMapping        = "IdPGroupMapping"
	TypeIdPSyncedGroup         = "IdPSyncedGroup"
	TypeInstanceSize           = "InstanceSize"
	TypeNamespaceRegistry      = "NamespaceRegistry"
	TypeNotification           = "Notification"
	TypePendingAdoption        = "PendingAdoption"
	TypeRateLimitExemption     = "RateLimitExemption"
	TypeRateLimitUserOverride  = "RateLimitUserOverride"
	TypeResourceRoleBinding    = "ResourceRoleBinding"
	TypeRole                   = "Role"
	TypeRoleBinding            = "RoleBinding"
	TypeService                = "Service"
	TypeSystem                 = "System"
	TypeSystemSecret           = "SystemSecret"
	TypeTemplate               = "Template"
	TypeUser                   = "User"
	TypeVM                     = "VM"
	TypeVMRevision             = "VMRevision"
)

// ApprovalPolicyMutation represents an operation that mutates the ApprovalPolicy nodes in the graph.
type ApprovalPolicyMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	description       *string
	action            *approvalpolicy.Action
	namespace_pattern *string
	enabled           *bool
	created_by        *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ApprovalPolicy, error)
	predicates        []predicate.ApprovalPolicy
}

var _ ent.Mutation = (*ApprovalPolicyMutation)(nil)

// approvalpolicyOption allows management of the mutation configuration using functional options.
type approvalpolicyOption func(*ApprovalPolicyMutation)

// newApprovalPolicyMutation creates new mutation for the ApprovalPolicy entity.
func newApprovalPolicyMutation(c config, op Op, opts ...approvalpolicyOption) *ApprovalPolicyMutation {
	m := &ApprovalPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeApprovalPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApprovalPolicyID sets the ID field of the mutation.
func withApprovalPolicyID(id string) approvalpolicyOption {
	return func(m *ApprovalPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApprovalPolicy
		)
		m.oldValue = func(ctx context.Context) (*ApprovalPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApprovalPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApprovalPolicy sets the old ApprovalPolicy of the mutation.
func withApprovalPolicy(node *ApprovalPolicy) approvalpolicyOption {
	return func(m *ApprovalPolicyMutation) {
		m.oldValue = func(context.Context) (*ApprovalPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApprovalPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApprovalPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApprovalPolicy entities.
func (m *ApprovalPolicyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApprovalPolicyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApprovalPolicyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApprovalPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApprovalPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApprovalPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApprovalPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApprovalPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApprovalPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApprovalPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ApprovalPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApprovalPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApprovalPolicyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ApprovalPolicyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApprovalPolicyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ApprovalPolicyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[approvalpolicy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ApprovalPolicyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[approvalpolicy.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ApprovalPolicyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, approvalpolicy.FieldDescription)
}

// SetAction sets the "action" field.
func (m *ApprovalPolicyMutation) SetAction(a approvalpolicy.Action) {
	m.action = &a
}

// Action returns the value of the "action" field in the mutation.
func (m *ApprovalPolicyMutation) Action() (r approvalpolicy.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldAction(ctx context.Context) (v approvalpolicy.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ApprovalPolicyMutation) ResetAction() {
	m.action = nil
}

// SetNamespacePattern sets the "namespace_pattern" field.
func (m *ApprovalPolicyMutation) SetNamespacePattern(s string) {
	m.namespace_pattern = &s
}

// NamespacePattern returns the value of the "namespace_pattern" field in the mutation.
func (m *ApprovalPolicyMutation) NamespacePattern() (r string, exists bool) {
	v := m.namespace_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespacePattern returns the old "namespace_pattern" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldNamespacePattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespacePattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespacePattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespacePattern: %w", err)
	}
	return oldValue.NamespacePattern, nil
}

// ClearNamespacePattern clears the value of the "namespace_pattern" field.
func (m *ApprovalPolicyMutation) ClearNamespacePattern() {
	m.namespace_pattern = nil
	m.clearedFields[approvalpolicy.FieldNamespacePattern] = struct{}{}
}

// NamespacePatternCleared returns if the "namespace_pattern" field was cleared in this mutation.
func (m *ApprovalPolicyMutation) NamespacePatternCleared() bool {
	_, ok := m.clearedFields[approvalpolicy.FieldNamespacePattern]
	return ok
}

// ResetNamespacePattern resets all changes to the "namespace_pattern" field.
func (m *ApprovalPolicyMutation) ResetNamespacePattern() {
	m.namespace_pattern = nil
	delete(m.clearedFields, approvalpolicy.FieldNamespacePattern)
}

// SetEnabled sets the "enabled" field.
func (m *ApprovalPolicyMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ApprovalPolicyMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ApprovalPolicyMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ApprovalPolicyMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ApprovalPolicyMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ApprovalPolicy entity.
// If the ApprovalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalPolicyMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ApprovalPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the ApprovalPolicyMutation builder.
func (m *ApprovalPolicyMutation) Where(ps ...predicate.ApprovalPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApprovalPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApprovalPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApprovalPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApprovalPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApprovalPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApprovalPolicy).
func (m *ApprovalPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApprovalPolicyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, approvalpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approvalpolicy.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, approvalpolicy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, approvalpolicy.FieldDescription)
	}
	if m.action != nil {
		fields = append(fields, approvalpolicy.FieldAction)
	}
	if m.namespace_pattern != nil {
		fields = append(fields, approvalpolicy.FieldNamespacePattern)
	}
	if m.enabled != nil {
		fields = append(fields, approvalpolicy.FieldEnabled)
	}
	if m.created_by != nil {
		fields = append(fields, approvalpolicy.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApprovalPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approvalpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case approvalpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case approvalpolicy.FieldName:
		return m.Name()
	case approvalpolicy.FieldDescription:
		return m.Description()
	case approvalpolicy.FieldAction:
		return m.Action()
	case approvalpolicy.FieldNamespacePattern:
		return m.NamespacePattern()
	case approvalpolicy.FieldEnabled:
		return m.Enabled()
	case approvalpolicy.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApprovalPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approvalpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approvalpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approvalpolicy.FieldName:
		return m.OldName(ctx)
	case approvalpolicy.FieldDescription:
		return m.OldDescription(ctx)
	case approvalpolicy.FieldAction:
		return m.OldAction(ctx)
	case approvalpolicy.FieldNamespacePattern:
		return m.OldNamespacePattern(ctx)
	case approvalpolicy.FieldEnabled:
		return m.OldEnabled(ctx)
	case approvalpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ApprovalPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approvalpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approvalpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approvalpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case approvalpolicy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approvalpolicy.FieldAction:
		v, ok := value.(approvalpolicy.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case approvalpolicy.FieldNamespacePattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespacePattern(v)
		return nil
	case approvalpolicy.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case approvalpolicy.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApprovalPolicyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApprovalPolicyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApprovalPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApprovalPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approvalpolicy.FieldDescription) {
		fields = append(fields, approvalpolicy.FieldDescription)
	}
	if m.FieldCleared(approvalpolicy.FieldNamespacePattern) {
		fields = append(fields, approvalpolicy.FieldNamespacePattern)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApprovalPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApprovalPolicyMutation) ClearField(name string) error {
	switch name {
	case approvalpolicy.FieldDescription:
		m.ClearDescription()
		return nil
	case approvalpolicy.FieldNamespacePattern:
		m.ClearNamespacePattern()
		return nil
	}
	return fmt.Errorf("unknown ApprovalPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApprovalPolicyMutation) ResetField(name string) error {
	switch name {
	case approvalpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approvalpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approvalpolicy.FieldName:
		m.ResetName()
		return nil
	case approvalpolicy.FieldDescription:
		m.ResetDescription()
		return nil
	case approvalpolicy.FieldAction:
		m.ResetAction()
		return nil
	case approvalpolicy.FieldNamespacePattern:
		m.ResetNamespacePattern()
		return nil
	case approvalpolicy.FieldEnabled:
		m.ResetEnabled()
		return nil
	case approvalpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ApprovalPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApprovalPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApprovalPolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApprovalPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApprovalPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApprovalPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApprovalPolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApprovalPolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApprovalPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApprovalPolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApprovalPolicy edge %s", name)
}

// ApprovalTicketMutation represents an operation that mutates the ApprovalTicket nodes in the graph.
type ApprovalTicketMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	created_at                   *time.Time
	updated_at                   *time.Time
	event_id                     *string
	operation_type               *approvalticket.OperationType
	status                       *approvalticket.Status
	requester                    *string
	approver                     *string
	reason                       *string
	reject_reason                *string
	selected_cluster_id          *string
	selected_template_version    *int
	addselected_template_version *int
	selected_storage_class       *string
	template_snapshot            *map[string]interface{}
	instance_size_snapshot       *map[string]interface{}
	modified_spec                *map[string]interface{}
	parent_ticket_id             *string
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*ApprovalTicket, error)
	predicates                   []predicate.ApprovalTicket
}

var _ ent.Mutation = (*ApprovalTicketMutation)(nil)

// approvalticketOption allows management of the mutation configuration using functional options.
type approvalticketOption func(*ApprovalTicketMutation)

// newApprovalTicketMutation creates new mutation for the ApprovalTicket entity.
func newApprovalTicketMutation(c config, op Op, opts ...approvalticketOption) *ApprovalTicketMutation {
	m := &ApprovalTicketMutation{
		config:        c,
		op:            op,
		typ:           TypeApprovalTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApprovalTicketID sets the ID field of the mutation.
func withApprovalTicketID(id string) approvalticketOption {
	return func(m *ApprovalTicketMutation) {
		var (
			err   error
			once  sync.Once
			value *ApprovalTicket
		)
		m.oldValue = func(ctx context.Context) (*ApprovalTicket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApprovalTicket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApprovalTicket sets the old ApprovalTicket of the mutation.
func withApprovalTicket(node *ApprovalTicket) approvalticketOption {
	return func(m *ApprovalTicketMutation) {
		m.oldValue = func(context.Context) (*ApprovalTicket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApprovalTicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApprovalTicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApprovalTicket entities.
func (m *ApprovalTicketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApprovalTicketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApprovalTicketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApprovalTicket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApprovalTicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApprovalTicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApprovalTicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApprovalTicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApprovalTicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApprovalTicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event_id" field.
func (m *ApprovalTicketMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *ApprovalTicketMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *ApprovalTicketMutation) ResetEventID() {
	m.event_id = nil
}

// SetOperationType sets the "operation_type" field.
func (m *ApprovalTicketMutation) SetOperationType(at approvalticket.OperationType) {
	m.operation_type = &at
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *ApprovalTicketMutation) OperationType() (r approvalticket.OperationType, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldOperationType(ctx context.Context) (v approvalticket.OperationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *ApprovalTicketMutation) ResetOperationType() {
	m.operation_type = nil
}

// SetStatus sets the "status" field.
func (m *ApprovalTicketMutation) SetStatus(a approvalticket.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *ApprovalTicketMutation) Status() (r approvalticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldStatus(ctx context.Context) (v approvalticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApprovalTicketMutation) ResetStatus() {
	m.status = nil
}

// SetRequester sets the "requester" field.
func (m *ApprovalTicketMutation) SetRequester(s string) {
	m.requester = &s
}

// Requester returns the value of the "requester" field in the mutation.
func (m *ApprovalTicketMutation) Requester() (r string, exists bool) {
	v := m.requester
	if v == nil {
		return
	}
	return *v, true
}

// OldRequester returns the old "requester" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldRequester(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequester is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequester requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequester: %w", err)
	}
	return oldValue.Requester, nil
}

// ResetRequester resets all changes to the "requester" field.
func (m *ApprovalTicketMutation) ResetRequester() {
	m.requester = nil
}

// SetApprover sets the "approver" field.
func (m *ApprovalTicketMutation) SetApprover(s string) {
	m.approver = &s
}

// Approver returns the value of the "approver" field in the mutation.
func (m *ApprovalTicketMutation) Approver() (r string, exists bool) {
	v := m.approver
	if v == nil {
		return
	}
	return *v, true
}

// OldApprover returns the old "approver" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldApprover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprover: %w", err)
	}
	return oldValue.Approver, nil
}

// ClearApprover clears the value of the "approver" field.
func (m *ApprovalTicketMutation) ClearApprover() {
	m.approver = nil
	m.clearedFields[approvalticket.FieldApprover] = struct{}{}
}

// ApproverCleared returns if the "approver" field was cleared in this mutation.
func (m *ApprovalTicketMutation) ApproverCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldApprover]
	return ok
}

// ResetApprover resets all changes to the "approver" field.
func (m *ApprovalTicketMutation) ResetApprover() {
	m.approver = nil
	delete(m.clearedFields, approvalticket.FieldApprover)
}

// SetReason sets the "reason" field.
func (m *ApprovalTicketMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ApprovalTicketMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ApprovalTicketMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[approvalticket.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ApprovalTicketMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ApprovalTicketMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, approvalticket.FieldReason)
}

// SetRejectReason sets the "reject_reason" field.
func (m *ApprovalTicketMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *ApprovalTicketMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ClearRejectReason clears the value of the "reject_reason" field.
func (m *ApprovalTicketMutation) ClearRejectReason() {
	m.reject_reason = nil
	m.clearedFields[approvalticket.FieldRejectReason] = struct{}{}
}

// RejectReasonCleared returns if the "reject_reason" field was cleared in this mutation.
func (m *ApprovalTicketMutation) RejectReasonCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldRejectReason]
	return ok
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *ApprovalTicketMutation) ResetRejectReason() {
	m.reject_reason = nil
	delete(m.clearedFields, approvalticket.FieldRejectReason)
}

// SetSelectedClusterID sets the "selected_cluster_id" field.
func (m *ApprovalTicketMutation) SetSelectedClusterID(s string) {
	m.selected_cluster_id = &s
}

// SelectedClusterID returns the value of the "selected_cluster_id" field in the mutation.
func (m *ApprovalTicketMutation) SelectedClusterID() (r string, exists bool) {
	v := m.selected_cluster_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedClusterID returns the old "selected_cluster_id" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldSelectedClusterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedClusterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedClusterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedClusterID: %w", err)
	}
	return oldValue.SelectedClusterID, nil
}

// ClearSelectedClusterID clears the value of the "selected_cluster_id" field.
func (m *ApprovalTicketMutation) ClearSelectedClusterID() {
	m.selected_cluster_id = nil
	m.clearedFields[approvalticket.FieldSelectedClusterID] = struct{}{}
}

// SelectedClusterIDCleared returns if the "selected_cluster_id" field was cleared in this mutation.
func (m *ApprovalTicketMutation) SelectedClusterIDCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldSelectedClusterID]
	return ok
}

// ResetSelectedClusterID resets all changes to the "selected_cluster_id" field.
func (m *ApprovalTicketMutation) ResetSelectedClusterID() {
	m.selected_cluster_id = nil
	delete(m.clearedFields, approvalticket.FieldSelectedClusterID)
}

// SetSelectedTemplateVersion sets the "selected_template_version" field.
func (m *ApprovalTicketMutation) SetSelectedTemplateVersion(i int) {
	m.selected_template_version = &i
	m.addselected_template_version = nil
}

// SelectedTemplateVersion returns the value of the "selected_template_version" field in the mutation.
func (m *ApprovalTicketMutation) SelectedTemplateVersion() (r int, exists bool) {
	v := m.selected_template_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedTemplateVersion returns the old "selected_template_version" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldSelectedTemplateVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedTemplateVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedTemplateVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedTemplateVersion: %w", err)
	}
	return oldValue.SelectedTemplateVersion, nil
}

// AddSelectedTemplateVersion adds i to the "selected_template_version" field.
func (m *ApprovalTicketMutation) AddSelectedTemplateVersion(i int) {
	if m.addselected_template_version != nil {
		*m.addselected_template_version += i
	} else {
		m.addselected_template_version = &i
	}
}

// AddedSelectedTemplateVersion returns the value that was added to the "selected_template_version" field in this mutation.
func (m *ApprovalTicketMutation) AddedSelectedTemplateVersion() (r int, exists bool) {
	v := m.addselected_template_version
	if v == nil {
		return
	}
	return *v, true
}

// ClearSelectedTemplateVersion clears the value of the "selected_template_version" field.
func (m *ApprovalTicketMutation) ClearSelectedTemplateVersion() {
	m.selected_template_version = nil
	m.addselected_template_version = nil
	m.clearedFields[approvalticket.FieldSelectedTemplateVersion] = struct{}{}
}

// SelectedTemplateVersionCleared returns if the "selected_template_version" field was cleared in this mutation.
func (m *ApprovalTicketMutation) SelectedTemplateVersionCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldSelectedTemplateVersion]
	return ok
}

// ResetSelectedTemplateVersion resets all changes to the "selected_template_version" field.
func (m *ApprovalTicketMutation) ResetSelectedTemplateVersion() {
	m.selected_template_version = nil
	m.addselected_template_version = nil
	delete(m.clearedFields, approvalticket.FieldSelectedTemplateVersion)
}

// SetSelectedStorageClass sets the "selected_storage_class" field.
func (m *ApprovalTicketMutation) SetSelectedStorageClass(s string) {
	m.selected_storage_class = &s
}

// SelectedStorageClass returns the value of the "selected_storage_class" field in the mutation.
func (m *ApprovalTicketMutation) SelectedStorageClass() (r string, exists bool) {
	v := m.selected_storage_class
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedStorageClass returns the old "selected_storage_class" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldSelectedStorageClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedStorageClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedStorageClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedStorageClass: %w", err)
	}
	return oldValue.SelectedStorageClass, nil
}

// ClearSelectedStorageClass clears the value of the "selected_storage_class" field.
func (m *ApprovalTicketMutation) ClearSelectedStorageClass() {
	m.selected_storage_class = nil
	m.clearedFields[approvalticket.FieldSelectedStorageClass] = struct{}{}
}

// SelectedStorageClassCleared returns if the "selected_storage_class" field was cleared in this mutation.
func (m *ApprovalTicketMutation) SelectedStorageClassCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldSelectedStorageClass]
	return ok
}

// ResetSelectedStorageClass resets all changes to the "selected_storage_class" field.
func (m *ApprovalTicketMutation) ResetSelectedStorageClass() {
	m.selected_storage_class = nil
	delete(m.clearedFields, approvalticket.FieldSelectedStorageClass)
}

// SetTemplateSnapshot sets the "template_snapshot" field.
func (m *ApprovalTicketMutation) SetTemplateSnapshot(value map[string]interface{}) {
	m.template_snapshot = &value
}

// TemplateSnapshot returns the value of the "template_snapshot" field in the mutation.
func (m *ApprovalTicketMutation) TemplateSnapshot() (r map[string]interface{}, exists bool) {
	v := m.template_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateSnapshot returns the old "template_snapshot" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldTemplateSnapshot(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateSnapshot: %w", err)
	}
	return oldValue.TemplateSnapshot, nil
}

// ClearTemplateSnapshot clears the value of the "template_snapshot" field.
func (m *ApprovalTicketMutation) ClearTemplateSnapshot() {
	m.template_snapshot = nil
	m.clearedFields[approvalticket.FieldTemplateSnapshot] = struct{}{}
}

// TemplateSnapshotCleared returns if the "template_snapshot" field was cleared in this mutation.
func (m *ApprovalTicketMutation) TemplateSnapshotCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldTemplateSnapshot]
	return ok
}

// ResetTemplateSnapshot resets all changes to the "template_snapshot" field.
func (m *ApprovalTicketMutation) ResetTemplateSnapshot() {
	m.template_snapshot = nil
	delete(m.clearedFields, approvalticket.FieldTemplateSnapshot)
}

// SetInstanceSizeSnapshot sets the "instance_size_snapshot" field.
func (m *ApprovalTicketMutation) SetInstanceSizeSnapshot(value map[string]interface{}) {
	m.instance_size_snapshot = &value
}

// InstanceSizeSnapshot returns the value of the "instance_size_snapshot" field in the mutation.
func (m *ApprovalTicketMutation) InstanceSizeSnapshot() (r map[string]interface{}, exists bool) {
	v := m.instance_size_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceSizeSnapshot returns the old "instance_size_snapshot" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldInstanceSizeSnapshot(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceSizeSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceSizeSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceSizeSnapshot: %w", err)
	}
	return oldValue.InstanceSizeSnapshot, nil
}

// ClearInstanceSizeSnapshot clears the value of the "instance_size_snapshot" field.
func (m *ApprovalTicketMutation) ClearInstanceSizeSnapshot() {
	m.instance_size_snapshot = nil
	m.clearedFields[approvalticket.FieldInstanceSizeSnapshot] = struct{}{}
}

// InstanceSizeSnapshotCleared returns if the "instance_size_snapshot" field was cleared in this mutation.
func (m *ApprovalTicketMutation) InstanceSizeSnapshotCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldInstanceSizeSnapshot]
	return ok
}

// ResetInstanceSizeSnapshot resets all changes to the "instance_size_snapshot" field.
func (m *ApprovalTicketMutation) ResetInstanceSizeSnapshot() {
	m.instance_size_snapshot = nil
	delete(m.clearedFields, approvalticket.FieldInstanceSizeSnapshot)
}

// SetModifiedSpec sets the "modified_spec" field.
func (m *ApprovalTicketMutation) SetModifiedSpec(value map[string]interface{}) {
	m.modified_spec = &value
}

// ModifiedSpec returns the value of the "modified_spec" field in the mutation.
func (m *ApprovalTicketMutation) ModifiedSpec() (r map[string]interface{}, exists bool) {
	v := m.modified_spec
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedSpec returns the old "modified_spec" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldModifiedSpec(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedSpec: %w", err)
	}
	return oldValue.ModifiedSpec, nil
}

// ClearModifiedSpec clears the value of the "modified_spec" field.
func (m *ApprovalTicketMutation) ClearModifiedSpec() {
	m.modified_spec = nil
	m.clearedFields[approvalticket.FieldModifiedSpec] = struct{}{}
}

// ModifiedSpecCleared returns if the "modified_spec" field was cleared in this mutation.
func (m *ApprovalTicketMutation) ModifiedSpecCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldModifiedSpec]
	return ok
}

// ResetModifiedSpec resets all changes to the "modified_spec" field.
func (m *ApprovalTicketMutation) ResetModifiedSpec() {
	m.modified_spec = nil
	delete(m.clearedFields, approvalticket.FieldModifiedSpec)
}

// SetParentTicketID sets the "parent_ticket_id" field.
func (m *ApprovalTicketMutation) SetParentTicketID(s string) {
	m.parent_ticket_id = &s
}

// ParentTicketID returns the value of the "parent_ticket_id" field in the mutation.
func (m *ApprovalTicketMutation) ParentTicketID() (r string, exists bool) {
	v := m.parent_ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentTicketID returns the old "parent_ticket_id" field's value of the ApprovalTicket entity.
// If the ApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApprovalTicketMutation) OldParentTicketID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentTicketID: %w", err)
	}
	return oldValue.ParentTicketID, nil
}

// ClearParentTicketID clears the value of the "parent_ticket_id" field.
func (m *ApprovalTicketMutation) ClearParentTicketID() {
	m.parent_ticket_id = nil
	m.clearedFields[approvalticket.FieldParentTicketID] = struct{}{}
}

// ParentTicketIDCleared returns if the "parent_ticket_id" field was cleared in this mutation.
func (m *ApprovalTicketMutation) ParentTicketIDCleared() bool {
	_, ok := m.clearedFields[approvalticket.FieldParentTicketID]
	return ok
}

// ResetParentTicketID resets all changes to the "parent_ticket_id" field.
func (m *ApprovalTicketMutation) ResetParentTicketID() {
	m.parent_ticket_id = nil
	delete(m.clearedFields, approvalticket.FieldParentTicketID)
}

// Where appends a list predicates to the ApprovalTicketMutation builder.
func (m *ApprovalTicketMutation) Where(ps ...predicate.ApprovalTicket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApprovalTicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApprovalTicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApprovalTicket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApprovalTicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApprovalTicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApprovalTicket).
func (m *ApprovalTicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApprovalTicketMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, approvalticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approvalticket.FieldUpdatedAt)
	}
	if m.event_id != nil {
		fields = append(fields, approvalticket.FieldEventID)
	}
	if m.operation_type != nil {
		fields = append(fields, approvalticket.FieldOperationType)
	}
	if m.status != nil {
		fields = append(fields, approvalticket.FieldStatus)
	}
	if m.requester != nil {
		fields = append(fields, approvalticket.FieldRequester)
	}
	if m.approver != nil {
		fields = append(fields, approvalticket.FieldApprover)
	}
	if m.reason != nil {
		fields = append(fields, approvalticket.FieldReason)
	}
	if m.reject_reason != nil {
		fields = append(fields, approvalticket.FieldRejectReason)
	}
	if m.selected_cluster_id != nil {
		fields = append(fields, approvalticket.FieldSelectedClusterID)
	}
	if m.selected_template_version != nil {
		fields = append(fields, approvalticket.FieldSelectedTemplateVersion)
	}
	if m.selected_storage_class != nil {
		fields = append(fields, approvalticket.FieldSelectedStorageClass)
	}
	if m.template_snapshot != nil {
		fields = append(fields, approvalticket.FieldTemplateSnapshot)
	}
	if m.instance_size_snapshot != nil {
		fields = append(fields, approvalticket.FieldInstanceSizeSnapshot)
	}
	if m.modified_spec != nil {
		fields = append(fields, approvalticket.FieldModifiedSpec)
	}
	if m.parent_ticket_id != nil {
		fields = append(fields, approvalticket.FieldParentTicketID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApprovalTicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approvalticket.FieldCreatedAt:
		return m.CreatedAt()
	case approvalticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case approvalticket.FieldEventID:
		return m.EventID()
	case approvalticket.FieldOperationType:
		return m.OperationType()
	case approvalticket.FieldStatus:
		return m.Status()
	case approvalticket.FieldRequester:
		return m.Requester()
	case approvalticket.FieldApprover:
		return m.Approver()
	case approvalticket.FieldReason:
		return m.Reason()
	case approvalticket.FieldRejectReason:
		return m.RejectReason()
	case approvalticket.FieldSelectedClusterID:
		return m.SelectedClusterID()
	case approvalticket.FieldSelectedTemplateVersion:
		return m.SelectedTemplateVersion()
	case approvalticket.FieldSelectedStorageClass:
		return m.SelectedStorageClass()
	case approvalticket.FieldTemplateSnapshot:
		return m.TemplateSnapshot()
	case approvalticket.FieldInstanceSizeSnapshot:
		return m.InstanceSizeSnapshot()
	case approvalticket.FieldModifiedSpec:
		return m.ModifiedSpec()
	case approvalticket.FieldParentTicketID:
		return m.ParentTicketID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApprovalTicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approvalticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approvalticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approvalticket.FieldEventID:
		return m.OldEventID(ctx)
	case approvalticket.FieldOperationType:
		return m.OldOperationType(ctx)
	case approvalticket.FieldStatus:
		return m.OldStatus(ctx)
	case approvalticket.FieldRequester:
		return m.OldRequester(ctx)
	case approvalticket.FieldApprover:
		return m.OldApprover(ctx)
	case approvalticket.FieldReason:
		return m.OldReason(ctx)
	case approvalticket.FieldRejectReason:
		return m.OldRejectReason(ctx)
	case approvalticket.FieldSelectedClusterID:
		return m.OldSelectedClusterID(ctx)
	case approvalticket.FieldSelectedTemplateVersion:
		return m.OldSelectedTemplateVersion(ctx)
	case approvalticket.FieldSelectedStorageClass:
		return m.OldSelectedStorageClass(ctx)
	case approvalticket.FieldTemplateSnapshot:
		return m.OldTemplateSnapshot(ctx)
	case approvalticket.FieldInstanceSizeSnapshot:
		return m.OldInstanceSizeSnapshot(ctx)
	case approvalticket.FieldModifiedSpec:
		return m.OldModifiedSpec(ctx)
	case approvalticket.FieldParentTicketID:
		return m.OldParentTicketID(ctx)
	}
	return nil, fmt.Errorf("unknown ApprovalTicket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalTicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approvalticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approvalticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approvalticket.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case approvalticket.FieldOperationType:
		v, ok := value.(approvalticket.OperationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case approvalticket.FieldStatus:
		v, ok := value.(approvalticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case approvalticket.FieldRequester:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequester(v)
		return nil
	case approvalticket.FieldApprover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprover(v)
		return nil
	case approvalticket.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case approvalticket.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	case approvalticket.FieldSelectedClusterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedClusterID(v)
		return nil
	case approvalticket.FieldSelectedTemplateVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedTemplateVersion(v)
		return nil
	case approvalticket.FieldSelectedStorageClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedStorageClass(v)
		return nil
	case approvalticket.FieldTemplateSnapshot:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateSnapshot(v)
		return nil
	case approvalticket.FieldInstanceSizeSnapshot:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceSizeSnapshot(v)
		return nil
	case approvalticket.FieldModifiedSpec:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedSpec(v)
		return nil
	case approvalticket.FieldParentTicketID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentTicketID(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalTicket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApprovalTicketMutation) AddedFields() []string {
	var fields []string
	if m.addselected_template_version != nil {
		fields = append(fields, approvalticket.FieldSelectedTemplateVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApprovalTicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approvalticket.FieldSelectedTemplateVersion:
		return m.AddedSelectedTemplateVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApprovalTicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approvalticket.FieldSelectedTemplateVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelectedTemplateVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ApprovalTicket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApprovalTicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approvalticket.FieldApprover) {
		fields = append(fields, approvalticket.FieldApprover)
	}
	if m.FieldCleared(approvalticket.FieldReason) {
		fields = append(fields, approvalticket.FieldReason)
	}
	if m.FieldCleared(approvalticket.FieldRejectReason) {
		fields = append(fields, approvalticket.FieldRejectReason)
	}
	if m.FieldCleared(approvalticket.FieldSelectedClusterID) {
		fields = append(fields, approvalticket.FieldSelectedClusterID)
	}
	if m.FieldCleared(approvalticket.FieldSelectedTemplateVersion) {
		fields = append(fields, approvalticket.FieldSelectedTemplateVersion)
	}
	if m.FieldCleared(approvalticket.FieldSelectedStorageClass) {
		fields = append(fields, approvalticket.FieldSelectedStorageClass)
	}
	if m.FieldCleared(approvalticket.FieldTemplateSnapshot) {
		fields = append(fields, approvalticket.FieldTemplateSnapshot)
	}
	if m.FieldCleared(approvalticket.FieldInstanceSizeSnapshot) {
		fields = append(fields, approvalticket.FieldInstanceSizeSnapshot)
	}
	if m.FieldCleared(approvalticket.FieldModifiedSpec) {
		fields = append(fields, approvalticket.FieldModifiedSpec)
	}
	if m.FieldCleared(approvalticket.FieldParentTicketID) {
		fields = append(fields, approvalticket.FieldParentTicketID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApprovalTicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApprovalTicketMutation) ClearField(name string) error {
	switch name {
	case approvalticket.FieldApprover:
		m.ClearApprover()
		return nil
	case approvalticket.FieldReason:
		m.ClearReason()
		return nil
	case approvalticket.FieldRejectReason:
		m.ClearRejectReason()
		return nil
	case approvalticket.FieldSelectedClusterID:
		m.ClearSelectedClusterID()
		return nil
	case approvalticket.FieldSelectedTemplateVersion:
		m.ClearSelectedTemplateVersion()
		return nil
	case approvalticket.FieldSelectedStorageClass:
		m.ClearSelectedStorageClass()
		return nil
	case approvalticket.FieldTemplateSnapshot:
		m.ClearTemplateSnapshot()
		return nil
	case approvalticket.FieldInstanceSizeSnapshot:
		m.ClearInstanceSizeSnapshot()
		return nil
	case approvalticket.FieldModifiedSpec:
		m.ClearModifiedSpec()
		return nil
	case approvalticket.FieldParentTicketID:
		m.ClearParentTicketID()
		return nil
	}
	return fmt.Errorf("unknown ApprovalTicket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApprovalTicketMutation) ResetField(name string) error {
	switch name {
	case approvalticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approvalticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approvalticket.FieldEventID:
		m.ResetEventID()
		return nil
	case approvalticket.FieldOperationType:
		m.ResetOperationType()
		return nil
	case approvalticket.FieldStatus:
		m.ResetStatus()
		return nil
	case approvalticket.FieldRequester:
		m.ResetRequester()
		return nil
	case approvalticket.FieldApprover:
		m.ResetApprover()
		return nil
	case approvalticket.FieldReason:
		m.ResetReason()
		return nil
	case approvalticket.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	case approvalticket.FieldSelectedClusterID:
		m.ResetSelectedClusterID()
		return nil
	case approvalticket.FieldSelectedTemplateVersion:
		m.ResetSelectedTemplateVersion()
		return nil
	case approvalticket.FieldSelectedStorageClass:
		m.ResetSelectedStorageClass()
		return nil
	case approvalticket.FieldTemplateSnapshot:
		m.ResetTemplateSnapshot()
		return nil
	case approvalticket.FieldInstanceSizeSnapshot:
		m.ResetInstanceSizeSnapshot()
		return nil
	case approvalticket.FieldModifiedSpec:
		m.ResetModifiedSpec()
		return nil
	case approvalticket.FieldParentTicketID:
		m.ResetParentTicketID()
		return nil
	}
	return fmt.Errorf("unknown ApprovalTicket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApprovalTicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApprovalTicketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApprovalTicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApprovalTicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApprovalTicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApprovalTicketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApprovalTicketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApprovalTicket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApprovalTicketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApprovalTicket edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	action        *string
	resource_type *string
	resource_id   *string
	actor         *string
	details       *map[string]interface{}
	ip_address    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id string) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetActor sets the "actor" field.
func (m *AuditLogMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *AuditLogMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ResetActor resets all changes to the "actor" field.
func (m *AuditLogMutation) ResetActor() {
	m.actor = nil
}

// SetDetails sets the "details" field.
func (m *AuditLogMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *AuditLogMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *AuditLogMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[auditlog.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *AuditLogMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *AuditLogMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, auditlog.FieldDetails)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[auditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, auditlog.FieldIPAddress)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.actor != nil {
		fields = append(fields, auditlog.FieldActor)
	}
	if m.details != nil {
		fields = append(fields, auditlog.FieldDetails)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldActor:
		return m.Actor()
	case auditlog.FieldDetails:
		return m.Details()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldActor:
		return m.OldActor(ctx)
	case auditlog.FieldDetails:
		return m.OldDetails(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case auditlog.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldDetails) {
		fields = append(fields, auditlog.FieldDetails)
	}
	if m.FieldCleared(auditlog.FieldIPAddress) {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldDetails:
		m.ClearDetails()
		return nil
	case auditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldActor:
		m.ResetActor()
		return nil
	case auditlog.FieldDetails:
		m.ResetDetails()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// AuthProviderMutation represents an operation that mutates the AuthProvider nodes in the graph.
type AuthProviderMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	auth_type     *string
	_config       *map[string]interface{}
	enabled       *bool
	sort_order    *int
	addsort_order *int
	created_by    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthProvider, error)
	predicates    []predicate.AuthProvider
}

var _ ent.Mutation = (*AuthProviderMutation)(nil)

// authproviderOption allows management of the mutation configuration using functional options.
type authproviderOption func(*AuthProviderMutation)

// newAuthProviderMutation creates new mutation for the AuthProvider entity.
func newAuthProviderMutation(c config, op Op, opts ...authproviderOption) *AuthProviderMutation {
	m := &AuthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthProviderID sets the ID field of the mutation.
func withAuthProviderID(id string) authproviderOption {
	return func(m *AuthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthProvider
		)
		m.oldValue = func(ctx context.Context) (*AuthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthProvider sets the old AuthProvider of the mutation.
func withAuthProvider(node *AuthProvider) authproviderOption {
	return func(m *AuthProviderMutation) {
		m.oldValue = func(context.Context) (*AuthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthProvider entities.
func (m *AuthProviderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthProviderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthProviderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AuthProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthProviderMutation) ResetName() {
	m.name = nil
}

// SetAuthType sets the "auth_type" field.
func (m *AuthProviderMutation) SetAuthType(s string) {
	m.auth_type = &s
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *AuthProviderMutation) AuthType() (r string, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldAuthType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *AuthProviderMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetConfig sets the "config" field.
func (m *AuthProviderMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *AuthProviderMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *AuthProviderMutation) ResetConfig() {
	m._config = nil
}

// SetEnabled sets the "enabled" field.
func (m *AuthProviderMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AuthProviderMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AuthProviderMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *AuthProviderMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AuthProviderMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AuthProviderMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AuthProviderMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AuthProviderMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AuthProviderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuthProviderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuthProviderMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the AuthProviderMutation builder.
func (m *AuthProviderMutation) Where(ps ...predicate.AuthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthProvider).
func (m *AuthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthProviderMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, authprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authprovider.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, authprovider.FieldName)
	}
	if m.auth_type != nil {
		fields = append(fields, authprovider.FieldAuthType)
	}
	if m._config != nil {
		fields = append(fields, authprovider.FieldConfig)
	}
	if m.enabled != nil {
		fields = append(fields, authprovider.FieldEnabled)
	}
	if m.sort_order != nil {
		fields = append(fields, authprovider.FieldSortOrder)
	}
	if m.created_by != nil {
		fields = append(fields, authprovider.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authprovider.FieldCreatedAt:
		return m.CreatedAt()
	case authprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case authprovider.FieldName:
		return m.Name()
	case authprovider.FieldAuthType:
		return m.AuthType()
	case authprovider.FieldConfig:
		return m.Config()
	case authprovider.FieldEnabled:
		return m.Enabled()
	case authprovider.FieldSortOrder:
		return m.SortOrder()
	case authprovider.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authprovider.FieldName:
		return m.OldName(ctx)
	case authprovider.FieldAuthType:
		return m.OldAuthType(ctx)
	case authprovider.FieldConfig:
		return m.OldConfig(ctx)
	case authprovider.FieldEnabled:
		return m.OldEnabled(ctx)
	case authprovider.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case authprovider.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown AuthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authprovider.FieldAuthType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case authprovider.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case authprovider.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case authprovider.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case authprovider.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AuthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthProviderMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, authprovider.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authprovider.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authprovider.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AuthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthProviderMutation) ResetField(name string) error {
	switch name {
	case authprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authprovider.FieldName:
		m.ResetName()
		return nil
	case authprovider.FieldAuthType:
		m.ResetAuthType()
		return nil
	case authprovider.FieldConfig:
		m.ResetConfig()
		return nil
	case authprovider.FieldEnabled:
		m.ResetEnabled()
		return nil
	case authprovider.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case authprovider.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown AuthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthProviderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthProviderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthProviderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthProviderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthProvider edge %s", name)
}

// BatchApprovalTicketMutation represents an operation that mutates the BatchApprovalTicket nodes in the graph.
type BatchApprovalTicketMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	batch_type       *batchapprovalticket.BatchType
	child_count      *int
	addchild_count   *int
	success_count    *int
	addsuccess_count *int
	failed_count     *int
	addfailed_count  *int
	pending_count    *int
	addpending_count *int
	status           *batchapprovalticket.Status
	request_id       *string
	created_by       *string
	reason           *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*BatchApprovalTicket, error)
	predicates       []predicate.BatchApprovalTicket
}

var _ ent.Mutation = (*BatchApprovalTicketMutation)(nil)

// batchapprovalticketOption allows management of the mutation configuration using functional options.
type batchapprovalticketOption func(*BatchApprovalTicketMutation)

// newBatchApprovalTicketMutation creates new mutation for the BatchApprovalTicket entity.
func newBatchApprovalTicketMutation(c config, op Op, opts ...batchapprovalticketOption) *BatchApprovalTicketMutation {
	m := &BatchApprovalTicketMutation{
		config:        c,
		op:            op,
		typ:           TypeBatchApprovalTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatchApprovalTicketID sets the ID field of the mutation.
func withBatchApprovalTicketID(id string) batchapprovalticketOption {
	return func(m *BatchApprovalTicketMutation) {
		var (
			err   error
			once  sync.Once
			value *BatchApprovalTicket
		)
		m.oldValue = func(ctx context.Context) (*BatchApprovalTicket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatchApprovalTicket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatchApprovalTicket sets the old BatchApprovalTicket of the mutation.
func withBatchApprovalTicket(node *BatchApprovalTicket) batchapprovalticketOption {
	return func(m *BatchApprovalTicketMutation) {
		m.oldValue = func(context.Context) (*BatchApprovalTicket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatchApprovalTicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatchApprovalTicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BatchApprovalTicket entities.
func (m *BatchApprovalTicketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatchApprovalTicketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatchApprovalTicketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatchApprovalTicket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatchApprovalTicketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatchApprovalTicketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatchApprovalTicketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatchApprovalTicketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatchApprovalTicketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatchApprovalTicketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBatchType sets the "batch_type" field.
func (m *BatchApprovalTicketMutation) SetBatchType(bt batchapprovalticket.BatchType) {
	m.batch_type = &bt
}

// BatchType returns the value of the "batch_type" field in the mutation.
func (m *BatchApprovalTicketMutation) BatchType() (r batchapprovalticket.BatchType, exists bool) {
	v := m.batch_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchType returns the old "batch_type" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldBatchType(ctx context.Context) (v batchapprovalticket.BatchType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchType: %w", err)
	}
	return oldValue.BatchType, nil
}

// ResetBatchType resets all changes to the "batch_type" field.
func (m *BatchApprovalTicketMutation) ResetBatchType() {
	m.batch_type = nil
}

// SetChildCount sets the "child_count" field.
func (m *BatchApprovalTicketMutation) SetChildCount(i int) {
	m.child_count = &i
	m.addchild_count = nil
}

// ChildCount returns the value of the "child_count" field in the mutation.
func (m *BatchApprovalTicketMutation) ChildCount() (r int, exists bool) {
	v := m.child_count
	if v == nil {
		return
	}
	return *v, true
}

// OldChildCount returns the old "child_count" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldChildCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChildCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChildCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChildCount: %w", err)
	}
	return oldValue.ChildCount, nil
}

// AddChildCount adds i to the "child_count" field.
func (m *BatchApprovalTicketMutation) AddChildCount(i int) {
	if m.addchild_count != nil {
		*m.addchild_count += i
	} else {
		m.addchild_count = &i
	}
}

// AddedChildCount returns the value that was added to the "child_count" field in this mutation.
func (m *BatchApprovalTicketMutation) AddedChildCount() (r int, exists bool) {
	v := m.addchild_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetChildCount resets all changes to the "child_count" field.
func (m *BatchApprovalTicketMutation) ResetChildCount() {
	m.child_count = nil
	m.addchild_count = nil
}

// SetSuccessCount sets the "success_count" field.
func (m *BatchApprovalTicketMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *BatchApprovalTicketMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *BatchApprovalTicketMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *BatchApprovalTicketMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *BatchApprovalTicketMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailedCount sets the "failed_count" field.
func (m *BatchApprovalTicketMutation) SetFailedCount(i int) {
	m.failed_count = &i
	m.addfailed_count = nil
}

// FailedCount returns the value of the "failed_count" field in the mutation.
func (m *BatchApprovalTicketMutation) FailedCount() (r int, exists bool) {
	v := m.failed_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedCount returns the old "failed_count" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldFailedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedCount: %w", err)
	}
	return oldValue.FailedCount, nil
}

// AddFailedCount adds i to the "failed_count" field.
func (m *BatchApprovalTicketMutation) AddFailedCount(i int) {
	if m.addfailed_count != nil {
		*m.addfailed_count += i
	} else {
		m.addfailed_count = &i
	}
}

// AddedFailedCount returns the value that was added to the "failed_count" field in this mutation.
func (m *BatchApprovalTicketMutation) AddedFailedCount() (r int, exists bool) {
	v := m.addfailed_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedCount resets all changes to the "failed_count" field.
func (m *BatchApprovalTicketMutation) ResetFailedCount() {
	m.failed_count = nil
	m.addfailed_count = nil
}

// SetPendingCount sets the "pending_count" field.
func (m *BatchApprovalTicketMutation) SetPendingCount(i int) {
	m.pending_count = &i
	m.addpending_count = nil
}

// PendingCount returns the value of the "pending_count" field in the mutation.
func (m *BatchApprovalTicketMutation) PendingCount() (r int, exists bool) {
	v := m.pending_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingCount returns the old "pending_count" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldPendingCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingCount: %w", err)
	}
	return oldValue.PendingCount, nil
}

// AddPendingCount adds i to the "pending_count" field.
func (m *BatchApprovalTicketMutation) AddPendingCount(i int) {
	if m.addpending_count != nil {
		*m.addpending_count += i
	} else {
		m.addpending_count = &i
	}
}

// AddedPendingCount returns the value that was added to the "pending_count" field in this mutation.
func (m *BatchApprovalTicketMutation) AddedPendingCount() (r int, exists bool) {
	v := m.addpending_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPendingCount resets all changes to the "pending_count" field.
func (m *BatchApprovalTicketMutation) ResetPendingCount() {
	m.pending_count = nil
	m.addpending_count = nil
}

// SetStatus sets the "status" field.
func (m *BatchApprovalTicketMutation) SetStatus(b batchapprovalticket.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BatchApprovalTicketMutation) Status() (r batchapprovalticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldStatus(ctx context.Context) (v batchapprovalticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BatchApprovalTicketMutation) ResetStatus() {
	m.status = nil
}

// SetRequestID sets the "request_id" field.
func (m *BatchApprovalTicketMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *BatchApprovalTicketMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldRequestID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *BatchApprovalTicketMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[batchapprovalticket.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *BatchApprovalTicketMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[batchapprovalticket.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *BatchApprovalTicketMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, batchapprovalticket.FieldRequestID)
}

// SetCreatedBy sets the "created_by" field.
func (m *BatchApprovalTicketMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *BatchApprovalTicketMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *BatchApprovalTicketMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetReason sets the "reason" field.
func (m *BatchApprovalTicketMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *BatchApprovalTicketMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the BatchApprovalTicket entity.
// If the BatchApprovalTicket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatchApprovalTicketMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *BatchApprovalTicketMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[batchapprovalticket.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *BatchApprovalTicketMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[batchapprovalticket.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *BatchApprovalTicketMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, batchapprovalticket.FieldReason)
}

// Where appends a list predicates to the BatchApprovalTicketMutation builder.
func (m *BatchApprovalTicketMutation) Where(ps ...predicate.BatchApprovalTicket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatchApprovalTicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatchApprovalTicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BatchApprovalTicket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatchApprovalTicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatchApprovalTicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BatchApprovalTicket).
func (m *BatchApprovalTicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatchApprovalTicketMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, batchapprovalticket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batchapprovalticket.FieldUpdatedAt)
	}
	if m.batch_type != nil {
		fields = append(fields, batchapprovalticket.FieldBatchType)
	}
	if m.child_count != nil {
		fields = append(fields, batchapprovalticket.FieldChildCount)
	}
	if m.success_count != nil {
		fields = append(fields, batchapprovalticket.FieldSuccessCount)
	}
	if m.failed_count != nil {
		fields = append(fields, batchapprovalticket.FieldFailedCount)
	}
	if m.pending_count != nil {
		fields = append(fields, batchapprovalticket.FieldPendingCount)
	}
	if m.status != nil {
		fields = append(fields, batchapprovalticket.FieldStatus)
	}
	if m.request_id != nil {
		fields = append(fields, batchapprovalticket.FieldRequestID)
	}
	if m.created_by != nil {
		fields = append(fields, batchapprovalticket.FieldCreatedBy)
	}
	if m.reason != nil {
		fields = append(fields, batchapprovalticket.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatchApprovalTicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batchapprovalticket.FieldCreatedAt:
		return m.CreatedAt()
	case batchapprovalticket.FieldUpdatedAt:
		return m.UpdatedAt()
	case batchapprovalticket.FieldBatchType:
		return m.BatchType()
	case batchapprovalticket.FieldChildCount:
		return m.ChildCount()
	case batchapprovalticket.FieldSuccessCount:
		return m.SuccessCount()
	case batchapprovalticket.FieldFailedCount:
		return m.FailedCount()
	case batchapprovalticket.FieldPendingCount:
		return m.PendingCount()
	case batchapprovalticket.FieldStatus:
		return m.Status()
	case batchapprovalticket.FieldRequestID:
		return m.RequestID()
	case batchapprovalticket.FieldCreatedBy:
		return m.CreatedBy()
	case batchapprovalticket.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatchApprovalTicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batchapprovalticket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batchapprovalticket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case batchapprovalticket.FieldBatchType:
		return m.OldBatchType(ctx)
	case batchapprovalticket.FieldChildCount:
		return m.OldChildCount(ctx)
	case batchapprovalticket.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case batchapprovalticket.FieldFailedCount:
		return m.OldFailedCount(ctx)
	case batchapprovalticket.FieldPendingCount:
		return m.OldPendingCount(ctx)
	case batchapprovalticket.FieldStatus:
		return m.OldStatus(ctx)
	case batchapprovalticket.FieldRequestID:
		return m.OldRequestID(ctx)
	case batchapprovalticket.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case batchapprovalticket.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown BatchApprovalTicket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatchApprovalTicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batchapprovalticket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batchapprovalticket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case batchapprovalticket.FieldBatchType:
		v, ok := value.(batchapprovalticket.BatchType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchType(v)
		return nil
	case batchapprovalticket.FieldChildCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChildCount(v)
		return nil
	case batchapprovalticket.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case batchapprovalticket.FieldFailedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedCount(v)
		return nil
	case batchapprovalticket.FieldPendingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingCount(v)
		return nil
	case batchapprovalticket.FieldStatus:
		v, ok := value.(batchapprovalticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case batchapprovalticket.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case batchapprovalticket.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case batchapprovalticket.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown BatchApprovalTicket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatchApprovalTicketMutation) AddedFields() []string {
	var fields []string
	if m.addchild_count != nil {
		fields = append(fields, batchapprovalticket.FieldChildCount)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, batchapprovalticket.FieldSuccessCount)
	}
	if m.addfailed_count != nil {
		fields = append(fields, batchapprovalticket.FieldFailedCount)
	}
	if m.addpending_count != nil {
		fields = append(fields, batchapprovalticket.FieldPendingCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatchApprovalTicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case batchapprovalticket.FieldChildCount:
		return m.AddedChildCount()
	case batchapprovalticket.FieldSuccessCount:
		return m.AddedSuccessCount()
	case batchapprovalticket.FieldFailedCount:
		return m.AddedFailedCount()
	case batchapprovalticket.FieldPendingCount:
		return m.AddedPendingCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatchApprovalTicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case batchapprovalticket.FieldChildCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChildCount(v)
		return nil
	case batchapprovalticket.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case batchapprovalticket.FieldFailedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedCount(v)
		return nil
	case batchapprovalticket.FieldPendingCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPendingCount(v)
		return nil
	}
	return fmt.Errorf("unknown BatchApprovalTicket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatchApprovalTicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(batchapprovalticket.FieldRequestID) {
		fields = append(fields, batchapprovalticket.FieldRequestID)
	}
	if m.FieldCleared(batchapprovalticket.FieldReason) {
		fields = append(fields, batchapprovalticket.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatchApprovalTicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatchApprovalTicketMutation) ClearField(name string) error {
	switch name {
	case batchapprovalticket.FieldRequestID:
		m.ClearRequestID()
		return nil
	case batchapprovalticket.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown BatchApprovalTicket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatchApprovalTicketMutation) ResetField(name string) error {
	switch name {
	case batchapprovalticket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batchapprovalticket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case batchapprovalticket.FieldBatchType:
		m.ResetBatchType()
		return nil
	case batchapprovalticket.FieldChildCount:
		m.ResetChildCount()
		return nil
	case batchapprovalticket.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case batchapprovalticket.FieldFailedCount:
		m.ResetFailedCount()
		return nil
	case batchapprovalticket.FieldPendingCount:
		m.ResetPendingCount()
		return nil
	case batchapprovalticket.FieldStatus:
		m.ResetStatus()
		return nil
	case batchapprovalticket.FieldRequestID:
		m.ResetRequestID()
		return nil
	case batchapprovalticket.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case batchapprovalticket.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown BatchApprovalTicket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatchApprovalTicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatchApprovalTicketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatchApprovalTicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatchApprovalTicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatchApprovalTicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatchApprovalTicketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatchApprovalTicketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BatchApprovalTicket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatchApprovalTicketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BatchApprovalTicket edge %s", name)
}

// ClusterMutation represents an operation that mutates the Cluster nodes in the graph.
type ClusterMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	name                       *string
	display_name               *string
	api_server_url             *string
	encrypted_kubeconfig       *[]byte
	encryption_key_id          *string
	status                     *cluster.Status
	kubevirt_version           *string
	enabled_features           *[]string
	appendenabled_features     []string
	created_by                 *string
	environment                *cluster.Environment
	storage_classes            *[]string
	appendstorage_classes      []string
	default_storage_class      *string
	storage_classes_updated_at *time.Time
	enabled                    *bool
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Cluster, error)
	predicates                 []predicate.Cluster
}

var _ ent.Mutation = (*ClusterMutation)(nil)

// clusterOption allows management of the mutation configuration using functional options.
type clusterOption func(*ClusterMutation)

// newClusterMutation creates new mutation for the Cluster entity.
func newClusterMutation(c config, op Op, opts ...clusterOption) *ClusterMutation {
	m := &ClusterMutation{
		config:        c,
		op:            op,
		typ:           TypeCluster,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClusterID sets the ID field of the mutation.
func withClusterID(id string) clusterOption {
	return func(m *ClusterMutation) {
		var (
			err   error
			once  sync.Once
			value *Cluster
		)
		m.oldValue = func(ctx context.Context) (*Cluster, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cluster.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCluster sets the old Cluster of the mutation.
func withCluster(node *Cluster) clusterOption {
	return func(m *ClusterMutation) {
		m.oldValue = func(context.Context) (*Cluster, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClusterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClusterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cluster entities.
func (m *ClusterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClusterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClusterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cluster.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClusterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClusterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClusterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClusterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClusterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClusterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ClusterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClusterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClusterMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ClusterMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ClusterMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *ClusterMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[cluster.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *ClusterMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[cluster.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ClusterMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, cluster.FieldDisplayName)
}

// SetAPIServerURL sets the "api_server_url" field.
func (m *ClusterMutation) SetAPIServerURL(s string) {
	m.api_server_url = &s
}

// APIServerURL returns the value of the "api_server_url" field in the mutation.
func (m *ClusterMutation) APIServerURL() (r string, exists bool) {
	v := m.api_server_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIServerURL returns the old "api_server_url" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldAPIServerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIServerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIServerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIServerURL: %w", err)
	}
	return oldValue.APIServerURL, nil
}

// ResetAPIServerURL resets all changes to the "api_server_url" field.
func (m *ClusterMutation) ResetAPIServerURL() {
	m.api_server_url = nil
}

// SetEncryptedKubeconfig sets the "encrypted_kubeconfig" field.
func (m *ClusterMutation) SetEncryptedKubeconfig(b []byte) {
	m.encrypted_kubeconfig = &b
}

// EncryptedKubeconfig returns the value of the "encrypted_kubeconfig" field in the mutation.
func (m *ClusterMutation) EncryptedKubeconfig() (r []byte, exists bool) {
	v := m.encrypted_kubeconfig
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptedKubeconfig returns the old "encrypted_kubeconfig" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldEncryptedKubeconfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptedKubeconfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptedKubeconfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptedKubeconfig: %w", err)
	}
	return oldValue.EncryptedKubeconfig, nil
}

// ResetEncryptedKubeconfig resets all changes to the "encrypted_kubeconfig" field.
func (m *ClusterMutation) ResetEncryptedKubeconfig() {
	m.encrypted_kubeconfig = nil
}

// SetEncryptionKeyID sets the "encryption_key_id" field.
func (m *ClusterMutation) SetEncryptionKeyID(s string) {
	m.encryption_key_id = &s
}

// EncryptionKeyID returns the value of the "encryption_key_id" field in the mutation.
func (m *ClusterMutation) EncryptionKeyID() (r string, exists bool) {
	v := m.encryption_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryptionKeyID returns the old "encryption_key_id" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldEncryptionKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryptionKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryptionKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryptionKeyID: %w", err)
	}
	return oldValue.EncryptionKeyID, nil
}

// ClearEncryptionKeyID clears the value of the "encryption_key_id" field.
func (m *ClusterMutation) ClearEncryptionKeyID() {
	m.encryption_key_id = nil
	m.clearedFields[cluster.FieldEncryptionKeyID] = struct{}{}
}

// EncryptionKeyIDCleared returns if the "encryption_key_id" field was cleared in this mutation.
func (m *ClusterMutation) EncryptionKeyIDCleared() bool {
	_, ok := m.clearedFields[cluster.FieldEncryptionKeyID]
	return ok
}

// ResetEncryptionKeyID resets all changes to the "encryption_key_id" field.
func (m *ClusterMutation) ResetEncryptionKeyID() {
	m.encryption_key_id = nil
	delete(m.clearedFields, cluster.FieldEncryptionKeyID)
}

// SetStatus sets the "status" field.
func (m *ClusterMutation) SetStatus(c cluster.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ClusterMutation) Status() (r cluster.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldStatus(ctx context.Context) (v cluster.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ClusterMutation) ResetStatus() {
	m.status = nil
}

// SetKubevirtVersion sets the "kubevirt_version" field.
func (m *ClusterMutation) SetKubevirtVersion(s string) {
	m.kubevirt_version = &s
}

// KubevirtVersion returns the value of the "kubevirt_version" field in the mutation.
func (m *ClusterMutation) KubevirtVersion() (r string, exists bool) {
	v := m.kubevirt_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKubevirtVersion returns the old "kubevirt_version" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldKubevirtVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKubevirtVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKubevirtVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKubevirtVersion: %w", err)
	}
	return oldValue.KubevirtVersion, nil
}

// ClearKubevirtVersion clears the value of the "kubevirt_version" field.
func (m *ClusterMutation) ClearKubevirtVersion() {
	m.kubevirt_version = nil
	m.clearedFields[cluster.FieldKubevirtVersion] = struct{}{}
}

// KubevirtVersionCleared returns if the "kubevirt_version" field was cleared in this mutation.
func (m *ClusterMutation) KubevirtVersionCleared() bool {
	_, ok := m.clearedFields[cluster.FieldKubevirtVersion]
	return ok
}

// ResetKubevirtVersion resets all changes to the "kubevirt_version" field.
func (m *ClusterMutation) ResetKubevirtVersion() {
	m.kubevirt_version = nil
	delete(m.clearedFields, cluster.FieldKubevirtVersion)
}

// SetEnabledFeatures sets the "enabled_features" field.
func (m *ClusterMutation) SetEnabledFeatures(s []string) {
	m.enabled_features = &s
	m.appendenabled_features = nil
}

// EnabledFeatures returns the value of the "enabled_features" field in the mutation.
func (m *ClusterMutation) EnabledFeatures() (r []string, exists bool) {
	v := m.enabled_features
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabledFeatures returns the old "enabled_features" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldEnabledFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabledFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabledFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabledFeatures: %w", err)
	}
	return oldValue.EnabledFeatures, nil
}

// AppendEnabledFeatures adds s to the "enabled_features" field.
func (m *ClusterMutation) AppendEnabledFeatures(s []string) {
	m.appendenabled_features = append(m.appendenabled_features, s...)
}

// AppendedEnabledFeatures returns the list of values that were appended to the "enabled_features" field in this mutation.
func (m *ClusterMutation) AppendedEnabledFeatures() ([]string, bool) {
	if len(m.appendenabled_features) == 0 {
		return nil, false
	}
	return m.appendenabled_features, true
}

// ClearEnabledFeatures clears the value of the "enabled_features" field.
func (m *ClusterMutation) ClearEnabledFeatures() {
	m.enabled_features = nil
	m.appendenabled_features = nil
	m.clearedFields[cluster.FieldEnabledFeatures] = struct{}{}
}

// EnabledFeaturesCleared returns if the "enabled_features" field was cleared in this mutation.
func (m *ClusterMutation) EnabledFeaturesCleared() bool {
	_, ok := m.clearedFields[cluster.FieldEnabledFeatures]
	return ok
}

// ResetEnabledFeatures resets all changes to the "enabled_features" field.
func (m *ClusterMutation) ResetEnabledFeatures() {
	m.enabled_features = nil
	m.appendenabled_features = nil
	delete(m.clearedFields, cluster.FieldEnabledFeatures)
}

// SetCreatedBy sets the "created_by" field.
func (m *ClusterMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ClusterMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ClusterMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetEnvironment sets the "environment" field.
func (m *ClusterMutation) SetEnvironment(c cluster.Environment) {
	m.environment = &c
}

// Environment returns the value of the "environment" field in the mutation.
func (m *ClusterMutation) Environment() (r cluster.Environment, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldEnvironment(ctx context.Context) (v cluster.Environment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *ClusterMutation) ResetEnvironment() {
	m.environment = nil
}

// SetStorageClasses sets the "storage_classes" field.
func (m *ClusterMutation) SetStorageClasses(s []string) {
	m.storage_classes = &s
	m.appendstorage_classes = nil
}

// StorageClasses returns the value of the "storage_classes" field in the mutation.
func (m *ClusterMutation) StorageClasses() (r []string, exists bool) {
	v := m.storage_classes
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageClasses returns the old "storage_classes" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldStorageClasses(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageClasses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageClasses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageClasses: %w", err)
	}
	return oldValue.StorageClasses, nil
}

// AppendStorageClasses adds s to the "storage_classes" field.
func (m *ClusterMutation) AppendStorageClasses(s []string) {
	m.appendstorage_classes = append(m.appendstorage_classes, s...)
}

// AppendedStorageClasses returns the list of values that were appended to the "storage_classes" field in this mutation.
func (m *ClusterMutation) AppendedStorageClasses() ([]string, bool) {
	if len(m.appendstorage_classes) == 0 {
		return nil, false
	}
	return m.appendstorage_classes, true
}

// ClearStorageClasses clears the value of the "storage_classes" field.
func (m *ClusterMutation) ClearStorageClasses() {
	m.storage_classes = nil
	m.appendstorage_classes = nil
	m.clearedFields[cluster.FieldStorageClasses] = struct{}{}
}

// StorageClassesCleared returns if the "storage_classes" field was cleared in this mutation.
func (m *ClusterMutation) StorageClassesCleared() bool {
	_, ok := m.clearedFields[cluster.FieldStorageClasses]
	return ok
}

// ResetStorageClasses resets all changes to the "storage_classes" field.
func (m *ClusterMutation) ResetStorageClasses() {
	m.storage_classes = nil
	m.appendstorage_classes = nil
	delete(m.clearedFields, cluster.FieldStorageClasses)
}

// SetDefaultStorageClass sets the "default_storage_class" field.
func (m *ClusterMutation) SetDefaultStorageClass(s string) {
	m.default_storage_class = &s
}

// DefaultStorageClass returns the value of the "default_storage_class" field in the mutation.
func (m *ClusterMutation) DefaultStorageClass() (r string, exists bool) {
	v := m.default_storage_class
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultStorageClass returns the old "default_storage_class" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldDefaultStorageClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultStorageClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultStorageClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultStorageClass: %w", err)
	}
	return oldValue.DefaultStorageClass, nil
}

// ClearDefaultStorageClass clears the value of the "default_storage_class" field.
func (m *ClusterMutation) ClearDefaultStorageClass() {
	m.default_storage_class = nil
	m.clearedFields[cluster.FieldDefaultStorageClass] = struct{}{}
}

// DefaultStorageClassCleared returns if the "default_storage_class" field was cleared in this mutation.
func (m *ClusterMutation) DefaultStorageClassCleared() bool {
	_, ok := m.clearedFields[cluster.FieldDefaultStorageClass]
	return ok
}

// ResetDefaultStorageClass resets all changes to the "default_storage_class" field.
func (m *ClusterMutation) ResetDefaultStorageClass() {
	m.default_storage_class = nil
	delete(m.clearedFields, cluster.FieldDefaultStorageClass)
}

// SetStorageClassesUpdatedAt sets the "storage_classes_updated_at" field.
func (m *ClusterMutation) SetStorageClassesUpdatedAt(t time.Time) {
	m.storage_classes_updated_at = &t
}

// StorageClassesUpdatedAt returns the value of the "storage_classes_updated_at" field in the mutation.
func (m *ClusterMutation) StorageClassesUpdatedAt() (r time.Time, exists bool) {
	v := m.storage_classes_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageClassesUpdatedAt returns the old "storage_classes_updated_at" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldStorageClassesUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageClassesUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageClassesUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageClassesUpdatedAt: %w", err)
	}
	return oldValue.StorageClassesUpdatedAt, nil
}

// ClearStorageClassesUpdatedAt clears the value of the "storage_classes_updated_at" field.
func (m *ClusterMutation) ClearStorageClassesUpdatedAt() {
	m.storage_classes_updated_at = nil
	m.clearedFields[cluster.FieldStorageClassesUpdatedAt] = struct{}{}
}

// StorageClassesUpdatedAtCleared returns if the "storage_classes_updated_at" field was cleared in this mutation.
func (m *ClusterMutation) StorageClassesUpdatedAtCleared() bool {
	_, ok := m.clearedFields[cluster.FieldStorageClassesUpdatedAt]
	return ok
}

// ResetStorageClassesUpdatedAt resets all changes to the "storage_classes_updated_at" field.
func (m *ClusterMutation) ResetStorageClassesUpdatedAt() {
	m.storage_classes_updated_at = nil
	delete(m.clearedFields, cluster.FieldStorageClassesUpdatedAt)
}

// SetEnabled sets the "enabled" field.
func (m *ClusterMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ClusterMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Cluster entity.
// If the Cluster object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClusterMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ClusterMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the ClusterMutation builder.
func (m *ClusterMutation) Where(ps ...predicate.Cluster) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClusterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClusterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cluster, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClusterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClusterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cluster).
func (m *ClusterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClusterMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, cluster.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cluster.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, cluster.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, cluster.FieldDisplayName)
	}
	if m.api_server_url != nil {
		fields = append(fields, cluster.FieldAPIServerURL)
	}
	if m.encrypted_kubeconfig != nil {
		fields = append(fields, cluster.FieldEncryptedKubeconfig)
	}
	if m.encryption_key_id != nil {
		fields = append(fields, cluster.FieldEncryptionKeyID)
	}
	if m.status != nil {
		fields = append(fields, cluster.FieldStatus)
	}
	if m.kubevirt_version != nil {
		fields = append(fields, cluster.FieldKubevirtVersion)
	}
	if m.enabled_features != nil {
		fields = append(fields, cluster.FieldEnabledFeatures)
	}
	if m.created_by != nil {
		fields = append(fields, cluster.FieldCreatedBy)
	}
	if m.environment != nil {
		fields = append(fields, cluster.FieldEnvironment)
	}
	if m.storage_classes != nil {
		fields = append(fields, cluster.FieldStorageClasses)
	}
	if m.default_storage_class != nil {
		fields = append(fields, cluster.FieldDefaultStorageClass)
	}
	if m.storage_classes_updated_at != nil {
		fields = append(fields, cluster.FieldStorageClassesUpdatedAt)
	}
	if m.enabled != nil {
		fields = append(fields, cluster.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClusterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cluster.FieldCreatedAt:
		return m.CreatedAt()
	case cluster.FieldUpdatedAt:
		return m.UpdatedAt()
	case cluster.FieldName:
		return m.Name()
	case cluster.FieldDisplayName:
		return m.DisplayName()
	case cluster.FieldAPIServerURL:
		return m.APIServerURL()
	case cluster.FieldEncryptedKubeconfig:
		return m.EncryptedKubeconfig()
	case cluster.FieldEncryptionKeyID:
		return m.EncryptionKeyID()
	case cluster.FieldStatus:
		return m.Status()
	case cluster.FieldKubevirtVersion:
		return m.KubevirtVersion()
	case cluster.FieldEnabledFeatures:
		return m.EnabledFeatures()
	case cluster.FieldCreatedBy:
		return m.CreatedBy()
	case cluster.FieldEnvironment:
		return m.Environment()
	case cluster.FieldStorageClasses:
		return m.StorageClasses()
	case cluster.FieldDefaultStorageClass:
		return m.DefaultStorageClass()
	case cluster.FieldStorageClassesUpdatedAt:
		return m.StorageClassesUpdatedAt()
	case cluster.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClusterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cluster.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cluster.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cluster.FieldName:
		return m.OldName(ctx)
	case cluster.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case cluster.FieldAPIServerURL:
		return m.OldAPIServerURL(ctx)
	case cluster.FieldEncryptedKubeconfig:
		return m.OldEncryptedKubeconfig(ctx)
	case cluster.FieldEncryptionKeyID:
		return m.OldEncryptionKeyID(ctx)
	case cluster.FieldStatus:
		return m.OldStatus(ctx)
	case cluster.FieldKubevirtVersion:
		return m.OldKubevirtVersion(ctx)
	case cluster.FieldEnabledFeatures:
		return m.OldEnabledFeatures(ctx)
	case cluster.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case cluster.FieldEnvironment:
		return m.OldEnvironment(ctx)
	case cluster.FieldStorageClasses:
		return m.OldStorageClasses(ctx)
	case cluster.FieldDefaultStorageClass:
		return m.OldDefaultStorageClass(ctx)
	case cluster.FieldStorageClassesUpdatedAt:
		return m.OldStorageClassesUpdatedAt(ctx)
	case cluster.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Cluster field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cluster.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cluster.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cluster.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cluster.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case cluster.FieldAPIServerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIServerURL(v)
		return nil
	case cluster.FieldEncryptedKubeconfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptedKubeconfig(v)
		return nil
	case cluster.FieldEncryptionKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryptionKeyID(v)
		return nil
	case cluster.FieldStatus:
		v, ok := value.(cluster.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cluster.FieldKubevirtVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKubevirtVersion(v)
		return nil
	case cluster.FieldEnabledFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabledFeatures(v)
		return nil
	case cluster.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case cluster.FieldEnvironment:
		v, ok := value.(cluster.Environment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	case cluster.FieldStorageClasses:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageClasses(v)
		return nil
	case cluster.FieldDefaultStorageClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultStorageClass(v)
		return nil
	case cluster.FieldStorageClassesUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageClassesUpdatedAt(v)
		return nil
	case cluster.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClusterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClusterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClusterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cluster numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClusterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cluster.FieldDisplayName) {
		fields = append(fields, cluster.FieldDisplayName)
	}
	if m.FieldCleared(cluster.FieldEncryptionKeyID) {
		fields = append(fields, cluster.FieldEncryptionKeyID)
	}
	if m.FieldCleared(cluster.FieldKubevirtVersion) {
		fields = append(fields, cluster.FieldKubevirtVersion)
	}
	if m.FieldCleared(cluster.FieldEnabledFeatures) {
		fields = append(fields, cluster.FieldEnabledFeatures)
	}
	if m.FieldCleared(cluster.FieldStorageClasses) {
		fields = append(fields, cluster.FieldStorageClasses)
	}
	if m.FieldCleared(cluster.FieldDefaultStorageClass) {
		fields = append(fields, cluster.FieldDefaultStorageClass)
	}
	if m.FieldCleared(cluster.FieldStorageClassesUpdatedAt) {
		fields = append(fields, cluster.FieldStorageClassesUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClusterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClusterMutation) ClearField(name string) error {
	switch name {
	case cluster.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case cluster.FieldEncryptionKeyID:
		m.ClearEncryptionKeyID()
		return nil
	case cluster.FieldKubevirtVersion:
		m.ClearKubevirtVersion()
		return nil
	case cluster.FieldEnabledFeatures:
		m.ClearEnabledFeatures()
		return nil
	case cluster.FieldStorageClasses:
		m.ClearStorageClasses()
		return nil
	case cluster.FieldDefaultStorageClass:
		m.ClearDefaultStorageClass()
		return nil
	case cluster.FieldStorageClassesUpdatedAt:
		m.ClearStorageClassesUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Cluster nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClusterMutation) ResetField(name string) error {
	switch name {
	case cluster.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cluster.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cluster.FieldName:
		m.ResetName()
		return nil
	case cluster.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case cluster.FieldAPIServerURL:
		m.ResetAPIServerURL()
		return nil
	case cluster.FieldEncryptedKubeconfig:
		m.ResetEncryptedKubeconfig()
		return nil
	case cluster.FieldEncryptionKeyID:
		m.ResetEncryptionKeyID()
		return nil
	case cluster.FieldStatus:
		m.ResetStatus()
		return nil
	case cluster.FieldKubevirtVersion:
		m.ResetKubevirtVersion()
		return nil
	case cluster.FieldEnabledFeatures:
		m.ResetEnabledFeatures()
		return nil
	case cluster.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case cluster.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	case cluster.FieldStorageClasses:
		m.ResetStorageClasses()
		return nil
	case cluster.FieldDefaultStorageClass:
		m.ResetDefaultStorageClass()
		return nil
	case cluster.FieldStorageClassesUpdatedAt:
		m.ResetStorageClassesUpdatedAt()
		return nil
	case cluster.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Cluster field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClusterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClusterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClusterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClusterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClusterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClusterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClusterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cluster unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClusterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cluster edge %s", name)
}

// DomainEventMutation represents an operation that mutates the DomainEvent nodes in the graph.
type DomainEventMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	event_type     *string
	aggregate_type *string
	aggregate_id   *string
	payload        *[]byte
	status         *domainevent.Status
	created_by     *string
	archived_at    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*DomainEvent, error)
	predicates     []predicate.DomainEvent
}

var _ ent.Mutation = (*DomainEventMutation)(nil)

// domaineventOption allows management of the mutation configuration using functional options.
type domaineventOption func(*DomainEventMutation)

// newDomainEventMutation creates new mutation for the DomainEvent entity.
func newDomainEventMutation(c config, op Op, opts ...domaineventOption) *DomainEventMutation {
	m := &DomainEventMutation{
		config:        c,
		op:            op,
		typ:           TypeDomainEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainEventID sets the ID field of the mutation.
func withDomainEventID(id string) domaineventOption {
	return func(m *DomainEventMutation) {
		var (
			err   error
			once  sync.Once
			value *DomainEvent
		)
		m.oldValue = func(ctx context.Context) (*DomainEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DomainEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomainEvent sets the old DomainEvent of the mutation.
func withDomainEvent(node *DomainEvent) domaineventOption {
	return func(m *DomainEventMutation) {
		m.oldValue = func(context.Context) (*DomainEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DomainEvent entities.
func (m *DomainEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DomainEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DomainEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DomainEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DomainEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEventType sets the "event_type" field.
func (m *DomainEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *DomainEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *DomainEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetAggregateType sets the "aggregate_type" field.
func (m *DomainEventMutation) SetAggregateType(s string) {
	m.aggregate_type = &s
}

// AggregateType returns the value of the "aggregate_type" field in the mutation.
func (m *DomainEventMutation) AggregateType() (r string, exists bool) {
	v := m.aggregate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateType returns the old "aggregate_type" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldAggregateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateType: %w", err)
	}
	return oldValue.AggregateType, nil
}

// ResetAggregateType resets all changes to the "aggregate_type" field.
func (m *DomainEventMutation) ResetAggregateType() {
	m.aggregate_type = nil
}

// SetAggregateID sets the "aggregate_id" field.
func (m *DomainEventMutation) SetAggregateID(s string) {
	m.aggregate_id = &s
}

// AggregateID returns the value of the "aggregate_id" field in the mutation.
func (m *DomainEventMutation) AggregateID() (r string, exists bool) {
	v := m.aggregate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateID returns the old "aggregate_id" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldAggregateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateID: %w", err)
	}
	return oldValue.AggregateID, nil
}

// ResetAggregateID resets all changes to the "aggregate_id" field.
func (m *DomainEventMutation) ResetAggregateID() {
	m.aggregate_id = nil
}

// SetPayload sets the "payload" field.
func (m *DomainEventMutation) SetPayload(b []byte) {
	m.payload = &b
}

// Payload returns the value of the "payload" field in the mutation.
func (m *DomainEventMutation) Payload() (r []byte, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldPayload(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *DomainEventMutation) ResetPayload() {
	m.payload = nil
}

// SetStatus sets the "status" field.
func (m *DomainEventMutation) SetStatus(d domainevent.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DomainEventMutation) Status() (r domainevent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldStatus(ctx context.Context) (v domainevent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DomainEventMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DomainEventMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DomainEventMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DomainEventMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetArchivedAt sets the "archived_at" field.
func (m *DomainEventMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *DomainEventMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the DomainEvent entity.
// If the DomainEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainEventMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *DomainEventMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[domainevent.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *DomainEventMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[domainevent.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *DomainEventMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, domainevent.FieldArchivedAt)
}

// Where appends a list predicates to the DomainEventMutation builder.
func (m *DomainEventMutation) Where(ps ...predicate.DomainEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DomainEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DomainEvent).
func (m *DomainEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, domainevent.FieldCreatedAt)
	}
	if m.event_type != nil {
		fields = append(fields, domainevent.FieldEventType)
	}
	if m.aggregate_type != nil {
		fields = append(fields, domainevent.FieldAggregateType)
	}
	if m.aggregate_id != nil {
		fields = append(fields, domainevent.FieldAggregateID)
	}
	if m.payload != nil {
		fields = append(fields, domainevent.FieldPayload)
	}
	if m.status != nil {
		fields = append(fields, domainevent.FieldStatus)
	}
	if m.created_by != nil {
		fields = append(fields, domainevent.FieldCreatedBy)
	}
	if m.archived_at != nil {
		fields = append(fields, domainevent.FieldArchivedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domainevent.FieldCreatedAt:
		return m.CreatedAt()
	case domainevent.FieldEventType:
		return m.EventType()
	case domainevent.FieldAggregateType:
		return m.AggregateType()
	case domainevent.FieldAggregateID:
		return m.AggregateID()
	case domainevent.FieldPayload:
		return m.Payload()
	case domainevent.FieldStatus:
		return m.Status()
	case domainevent.FieldCreatedBy:
		return m.CreatedBy()
	case domainevent.FieldArchivedAt:
		return m.ArchivedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domainevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case domainevent.FieldEventType:
		return m.OldEventType(ctx)
	case domainevent.FieldAggregateType:
		return m.OldAggregateType(ctx)
	case domainevent.FieldAggregateID:
		return m.OldAggregateID(ctx)
	case domainevent.FieldPayload:
		return m.OldPayload(ctx)
	case domainevent.FieldStatus:
		return m.OldStatus(ctx)
	case domainevent.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case domainevent.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DomainEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domainevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case domainevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case domainevent.FieldAggregateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateType(v)
		return nil
	case domainevent.FieldAggregateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateID(v)
		return nil
	case domainevent.FieldPayload:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case domainevent.FieldStatus:
		v, ok := value.(domainevent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case domainevent.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case domainevent.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DomainEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DomainEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(domainevent.FieldArchivedAt) {
		fields = append(fields, domainevent.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainEventMutation) ClearField(name string) error {
	switch name {
	case domainevent.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown DomainEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainEventMutation) ResetField(name string) error {
	switch name {
	case domainevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case domainevent.FieldEventType:
		m.ResetEventType()
		return nil
	case domainevent.FieldAggregateType:
		m.ResetAggregateType()
		return nil
	case domainevent.FieldAggregateID:
		m.ResetAggregateID()
		return nil
	case domainevent.FieldPayload:
		m.ResetPayload()
		return nil
	case domainevent.FieldStatus:
		m.ResetStatus()
		return nil
	case domainevent.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case domainevent.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown DomainEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DomainEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DomainEvent edge %s", name)
}

// ExternalApprovalSystemMutation represents an operation that mutates the ExternalApprovalSystem nodes in the graph.
type ExternalApprovalSystemMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	system_type   *externalapprovalsystem.SystemType
	_config       *map[string]interface{}
	enabled       *bool
	created_by    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ExternalApprovalSystem, error)
	predicates    []predicate.ExternalApprovalSystem
}

var _ ent.Mutation = (*ExternalApprovalSystemMutation)(nil)

// externalapprovalsystemOption allows management of the mutation configuration using functional options.
type externalapprovalsystemOption func(*ExternalApprovalSystemMutation)

// newExternalApprovalSystemMutation creates new mutation for the ExternalApprovalSystem entity.
func newExternalApprovalSystemMutation(c config, op Op, opts ...externalapprovalsystemOption) *ExternalApprovalSystemMutation {
	m := &ExternalApprovalSystemMutation{
		config:        c,
		op:            op,
		typ:           TypeExternalApprovalSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExternalApprovalSystemID sets the ID field of the mutation.
func withExternalApprovalSystemID(id string) externalapprovalsystemOption {
	return func(m *ExternalApprovalSystemMutation) {
		var (
			err   error
			once  sync.Once
			value *ExternalApprovalSystem
		)
		m.oldValue = func(ctx context.Context) (*ExternalApprovalSystem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExternalApprovalSystem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExternalApprovalSystem sets the old ExternalApprovalSystem of the mutation.
func withExternalApprovalSystem(node *ExternalApprovalSystem) externalapprovalsystemOption {
	return func(m *ExternalApprovalSystemMutation) {
		m.oldValue = func(context.Context) (*ExternalApprovalSystem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExternalApprovalSystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExternalApprovalSystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExternalApprovalSystem entities.
func (m *ExternalApprovalSystemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExternalApprovalSystemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExternalApprovalSystemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExternalApprovalSystem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExternalApprovalSystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExternalApprovalSystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExternalApprovalSystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExternalApprovalSystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExternalApprovalSystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExternalApprovalSystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ExternalApprovalSystemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExternalApprovalSystemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExternalApprovalSystemMutation) ResetName() {
	m.name = nil
}

// SetSystemType sets the "system_type" field.
func (m *ExternalApprovalSystemMutation) SetSystemType(et externalapprovalsystem.SystemType) {
	m.system_type = &et
}

// SystemType returns the value of the "system_type" field in the mutation.
func (m *ExternalApprovalSystemMutation) SystemType() (r externalapprovalsystem.SystemType, exists bool) {
	v := m.system_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemType returns the old "system_type" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldSystemType(ctx context.Context) (v externalapprovalsystem.SystemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemType: %w", err)
	}
	return oldValue.SystemType, nil
}

// ResetSystemType resets all changes to the "system_type" field.
func (m *ExternalApprovalSystemMutation) ResetSystemType() {
	m.system_type = nil
}

// SetConfig sets the "config" field.
func (m *ExternalApprovalSystemMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ExternalApprovalSystemMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *ExternalApprovalSystemMutation) ResetConfig() {
	m._config = nil
}

// SetEnabled sets the "enabled" field.
func (m *ExternalApprovalSystemMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ExternalApprovalSystemMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ExternalApprovalSystemMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ExternalApprovalSystemMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ExternalApprovalSystemMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ExternalApprovalSystem entity.
// If the ExternalApprovalSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExternalApprovalSystemMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ExternalApprovalSystemMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the ExternalApprovalSystemMutation builder.
func (m *ExternalApprovalSystemMutation) Where(ps ...predicate.ExternalApprovalSystem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExternalApprovalSystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExternalApprovalSystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExternalApprovalSystem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExternalApprovalSystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExternalApprovalSystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExternalApprovalSystem).
func (m *ExternalApprovalSystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExternalApprovalSystemMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, externalapprovalsystem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, externalapprovalsystem.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, externalapprovalsystem.FieldName)
	}
	if m.system_type != nil {
		fields = append(fields, externalapprovalsystem.FieldSystemType)
	}
	if m._config != nil {
		fields = append(fields, externalapprovalsystem.FieldConfig)
	}
	if m.enabled != nil {
		fields = append(fields, externalapprovalsystem.FieldEnabled)
	}
	if m.created_by != nil {
		fields = append(fields, externalapprovalsystem.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExternalApprovalSystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case externalapprovalsystem.FieldCreatedAt:
		return m.CreatedAt()
	case externalapprovalsystem.FieldUpdatedAt:
		return m.UpdatedAt()
	case externalapprovalsystem.FieldName:
		return m.Name()
	case externalapprovalsystem.FieldSystemType:
		return m.SystemType()
	case externalapprovalsystem.FieldConfig:
		return m.Config()
	case externalapprovalsystem.FieldEnabled:
		return m.Enabled()
	case externalapprovalsystem.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExternalApprovalSystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case externalapprovalsystem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case externalapprovalsystem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case externalapprovalsystem.FieldName:
		return m.OldName(ctx)
	case externalapprovalsystem.FieldSystemType:
		return m.OldSystemType(ctx)
	case externalapprovalsystem.FieldConfig:
		return m.OldConfig(ctx)
	case externalapprovalsystem.FieldEnabled:
		return m.OldEnabled(ctx)
	case externalapprovalsystem.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ExternalApprovalSystem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalApprovalSystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case externalapprovalsystem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case externalapprovalsystem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case externalapprovalsystem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case externalapprovalsystem.FieldSystemType:
		v, ok := value.(externalapprovalsystem.SystemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemType(v)
		return nil
	case externalapprovalsystem.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case externalapprovalsystem.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case externalapprovalsystem.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ExternalApprovalSystem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExternalApprovalSystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExternalApprovalSystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExternalApprovalSystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ExternalApprovalSystem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExternalApprovalSystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExternalApprovalSystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExternalApprovalSystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExternalApprovalSystem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExternalApprovalSystemMutation) ResetField(name string) error {
	switch name {
	case externalapprovalsystem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case externalapprovalsystem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case externalapprovalsystem.FieldName:
		m.ResetName()
		return nil
	case externalapprovalsystem.FieldSystemType:
		m.ResetSystemType()
		return nil
	case externalapprovalsystem.FieldConfig:
		m.ResetConfig()
		return nil
	case externalapprovalsystem.FieldEnabled:
		m.ResetEnabled()
		return nil
	case externalapprovalsystem.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ExternalApprovalSystem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExternalApprovalSystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExternalApprovalSystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExternalApprovalSystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExternalApprovalSystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExternalApprovalSystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExternalApprovalSystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExternalApprovalSystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExternalApprovalSystem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExternalApprovalSystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExternalApprovalSystem edge %s", name)
}

// IdPGroupMappingMutation represents an operation that mutates the IdPGroupMapping nodes in the graph.
type IdPGroupMappingMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	provider_id                *string
	external_group_id          *string
	role_id                    *string
	scope_type                 *string
	scope_id                   *string
	allowed_environments       *[]string
	appendallowed_environments []string
	created_by                 *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*IdPGroupMapping, error)
	predicates                 []predicate.IdPGroupMapping
}

var _ ent.Mutation = (*IdPGroupMappingMutation)(nil)

// idpgroupmappingOption allows management of the mutation configuration using functional options.
type idpgroupmappingOption func(*IdPGroupMappingMutation)

// newIdPGroupMappingMutation creates new mutation for the IdPGroupMapping entity.
func newIdPGroupMappingMutation(c config, op Op, opts ...idpgroupmappingOption) *IdPGroupMappingMutation {
	m := &IdPGroupMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeIdPGroupMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdPGroupMappingID sets the ID field of the mutation.
func withIdPGroupMappingID(id string) idpgroupmappingOption {
	return func(m *IdPGroupMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *IdPGroupMapping
		)
		m.oldValue = func(ctx context.Context) (*IdPGroupMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdPGroupMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdPGroupMapping sets the old IdPGroupMapping of the mutation.
func withIdPGroupMapping(node *IdPGroupMapping) idpgroupmappingOption {
	return func(m *IdPGroupMappingMutation) {
		m.oldValue = func(context.Context) (*IdPGroupMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdPGroupMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdPGroupMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdPGroupMapping entities.
func (m *IdPGroupMappingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdPGroupMappingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdPGroupMappingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdPGroupMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IdPGroupMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdPGroupMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdPGroupMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdPGroupMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdPGroupMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdPGroupMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProviderID sets the "provider_id" field.
func (m *IdPGroupMappingMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *IdPGroupMappingMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *IdPGroupMappingMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetExternalGroupID sets the "external_group_id" field.
func (m *IdPGroupMappingMutation) SetExternalGroupID(s string) {
	m.external_group_id = &s
}

// ExternalGroupID returns the value of the "external_group_id" field in the mutation.
func (m *IdPGroupMappingMutation) ExternalGroupID() (r string, exists bool) {
	v := m.external_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalGroupID returns the old "external_group_id" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldExternalGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalGroupID: %w", err)
	}
	return oldValue.ExternalGroupID, nil
}

// ResetExternalGroupID resets all changes to the "external_group_id" field.
func (m *IdPGroupMappingMutation) ResetExternalGroupID() {
	m.external_group_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *IdPGroupMappingMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *IdPGroupMappingMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *IdPGroupMappingMutation) ResetRoleID() {
	m.role_id = nil
}

// SetScopeType sets the "scope_type" field.
func (m *IdPGroupMappingMutation) SetScopeType(s string) {
	m.scope_type = &s
}

// ScopeType returns the value of the "scope_type" field in the mutation.
func (m *IdPGroupMappingMutation) ScopeType() (r string, exists bool) {
	v := m.scope_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeType returns the old "scope_type" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldScopeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeType: %w", err)
	}
	return oldValue.ScopeType, nil
}

// ClearScopeType clears the value of the "scope_type" field.
func (m *IdPGroupMappingMutation) ClearScopeType() {
	m.scope_type = nil
	m.clearedFields[idpgroupmapping.FieldScopeType] = struct{}{}
}

// ScopeTypeCleared returns if the "scope_type" field was cleared in this mutation.
func (m *IdPGroupMappingMutation) ScopeTypeCleared() bool {
	_, ok := m.clearedFields[idpgroupmapping.FieldScopeType]
	return ok
}

// ResetScopeType resets all changes to the "scope_type" field.
func (m *IdPGroupMappingMutation) ResetScopeType() {
	m.scope_type = nil
	delete(m.clearedFields, idpgroupmapping.FieldScopeType)
}

// SetScopeID sets the "scope_id" field.
func (m *IdPGroupMappingMutation) SetScopeID(s string) {
	m.scope_id = &s
}

// ScopeID returns the value of the "scope_id" field in the mutation.
func (m *IdPGroupMappingMutation) ScopeID() (r string, exists bool) {
	v := m.scope_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeID returns the old "scope_id" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldScopeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeID: %w", err)
	}
	return oldValue.ScopeID, nil
}

// ClearScopeID clears the value of the "scope_id" field.
func (m *IdPGroupMappingMutation) ClearScopeID() {
	m.scope_id = nil
	m.clearedFields[idpgroupmapping.FieldScopeID] = struct{}{}
}

// ScopeIDCleared returns if the "scope_id" field was cleared in this mutation.
func (m *IdPGroupMappingMutation) ScopeIDCleared() bool {
	_, ok := m.clearedFields[idpgroupmapping.FieldScopeID]
	return ok
}

// ResetScopeID resets all changes to the "scope_id" field.
func (m *IdPGroupMappingMutation) ResetScopeID() {
	m.scope_id = nil
	delete(m.clearedFields, idpgroupmapping.FieldScopeID)
}

// SetAllowedEnvironments sets the "allowed_environments" field.
func (m *IdPGroupMappingMutation) SetAllowedEnvironments(s []string) {
	m.allowed_environments = &s
	m.appendallowed_environments = nil
}

// AllowedEnvironments returns the value of the "allowed_environments" field in the mutation.
func (m *IdPGroupMappingMutation) AllowedEnvironments() (r []string, exists bool) {
	v := m.allowed_environments
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedEnvironments returns the old "allowed_environments" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldAllowedEnvironments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedEnvironments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedEnvironments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedEnvironments: %w", err)
	}
	return oldValue.AllowedEnvironments, nil
}

// AppendAllowedEnvironments adds s to the "allowed_environments" field.
func (m *IdPGroupMappingMutation) AppendAllowedEnvironments(s []string) {
	m.appendallowed_environments = append(m.appendallowed_environments, s...)
}

// AppendedAllowedEnvironments returns the list of values that were appended to the "allowed_environments" field in this mutation.
func (m *IdPGroupMappingMutation) AppendedAllowedEnvironments() ([]string, bool) {
	if len(m.appendallowed_environments) == 0 {
		return nil, false
	}
	return m.appendallowed_environments, true
}

// ClearAllowedEnvironments clears the value of the "allowed_environments" field.
func (m *IdPGroupMappingMutation) ClearAllowedEnvironments() {
	m.allowed_environments = nil
	m.appendallowed_environments = nil
	m.clearedFields[idpgroupmapping.FieldAllowedEnvironments] = struct{}{}
}

// AllowedEnvironmentsCleared returns if the "allowed_environments" field was cleared in this mutation.
func (m *IdPGroupMappingMutation) AllowedEnvironmentsCleared() bool {
	_, ok := m.clearedFields[idpgroupmapping.FieldAllowedEnvironments]
	return ok
}

// ResetAllowedEnvironments resets all changes to the "allowed_environments" field.
func (m *IdPGroupMappingMutation) ResetAllowedEnvironments() {
	m.allowed_environments = nil
	m.appendallowed_environments = nil
	delete(m.clearedFields, idpgroupmapping.FieldAllowedEnvironments)
}

// SetCreatedBy sets the "created_by" field.
func (m *IdPGroupMappingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IdPGroupMappingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IdPGroupMapping entity.
// If the IdPGroupMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPGroupMappingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IdPGroupMappingMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the IdPGroupMappingMutation builder.
func (m *IdPGroupMappingMutation) Where(ps ...predicate.IdPGroupMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdPGroupMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdPGroupMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdPGroupMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdPGroupMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdPGroupMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdPGroupMapping).
func (m *IdPGroupMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdPGroupMappingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, idpgroupmapping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, idpgroupmapping.FieldUpdatedAt)
	}
	if m.provider_id != nil {
		fields = append(fields, idpgroupmapping.FieldProviderID)
	}
	if m.external_group_id != nil {
		fields = append(fields, idpgroupmapping.FieldExternalGroupID)
	}
	if m.role_id != nil {
		fields = append(fields, idpgroupmapping.FieldRoleID)
	}
	if m.scope_type != nil {
		fields = append(fields, idpgroupmapping.FieldScopeType)
	}
	if m.scope_id != nil {
		fields = append(fields, idpgroupmapping.FieldScopeID)
	}
	if m.allowed_environments != nil {
		fields = append(fields, idpgroupmapping.FieldAllowedEnvironments)
	}
	if m.created_by != nil {
		fields = append(fields, idpgroupmapping.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdPGroupMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idpgroupmapping.FieldCreatedAt:
		return m.CreatedAt()
	case idpgroupmapping.FieldUpdatedAt:
		return m.UpdatedAt()
	case idpgroupmapping.FieldProviderID:
		return m.ProviderID()
	case idpgroupmapping.FieldExternalGroupID:
		return m.ExternalGroupID()
	case idpgroupmapping.FieldRoleID:
		return m.RoleID()
	case idpgroupmapping.FieldScopeType:
		return m.ScopeType()
	case idpgroupmapping.FieldScopeID:
		return m.ScopeID()
	case idpgroupmapping.FieldAllowedEnvironments:
		return m.AllowedEnvironments()
	case idpgroupmapping.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdPGroupMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idpgroupmapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case idpgroupmapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case idpgroupmapping.FieldProviderID:
		return m.OldProviderID(ctx)
	case idpgroupmapping.FieldExternalGroupID:
		return m.OldExternalGroupID(ctx)
	case idpgroupmapping.FieldRoleID:
		return m.OldRoleID(ctx)
	case idpgroupmapping.FieldScopeType:
		return m.OldScopeType(ctx)
	case idpgroupmapping.FieldScopeID:
		return m.OldScopeID(ctx)
	case idpgroupmapping.FieldAllowedEnvironments:
		return m.OldAllowedEnvironments(ctx)
	case idpgroupmapping.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown IdPGroupMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdPGroupMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idpgroupmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case idpgroupmapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case idpgroupmapping.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case idpgroupmapping.FieldExternalGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalGroupID(v)
		return nil
	case idpgroupmapping.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case idpgroupmapping.FieldScopeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeType(v)
		return nil
	case idpgroupmapping.FieldScopeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeID(v)
		return nil
	case idpgroupmapping.FieldAllowedEnvironments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedEnvironments(v)
		return nil
	case idpgroupmapping.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown IdPGroupMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdPGroupMappingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdPGroupMappingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdPGroupMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdPGroupMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdPGroupMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(idpgroupmapping.FieldScopeType) {
		fields = append(fields, idpgroupmapping.FieldScopeType)
	}
	if m.FieldCleared(idpgroupmapping.FieldScopeID) {
		fields = append(fields, idpgroupmapping.FieldScopeID)
	}
	if m.FieldCleared(idpgroupmapping.FieldAllowedEnvironments) {
		fields = append(fields, idpgroupmapping.FieldAllowedEnvironments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdPGroupMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdPGroupMappingMutation) ClearField(name string) error {
	switch name {
	case idpgroupmapping.FieldScopeType:
		m.ClearScopeType()
		return nil
	case idpgroupmapping.FieldScopeID:
		m.ClearScopeID()
		return nil
	case idpgroupmapping.FieldAllowedEnvironments:
		m.ClearAllowedEnvironments()
		return nil
	}
	return fmt.Errorf("unknown IdPGroupMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdPGroupMappingMutation) ResetField(name string) error {
	switch name {
	case idpgroupmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case idpgroupmapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case idpgroupmapping.FieldProviderID:
		m.ResetProviderID()
		return nil
	case idpgroupmapping.FieldExternalGroupID:
		m.ResetExternalGroupID()
		return nil
	case idpgroupmapping.FieldRoleID:
		m.ResetRoleID()
		return nil
	case idpgroupmapping.FieldScopeType:
		m.ResetScopeType()
		return nil
	case idpgroupmapping.FieldScopeID:
		m.ResetScopeID()
		return nil
	case idpgroupmapping.FieldAllowedEnvironments:
		m.ResetAllowedEnvironments()
		return nil
	case idpgroupmapping.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown IdPGroupMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdPGroupMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdPGroupMappingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdPGroupMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdPGroupMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdPGroupMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdPGroupMappingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdPGroupMappingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IdPGroupMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdPGroupMappingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IdPGroupMapping edge %s", name)
}

// IdPSyncedGroupMutation represents an operation that mutates the IdPSyncedGroup nodes in the graph.
type IdPSyncedGroupMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	provider_id       *string
	external_group_id *string
	group_name        *string
	source_field      *string
	description       *string
	last_synced_at    *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*IdPSyncedGroup, error)
	predicates        []predicate.IdPSyncedGroup
}

var _ ent.Mutation = (*IdPSyncedGroupMutation)(nil)

// idpsyncedgroupOption allows management of the mutation configuration using functional options.
type idpsyncedgroupOption func(*IdPSyncedGroupMutation)

// newIdPSyncedGroupMutation creates new mutation for the IdPSyncedGroup entity.
func newIdPSyncedGroupMutation(c config, op Op, opts ...idpsyncedgroupOption) *IdPSyncedGroupMutation {
	m := &IdPSyncedGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeIdPSyncedGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdPSyncedGroupID sets the ID field of the mutation.
func withIdPSyncedGroupID(id string) idpsyncedgroupOption {
	return func(m *IdPSyncedGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *IdPSyncedGroup
		)
		m.oldValue = func(ctx context.Context) (*IdPSyncedGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdPSyncedGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdPSyncedGroup sets the old IdPSyncedGroup of the mutation.
func withIdPSyncedGroup(node *IdPSyncedGroup) idpsyncedgroupOption {
	return func(m *IdPSyncedGroupMutation) {
		m.oldValue = func(context.Context) (*IdPSyncedGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdPSyncedGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdPSyncedGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdPSyncedGroup entities.
func (m *IdPSyncedGroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdPSyncedGroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdPSyncedGroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdPSyncedGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IdPSyncedGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdPSyncedGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdPSyncedGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdPSyncedGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdPSyncedGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdPSyncedGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProviderID sets the "provider_id" field.
func (m *IdPSyncedGroupMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *IdPSyncedGroupMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *IdPSyncedGroupMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetExternalGroupID sets the "external_group_id" field.
func (m *IdPSyncedGroupMutation) SetExternalGroupID(s string) {
	m.external_group_id = &s
}

// ExternalGroupID returns the value of the "external_group_id" field in the mutation.
func (m *IdPSyncedGroupMutation) ExternalGroupID() (r string, exists bool) {
	v := m.external_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalGroupID returns the old "external_group_id" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldExternalGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalGroupID: %w", err)
	}
	return oldValue.ExternalGroupID, nil
}

// ResetExternalGroupID resets all changes to the "external_group_id" field.
func (m *IdPSyncedGroupMutation) ResetExternalGroupID() {
	m.external_group_id = nil
}

// SetGroupName sets the "group_name" field.
func (m *IdPSyncedGroupMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *IdPSyncedGroupMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *IdPSyncedGroupMutation) ResetGroupName() {
	m.group_name = nil
}

// SetSourceField sets the "source_field" field.
func (m *IdPSyncedGroupMutation) SetSourceField(s string) {
	m.source_field = &s
}

// SourceField returns the value of the "source_field" field in the mutation.
func (m *IdPSyncedGroupMutation) SourceField() (r string, exists bool) {
	v := m.source_field
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceField returns the old "source_field" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldSourceField(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceField: %w", err)
	}
	return oldValue.SourceField, nil
}

// ClearSourceField clears the value of the "source_field" field.
func (m *IdPSyncedGroupMutation) ClearSourceField() {
	m.source_field = nil
	m.clearedFields[idpsyncedgroup.FieldSourceField] = struct{}{}
}

// SourceFieldCleared returns if the "source_field" field was cleared in this mutation.
func (m *IdPSyncedGroupMutation) SourceFieldCleared() bool {
	_, ok := m.clearedFields[idpsyncedgroup.FieldSourceField]
	return ok
}

// ResetSourceField resets all changes to the "source_field" field.
func (m *IdPSyncedGroupMutation) ResetSourceField() {
	m.source_field = nil
	delete(m.clearedFields, idpsyncedgroup.FieldSourceField)
}

// SetDescription sets the "description" field.
func (m *IdPSyncedGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IdPSyncedGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IdPSyncedGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[idpsyncedgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IdPSyncedGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[idpsyncedgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IdPSyncedGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, idpsyncedgroup.FieldDescription)
}

// SetLastSyncedAt sets the "last_synced_at" field.
func (m *IdPSyncedGroupMutation) SetLastSyncedAt(t time.Time) {
	m.last_synced_at = &t
}

// LastSyncedAt returns the value of the "last_synced_at" field in the mutation.
func (m *IdPSyncedGroupMutation) LastSyncedAt() (r time.Time, exists bool) {
	v := m.last_synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncedAt returns the old "last_synced_at" field's value of the IdPSyncedGroup entity.
// If the IdPSyncedGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdPSyncedGroupMutation) OldLastSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncedAt: %w", err)
	}
	return oldValue.LastSyncedAt, nil
}

// ClearLastSyncedAt clears the value of the "last_synced_at" field.
func (m *IdPSyncedGroupMutation) ClearLastSyncedAt() {
	m.last_synced_at = nil
	m.clearedFields[idpsyncedgroup.FieldLastSyncedAt] = struct{}{}
}

// LastSyncedAtCleared returns if the "last_synced_at" field was cleared in this mutation.
func (m *IdPSyncedGroupMutation) LastSyncedAtCleared() bool {
	_, ok := m.clearedFields[idpsyncedgroup.FieldLastSyncedAt]
	return ok
}

// ResetLastSyncedAt resets all changes to the "last_synced_at" field.
func (m *IdPSyncedGroupMutation) ResetLastSyncedAt() {
	m.last_synced_at = nil
	delete(m.clearedFields, idpsyncedgroup.FieldLastSyncedAt)
}

// Where appends a list predicates to the IdPSyncedGroupMutation builder.
func (m *IdPSyncedGroupMutation) Where(ps ...predicate.IdPSyncedGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdPSyncedGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdPSyncedGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdPSyncedGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdPSyncedGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdPSyncedGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdPSyncedGroup).
func (m *IdPSyncedGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdPSyncedGroupMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, idpsyncedgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, idpsyncedgroup.FieldUpdatedAt)
	}
	if m.provider_id != nil {
		fields = append(fields, idpsyncedgroup.FieldProviderID)
	}
	if m.external_group_id != nil {
		fields = append(fields, idpsyncedgroup.FieldExternalGroupID)
	}
	if m.group_name != nil {
		fields = append(fields, idpsyncedgroup.FieldGroupName)
	}
	if m.source_field != nil {
		fields = append(fields, idpsyncedgroup.FieldSourceField)
	}
	if m.description != nil {
		fields = append(fields, idpsyncedgroup.FieldDescription)
	}
	if m.last_synced_at != nil {
		fields = append(fields, idpsyncedgroup.FieldLastSyncedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdPSyncedGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idpsyncedgroup.FieldCreatedAt:
		return m.CreatedAt()
	case idpsyncedgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case idpsyncedgroup.FieldProviderID:
		return m.ProviderID()
	case idpsyncedgroup.FieldExternalGroupID:
		return m.ExternalGroupID()
	case idpsyncedgroup.FieldGroupName:
		return m.GroupName()
	case idpsyncedgroup.FieldSourceField:
		return m.SourceField()
	case idpsyncedgroup.FieldDescription:
		return m.Description()
	case idpsyncedgroup.FieldLastSyncedAt:
		return m.LastSyncedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdPSyncedGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idpsyncedgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case idpsyncedgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case idpsyncedgroup.FieldProviderID:
		return m.OldProviderID(ctx)
	case idpsyncedgroup.FieldExternalGroupID:
		return m.OldExternalGroupID(ctx)
	case idpsyncedgroup.FieldGroupName:
		return m.OldGroupName(ctx)
	case idpsyncedgroup.FieldSourceField:
		return m.OldSourceField(ctx)
	case idpsyncedgroup.FieldDescription:
		return m.OldDescription(ctx)
	case idpsyncedgroup.FieldLastSyncedAt:
		return m.OldLastSyncedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IdPSyncedGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdPSyncedGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idpsyncedgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case idpsyncedgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case idpsyncedgroup.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case idpsyncedgroup.FieldExternalGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalGroupID(v)
		return nil
	case idpsyncedgroup.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case idpsyncedgroup.FieldSourceField:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceField(v)
		return nil
	case idpsyncedgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case idpsyncedgroup.FieldLastSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IdPSyncedGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdPSyncedGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdPSyncedGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdPSyncedGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdPSyncedGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdPSyncedGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(idpsyncedgroup.FieldSourceField) {
		fields = append(fields, idpsyncedgroup.FieldSourceField)
	}
	if m.FieldCleared(idpsyncedgroup.FieldDescription) {
		fields = append(fields, idpsyncedgroup.FieldDescription)
	}
	if m.FieldCleared(idpsyncedgroup.FieldLastSyncedAt) {
		fields = append(fields, idpsyncedgroup.FieldLastSyncedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdPSyncedGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdPSyncedGroupMutation) ClearField(name string) error {
	switch name {
	case idpsyncedgroup.FieldSourceField:
		m.ClearSourceField()
		return nil
	case idpsyncedgroup.FieldDescription:
		m.ClearDescription()
		return nil
	case idpsyncedgroup.FieldLastSyncedAt:
		m.ClearLastSyncedAt()
		return nil
	}
	return fmt.Errorf("unknown IdPSyncedGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdPSyncedGroupMutation) ResetField(name string) error {
	switch name {
	case idpsyncedgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case idpsyncedgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case idpsyncedgroup.FieldProviderID:
		m.ResetProviderID()
		return nil
	case idpsyncedgroup.FieldExternalGroupID:
		m.ResetExternalGroupID()
		return nil
	case idpsyncedgroup.FieldGroupName:
		m.ResetGroupName()
		return nil
	case idpsyncedgroup.FieldSourceField:
		m.ResetSourceField()
		return nil
	case idpsyncedgroup.FieldDescription:
		m.ResetDescription()
		return nil
	case idpsyncedgroup.FieldLastSyncedAt:
		m.ResetLastSyncedAt()
		return nil
	}
	return fmt.Errorf("unknown IdPSyncedGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdPSyncedGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdPSyncedGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdPSyncedGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdPSyncedGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdPSyncedGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdPSyncedGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdPSyncedGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IdPSyncedGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdPSyncedGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IdPSyncedGroup edge %s", name)
}

// InstanceSizeMutation represents an operation that mutates the InstanceSize nodes in the graph.
type InstanceSizeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	display_name         *string
	description          *string
	cpu_cores            *int
	addcpu_cores         *int
	memory_mb            *int
	addmemory_mb         *int
	disk_gb              *int
	adddisk_gb           *int
	cpu_request          *int
	addcpu_request       *int
	memory_request_mb    *int
	addmemory_request_mb *int
	dedicated_cpu        *bool
	requires_gpu         *bool
	requires_sriov       *bool
	requires_hugepages   *bool
	hugepages_size       *string
	spec_overrides       *map[string]interface{}
	sort_order           *int
	addsort_order        *int
	enabled              *bool
	created_by           *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*InstanceSize, error)
	predicates           []predicate.InstanceSize
}

var _ ent.Mutation = (*InstanceSizeMutation)(nil)

// instancesizeOption allows management of the mutation configuration using functional options.
type instancesizeOption func(*InstanceSizeMutation)

// newInstanceSizeMutation creates new mutation for the InstanceSize entity.
func newInstanceSizeMutation(c config, op Op, opts ...instancesizeOption) *InstanceSizeMutation {
	m := &InstanceSizeMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceSize,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceSizeID sets the ID field of the mutation.
func withInstanceSizeID(id string) instancesizeOption {
	return func(m *InstanceSizeMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceSize
		)
		m.oldValue = func(ctx context.Context) (*InstanceSize, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceSize.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceSize sets the old InstanceSize of the mutation.
func withInstanceSize(node *InstanceSize) instancesizeOption {
	return func(m *InstanceSizeMutation) {
		m.oldValue = func(context.Context) (*InstanceSize, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceSizeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceSizeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceSize entities.
func (m *InstanceSizeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceSizeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceSizeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceSize.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstanceSizeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstanceSizeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstanceSizeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstanceSizeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstanceSizeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstanceSizeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *InstanceSizeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InstanceSizeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InstanceSizeMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *InstanceSizeMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *InstanceSizeMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *InstanceSizeMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[instancesize.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *InstanceSizeMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *InstanceSizeMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, instancesize.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *InstanceSizeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InstanceSizeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InstanceSizeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[instancesize.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InstanceSizeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InstanceSizeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, instancesize.FieldDescription)
}

// SetCPUCores sets the "cpu_cores" field.
func (m *InstanceSizeMutation) SetCPUCores(i int) {
	m.cpu_cores = &i
	m.addcpu_cores = nil
}

// CPUCores returns the value of the "cpu_cores" field in the mutation.
func (m *InstanceSizeMutation) CPUCores() (r int, exists bool) {
	v := m.cpu_cores
	if v == nil {
		return
	}
	return *v, true
}

// OldCPUCores returns the old "cpu_cores" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldCPUCores(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPUCores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPUCores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPUCores: %w", err)
	}
	return oldValue.CPUCores, nil
}

// AddCPUCores adds i to the "cpu_cores" field.
func (m *InstanceSizeMutation) AddCPUCores(i int) {
	if m.addcpu_cores != nil {
		*m.addcpu_cores += i
	} else {
		m.addcpu_cores = &i
	}
}

// AddedCPUCores returns the value that was added to the "cpu_cores" field in this mutation.
func (m *InstanceSizeMutation) AddedCPUCores() (r int, exists bool) {
	v := m.addcpu_cores
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPUCores resets all changes to the "cpu_cores" field.
func (m *InstanceSizeMutation) ResetCPUCores() {
	m.cpu_cores = nil
	m.addcpu_cores = nil
}

// SetMemoryMB sets the "memory_mb" field.
func (m *InstanceSizeMutation) SetMemoryMB(i int) {
	m.memory_mb = &i
	m.addmemory_mb = nil
}

// MemoryMB returns the value of the "memory_mb" field in the mutation.
func (m *InstanceSizeMutation) MemoryMB() (r int, exists bool) {
	v := m.memory_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryMB returns the old "memory_mb" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldMemoryMB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryMB: %w", err)
	}
	return oldValue.MemoryMB, nil
}

// AddMemoryMB adds i to the "memory_mb" field.
func (m *InstanceSizeMutation) AddMemoryMB(i int) {
	if m.addmemory_mb != nil {
		*m.addmemory_mb += i
	} else {
		m.addmemory_mb = &i
	}
}

// AddedMemoryMB returns the value that was added to the "memory_mb" field in this mutation.
func (m *InstanceSizeMutation) AddedMemoryMB() (r int, exists bool) {
	v := m.addmemory_mb
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryMB resets all changes to the "memory_mb" field.
func (m *InstanceSizeMutation) ResetMemoryMB() {
	m.memory_mb = nil
	m.addmemory_mb = nil
}

// SetDiskGB sets the "disk_gb" field.
func (m *InstanceSizeMutation) SetDiskGB(i int) {
	m.disk_gb = &i
	m.adddisk_gb = nil
}

// DiskGB returns the value of the "disk_gb" field in the mutation.
func (m *InstanceSizeMutation) DiskGB() (r int, exists bool) {
	v := m.disk_gb
	if v == nil {
		return
	}
	return *v, true
}

// OldDiskGB returns the old "disk_gb" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldDiskGB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiskGB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiskGB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiskGB: %w", err)
	}
	return oldValue.DiskGB, nil
}

// AddDiskGB adds i to the "disk_gb" field.
func (m *InstanceSizeMutation) AddDiskGB(i int) {
	if m.adddisk_gb != nil {
		*m.adddisk_gb += i
	} else {
		m.adddisk_gb = &i
	}
}

// AddedDiskGB returns the value that was added to the "disk_gb" field in this mutation.
func (m *InstanceSizeMutation) AddedDiskGB() (r int, exists bool) {
	v := m.adddisk_gb
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiskGB clears the value of the "disk_gb" field.
func (m *InstanceSizeMutation) ClearDiskGB() {
	m.disk_gb = nil
	m.adddisk_gb = nil
	m.clearedFields[instancesize.FieldDiskGB] = struct{}{}
}

// DiskGBCleared returns if the "disk_gb" field was cleared in this mutation.
func (m *InstanceSizeMutation) DiskGBCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldDiskGB]
	return ok
}

// ResetDiskGB resets all changes to the "disk_gb" field.
func (m *InstanceSizeMutation) ResetDiskGB() {
	m.disk_gb = nil
	m.adddisk_gb = nil
	delete(m.clearedFields, instancesize.FieldDiskGB)
}

// SetCPURequest sets the "cpu_request" field.
func (m *InstanceSizeMutation) SetCPURequest(i int) {
	m.cpu_request = &i
	m.addcpu_request = nil
}

// CPURequest returns the value of the "cpu_request" field in the mutation.
func (m *InstanceSizeMutation) CPURequest() (r int, exists bool) {
	v := m.cpu_request
	if v == nil {
		return
	}
	return *v, true
}

// OldCPURequest returns the old "cpu_request" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldCPURequest(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPURequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPURequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPURequest: %w", err)
	}
	return oldValue.CPURequest, nil
}

// AddCPURequest adds i to the "cpu_request" field.
func (m *InstanceSizeMutation) AddCPURequest(i int) {
	if m.addcpu_request != nil {
		*m.addcpu_request += i
	} else {
		m.addcpu_request = &i
	}
}

// AddedCPURequest returns the value that was added to the "cpu_request" field in this mutation.
func (m *InstanceSizeMutation) AddedCPURequest() (r int, exists bool) {
	v := m.addcpu_request
	if v == nil {
		return
	}
	return *v, true
}

// ClearCPURequest clears the value of the "cpu_request" field.
func (m *InstanceSizeMutation) ClearCPURequest() {
	m.cpu_request = nil
	m.addcpu_request = nil
	m.clearedFields[instancesize.FieldCPURequest] = struct{}{}
}

// CPURequestCleared returns if the "cpu_request" field was cleared in this mutation.
func (m *InstanceSizeMutation) CPURequestCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldCPURequest]
	return ok
}

// ResetCPURequest resets all changes to the "cpu_request" field.
func (m *InstanceSizeMutation) ResetCPURequest() {
	m.cpu_request = nil
	m.addcpu_request = nil
	delete(m.clearedFields, instancesize.FieldCPURequest)
}

// SetMemoryRequestMB sets the "memory_request_mb" field.
func (m *InstanceSizeMutation) SetMemoryRequestMB(i int) {
	m.memory_request_mb = &i
	m.addmemory_request_mb = nil
}

// MemoryRequestMB returns the value of the "memory_request_mb" field in the mutation.
func (m *InstanceSizeMutation) MemoryRequestMB() (r int, exists bool) {
	v := m.memory_request_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryRequestMB returns the old "memory_request_mb" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldMemoryRequestMB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryRequestMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryRequestMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryRequestMB: %w", err)
	}
	return oldValue.MemoryRequestMB, nil
}

// AddMemoryRequestMB adds i to the "memory_request_mb" field.
func (m *InstanceSizeMutation) AddMemoryRequestMB(i int) {
	if m.addmemory_request_mb != nil {
		*m.addmemory_request_mb += i
	} else {
		m.addmemory_request_mb = &i
	}
}

// AddedMemoryRequestMB returns the value that was added to the "memory_request_mb" field in this mutation.
func (m *InstanceSizeMutation) AddedMemoryRequestMB() (r int, exists bool) {
	v := m.addmemory_request_mb
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemoryRequestMB clears the value of the "memory_request_mb" field.
func (m *InstanceSizeMutation) ClearMemoryRequestMB() {
	m.memory_request_mb = nil
	m.addmemory_request_mb = nil
	m.clearedFields[instancesize.FieldMemoryRequestMB] = struct{}{}
}

// MemoryRequestMBCleared returns if the "memory_request_mb" field was cleared in this mutation.
func (m *InstanceSizeMutation) MemoryRequestMBCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldMemoryRequestMB]
	return ok
}

// ResetMemoryRequestMB resets all changes to the "memory_request_mb" field.
func (m *InstanceSizeMutation) ResetMemoryRequestMB() {
	m.memory_request_mb = nil
	m.addmemory_request_mb = nil
	delete(m.clearedFields, instancesize.FieldMemoryRequestMB)
}

// SetDedicatedCPU sets the "dedicated_cpu" field.
func (m *InstanceSizeMutation) SetDedicatedCPU(b bool) {
	m.dedicated_cpu = &b
}

// DedicatedCPU returns the value of the "dedicated_cpu" field in the mutation.
func (m *InstanceSizeMutation) DedicatedCPU() (r bool, exists bool) {
	v := m.dedicated_cpu
	if v == nil {
		return
	}
	return *v, true
}

// OldDedicatedCPU returns the old "dedicated_cpu" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldDedicatedCPU(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedicatedCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedicatedCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedicatedCPU: %w", err)
	}
	return oldValue.DedicatedCPU, nil
}

// ResetDedicatedCPU resets all changes to the "dedicated_cpu" field.
func (m *InstanceSizeMutation) ResetDedicatedCPU() {
	m.dedicated_cpu = nil
}

// SetRequiresGpu sets the "requires_gpu" field.
func (m *InstanceSizeMutation) SetRequiresGpu(b bool) {
	m.requires_gpu = &b
}

// RequiresGpu returns the value of the "requires_gpu" field in the mutation.
func (m *InstanceSizeMutation) RequiresGpu() (r bool, exists bool) {
	v := m.requires_gpu
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresGpu returns the old "requires_gpu" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldRequiresGpu(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresGpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresGpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresGpu: %w", err)
	}
	return oldValue.RequiresGpu, nil
}

// ResetRequiresGpu resets all changes to the "requires_gpu" field.
func (m *InstanceSizeMutation) ResetRequiresGpu() {
	m.requires_gpu = nil
}

// SetRequiresSriov sets the "requires_sriov" field.
func (m *InstanceSizeMutation) SetRequiresSriov(b bool) {
	m.requires_sriov = &b
}

// RequiresSriov returns the value of the "requires_sriov" field in the mutation.
func (m *InstanceSizeMutation) RequiresSriov() (r bool, exists bool) {
	v := m.requires_sriov
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresSriov returns the old "requires_sriov" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldRequiresSriov(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresSriov is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresSriov requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresSriov: %w", err)
	}
	return oldValue.RequiresSriov, nil
}

// ResetRequiresSriov resets all changes to the "requires_sriov" field.
func (m *InstanceSizeMutation) ResetRequiresSriov() {
	m.requires_sriov = nil
}

// SetRequiresHugepages sets the "requires_hugepages" field.
func (m *InstanceSizeMutation) SetRequiresHugepages(b bool) {
	m.requires_hugepages = &b
}

// RequiresHugepages returns the value of the "requires_hugepages" field in the mutation.
func (m *InstanceSizeMutation) RequiresHugepages() (r bool, exists bool) {
	v := m.requires_hugepages
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresHugepages returns the old "requires_hugepages" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldRequiresHugepages(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresHugepages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresHugepages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresHugepages: %w", err)
	}
	return oldValue.RequiresHugepages, nil
}

// ResetRequiresHugepages resets all changes to the "requires_hugepages" field.
func (m *InstanceSizeMutation) ResetRequiresHugepages() {
	m.requires_hugepages = nil
}

// SetHugepagesSize sets the "hugepages_size" field.
func (m *InstanceSizeMutation) SetHugepagesSize(s string) {
	m.hugepages_size = &s
}

// HugepagesSize returns the value of the "hugepages_size" field in the mutation.
func (m *InstanceSizeMutation) HugepagesSize() (r string, exists bool) {
	v := m.hugepages_size
	if v == nil {
		return
	}
	return *v, true
}

// OldHugepagesSize returns the old "hugepages_size" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldHugepagesSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHugepagesSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHugepagesSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHugepagesSize: %w", err)
	}
	return oldValue.HugepagesSize, nil
}

// ClearHugepagesSize clears the value of the "hugepages_size" field.
func (m *InstanceSizeMutation) ClearHugepagesSize() {
	m.hugepages_size = nil
	m.clearedFields[instancesize.FieldHugepagesSize] = struct{}{}
}

// HugepagesSizeCleared returns if the "hugepages_size" field was cleared in this mutation.
func (m *InstanceSizeMutation) HugepagesSizeCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldHugepagesSize]
	return ok
}

// ResetHugepagesSize resets all changes to the "hugepages_size" field.
func (m *InstanceSizeMutation) ResetHugepagesSize() {
	m.hugepages_size = nil
	delete(m.clearedFields, instancesize.FieldHugepagesSize)
}

// SetSpecOverrides sets the "spec_overrides" field.
func (m *InstanceSizeMutation) SetSpecOverrides(value map[string]interface{}) {
	m.spec_overrides = &value
}

// SpecOverrides returns the value of the "spec_overrides" field in the mutation.
func (m *InstanceSizeMutation) SpecOverrides() (r map[string]interface{}, exists bool) {
	v := m.spec_overrides
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecOverrides returns the old "spec_overrides" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldSpecOverrides(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecOverrides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecOverrides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecOverrides: %w", err)
	}
	return oldValue.SpecOverrides, nil
}

// ClearSpecOverrides clears the value of the "spec_overrides" field.
func (m *InstanceSizeMutation) ClearSpecOverrides() {
	m.spec_overrides = nil
	m.clearedFields[instancesize.FieldSpecOverrides] = struct{}{}
}

// SpecOverridesCleared returns if the "spec_overrides" field was cleared in this mutation.
func (m *InstanceSizeMutation) SpecOverridesCleared() bool {
	_, ok := m.clearedFields[instancesize.FieldSpecOverrides]
	return ok
}

// ResetSpecOverrides resets all changes to the "spec_overrides" field.
func (m *InstanceSizeMutation) ResetSpecOverrides() {
	m.spec_overrides = nil
	delete(m.clearedFields, instancesize.FieldSpecOverrides)
}

// SetSortOrder sets the "sort_order" field.
func (m *InstanceSizeMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *InstanceSizeMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *InstanceSizeMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *InstanceSizeMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *InstanceSizeMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetEnabled sets the "enabled" field.
func (m *InstanceSizeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *InstanceSizeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *InstanceSizeMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *InstanceSizeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InstanceSizeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InstanceSize entity.
// If the InstanceSize object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceSizeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InstanceSizeMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the InstanceSizeMutation builder.
func (m *InstanceSizeMutation) Where(ps ...predicate.InstanceSize) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstanceSizeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstanceSizeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstanceSize, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstanceSizeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstanceSizeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstanceSize).
func (m *InstanceSizeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceSizeMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, instancesize.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, instancesize.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, instancesize.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, instancesize.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, instancesize.FieldDescription)
	}
	if m.cpu_cores != nil {
		fields = append(fields, instancesize.FieldCPUCores)
	}
	if m.memory_mb != nil {
		fields = append(fields, instancesize.FieldMemoryMB)
	}
	if m.disk_gb != nil {
		fields = append(fields, instancesize.FieldDiskGB)
	}
	if m.cpu_request != nil {
		fields = append(fields, instancesize.FieldCPURequest)
	}
	if m.memory_request_mb != nil {
		fields = append(fields, instancesize.FieldMemoryRequestMB)
	}
	if m.dedicated_cpu != nil {
		fields = append(fields, instancesize.FieldDedicatedCPU)
	}
	if m.requires_gpu != nil {
		fields = append(fields, instancesize.FieldRequiresGpu)
	}
	if m.requires_sriov != nil {
		fields = append(fields, instancesize.FieldRequiresSriov)
	}
	if m.requires_hugepages != nil {
		fields = append(fields, instancesize.FieldRequiresHugepages)
	}
	if m.hugepages_size != nil {
		fields = append(fields, instancesize.FieldHugepagesSize)
	}
	if m.spec_overrides != nil {
		fields = append(fields, instancesize.FieldSpecOverrides)
	}
	if m.sort_order != nil {
		fields = append(fields, instancesize.FieldSortOrder)
	}
	if m.enabled != nil {
		fields = append(fields, instancesize.FieldEnabled)
	}
	if m.created_by != nil {
		fields = append(fields, instancesize.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceSizeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instancesize.FieldCreatedAt:
		return m.CreatedAt()
	case instancesize.FieldUpdatedAt:
		return m.UpdatedAt()
	case instancesize.FieldName:
		return m.Name()
	case instancesize.FieldDisplayName:
		return m.DisplayName()
	case instancesize.FieldDescription:
		return m.Description()
	case instancesize.FieldCPUCores:
		return m.CPUCores()
	case instancesize.FieldMemoryMB:
		return m.MemoryMB()
	case instancesize.FieldDiskGB:
		return m.DiskGB()
	case instancesize.FieldCPURequest:
		return m.CPURequest()
	case instancesize.FieldMemoryRequestMB:
		return m.MemoryRequestMB()
	case instancesize.FieldDedicatedCPU:
		return m.DedicatedCPU()
	case instancesize.FieldRequiresGpu:
		return m.RequiresGpu()
	case instancesize.FieldRequiresSriov:
		return m.RequiresSriov()
	case instancesize.FieldRequiresHugepages:
		return m.RequiresHugepages()
	case instancesize.FieldHugepagesSize:
		return m.HugepagesSize()
	case instancesize.FieldSpecOverrides:
		return m.SpecOverrides()
	case instancesize.FieldSortOrder:
		return m.SortOrder()
	case instancesize.FieldEnabled:
		return m.Enabled()
	case instancesize.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceSizeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instancesize.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instancesize.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case instancesize.FieldName:
		return m.OldName(ctx)
	case instancesize.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case instancesize.FieldDescription:
		return m.OldDescription(ctx)
	case instancesize.FieldCPUCores:
		return m.OldCPUCores(ctx)
	case instancesize.FieldMemoryMB:
		return m.OldMemoryMB(ctx)
	case instancesize.FieldDiskGB:
		return m.OldDiskGB(ctx)
	case instancesize.FieldCPURequest:
		return m.OldCPURequest(ctx)
	case instancesize.FieldMemoryRequestMB:
		return m.OldMemoryRequestMB(ctx)
	case instancesize.FieldDedicatedCPU:
		return m.OldDedicatedCPU(ctx)
	case instancesize.FieldRequiresGpu:
		return m.OldRequiresGpu(ctx)
	case instancesize.FieldRequiresSriov:
		return m.OldRequiresSriov(ctx)
	case instancesize.FieldRequiresHugepages:
		return m.OldRequiresHugepages(ctx)
	case instancesize.FieldHugepagesSize:
		return m.OldHugepagesSize(ctx)
	case instancesize.FieldSpecOverrides:
		return m.OldSpecOverrides(ctx)
	case instancesize.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case instancesize.FieldEnabled:
		return m.OldEnabled(ctx)
	case instancesize.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceSize field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceSizeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instancesize.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instancesize.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case instancesize.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case instancesize.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case instancesize.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case instancesize.FieldCPUCores:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPUCores(v)
		return nil
	case instancesize.FieldMemoryMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryMB(v)
		return nil
	case instancesize.FieldDiskGB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiskGB(v)
		return nil
	case instancesize.FieldCPURequest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPURequest(v)
		return nil
	case instancesize.FieldMemoryRequestMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryRequestMB(v)
		return nil
	case instancesize.FieldDedicatedCPU:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedicatedCPU(v)
		return nil
	case instancesize.FieldRequiresGpu:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresGpu(v)
		return nil
	case instancesize.FieldRequiresSriov:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresSriov(v)
		return nil
	case instancesize.FieldRequiresHugepages:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresHugepages(v)
		return nil
	case instancesize.FieldHugepagesSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHugepagesSize(v)
		return nil
	case instancesize.FieldSpecOverrides:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecOverrides(v)
		return nil
	case instancesize.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case instancesize.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case instancesize.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceSize field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceSizeMutation) AddedFields() []string {
	var fields []string
	if m.addcpu_cores != nil {
		fields = append(fields, instancesize.FieldCPUCores)
	}
	if m.addmemory_mb != nil {
		fields = append(fields, instancesize.FieldMemoryMB)
	}
	if m.adddisk_gb != nil {
		fields = append(fields, instancesize.FieldDiskGB)
	}
	if m.addcpu_request != nil {
		fields = append(fields, instancesize.FieldCPURequest)
	}
	if m.addmemory_request_mb != nil {
		fields = append(fields, instancesize.FieldMemoryRequestMB)
	}
	if m.addsort_order != nil {
		fields = append(fields, instancesize.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceSizeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instancesize.FieldCPUCores:
		return m.AddedCPUCores()
	case instancesize.FieldMemoryMB:
		return m.AddedMemoryMB()
	case instancesize.FieldDiskGB:
		return m.AddedDiskGB()
	case instancesize.FieldCPURequest:
		return m.AddedCPURequest()
	case instancesize.FieldMemoryRequestMB:
		return m.AddedMemoryRequestMB()
	case instancesize.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceSizeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instancesize.FieldCPUCores:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPUCores(v)
		return nil
	case instancesize.FieldMemoryMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryMB(v)
		return nil
	case instancesize.FieldDiskGB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiskGB(v)
		return nil
	case instancesize.FieldCPURequest:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPURequest(v)
		return nil
	case instancesize.FieldMemoryRequestMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryRequestMB(v)
		return nil
	case instancesize.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceSize numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceSizeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instancesize.FieldDisplayName) {
		fields = append(fields, instancesize.FieldDisplayName)
	}
	if m.FieldCleared(instancesize.FieldDescription) {
		fields = append(fields, instancesize.FieldDescription)
	}
	if m.FieldCleared(instancesize.FieldDiskGB) {
		fields = append(fields, instancesize.FieldDiskGB)
	}
	if m.FieldCleared(instancesize.FieldCPURequest) {
		fields = append(fields, instancesize.FieldCPURequest)
	}
	if m.FieldCleared(instancesize.FieldMemoryRequestMB) {
		fields = append(fields, instancesize.FieldMemoryRequestMB)
	}
	if m.FieldCleared(instancesize.FieldHugepagesSize) {
		fields = append(fields, instancesize.FieldHugepagesSize)
	}
	if m.FieldCleared(instancesize.FieldSpecOverrides) {
		fields = append(fields, instancesize.FieldSpecOverrides)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceSizeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceSizeMutation) ClearField(name string) error {
	switch name {
	case instancesize.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case instancesize.FieldDescription:
		m.ClearDescription()
		return nil
	case instancesize.FieldDiskGB:
		m.ClearDiskGB()
		return nil
	case instancesize.FieldCPURequest:
		m.ClearCPURequest()
		return nil
	case instancesize.FieldMemoryRequestMB:
		m.ClearMemoryRequestMB()
		return nil
	case instancesize.FieldHugepagesSize:
		m.ClearHugepagesSize()
		return nil
	case instancesize.FieldSpecOverrides:
		m.ClearSpecOverrides()
		return nil
	}
	return fmt.Errorf("unknown InstanceSize nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceSizeMutation) ResetField(name string) error {
	switch name {
	case instancesize.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instancesize.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case instancesize.FieldName:
		m.ResetName()
		return nil
	case instancesize.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case instancesize.FieldDescription:
		m.ResetDescription()
		return nil
	case instancesize.FieldCPUCores:
		m.ResetCPUCores()
		return nil
	case instancesize.FieldMemoryMB:
		m.ResetMemoryMB()
		return nil
	case instancesize.FieldDiskGB:
		m.ResetDiskGB()
		return nil
	case instancesize.FieldCPURequest:
		m.ResetCPURequest()
		return nil
	case instancesize.FieldMemoryRequestMB:
		m.ResetMemoryRequestMB()
		return nil
	case instancesize.FieldDedicatedCPU:
		m.ResetDedicatedCPU()
		return nil
	case instancesize.FieldRequiresGpu:
		m.ResetRequiresGpu()
		return nil
	case instancesize.FieldRequiresSriov:
		m.ResetRequiresSriov()
		return nil
	case instancesize.FieldRequiresHugepages:
		m.ResetRequiresHugepages()
		return nil
	case instancesize.FieldHugepagesSize:
		m.ResetHugepagesSize()
		return nil
	case instancesize.FieldSpecOverrides:
		m.ResetSpecOverrides()
		return nil
	case instancesize.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case instancesize.FieldEnabled:
		m.ResetEnabled()
		return nil
	case instancesize.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown InstanceSize field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceSizeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceSizeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceSizeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceSizeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceSizeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceSizeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceSizeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InstanceSize unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceSizeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InstanceSize edge %s", name)
}

// NamespaceRegistryMutation represents an operation that mutates the NamespaceRegistry nodes in the graph.
type NamespaceRegistryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	environment   *namespaceregistry.Environment
	description   *string
	created_by    *string
	enabled       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NamespaceRegistry, error)
	predicates    []predicate.NamespaceRegistry
}

var _ ent.Mutation = (*NamespaceRegistryMutation)(nil)

// namespaceregistryOption allows management of the mutation configuration using functional options.
type namespaceregistryOption func(*NamespaceRegistryMutation)

// newNamespaceRegistryMutation creates new mutation for the NamespaceRegistry entity.
func newNamespaceRegistryMutation(c config, op Op, opts ...namespaceregistryOption) *NamespaceRegistryMutation {
	m := &NamespaceRegistryMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespaceRegistry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceRegistryID sets the ID field of the mutation.
func withNamespaceRegistryID(id string) namespaceregistryOption {
	return func(m *NamespaceRegistryMutation) {
		var (
			err   error
			once  sync.Once
			value *NamespaceRegistry
		)
		m.oldValue = func(ctx context.Context) (*NamespaceRegistry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NamespaceRegistry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespaceRegistry sets the old NamespaceRegistry of the mutation.
func withNamespaceRegistry(node *NamespaceRegistry) namespaceregistryOption {
	return func(m *NamespaceRegistryMutation) {
		m.oldValue = func(context.Context) (*NamespaceRegistry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceRegistryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceRegistryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NamespaceRegistry entities.
func (m *NamespaceRegistryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceRegistryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceRegistryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NamespaceRegistry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceRegistryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceRegistryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceRegistryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceRegistryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceRegistryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceRegistryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *NamespaceRegistryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceRegistryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceRegistryMutation) ResetName() {
	m.name = nil
}

// SetEnvironment sets the "environment" field.
func (m *NamespaceRegistryMutation) SetEnvironment(n namespaceregistry.Environment) {
	m.environment = &n
}

// Environment returns the value of the "environment" field in the mutation.
func (m *NamespaceRegistryMutation) Environment() (r namespaceregistry.Environment, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldEnvironment(ctx context.Context) (v namespaceregistry.Environment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *NamespaceRegistryMutation) ResetEnvironment() {
	m.environment = nil
}

// SetDescription sets the "description" field.
func (m *NamespaceRegistryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NamespaceRegistryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NamespaceRegistryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[namespaceregistry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NamespaceRegistryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[namespaceregistry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NamespaceRegistryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, namespaceregistry.FieldDescription)
}

// SetCreatedBy sets the "created_by" field.
func (m *NamespaceRegistryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NamespaceRegistryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NamespaceRegistryMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetEnabled sets the "enabled" field.
func (m *NamespaceRegistryMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NamespaceRegistryMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NamespaceRegistry entity.
// If the NamespaceRegistry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceRegistryMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NamespaceRegistryMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the NamespaceRegistryMutation builder.
func (m *NamespaceRegistryMutation) Where(ps ...predicate.NamespaceRegistry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceRegistryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceRegistryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NamespaceRegistry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceRegistryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceRegistryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NamespaceRegistry).
func (m *NamespaceRegistryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceRegistryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, namespaceregistry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespaceregistry.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, namespaceregistry.FieldName)
	}
	if m.environment != nil {
		fields = append(fields, namespaceregistry.FieldEnvironment)
	}
	if m.description != nil {
		fields = append(fields, namespaceregistry.FieldDescription)
	}
	if m.created_by != nil {
		fields = append(fields, namespaceregistry.FieldCreatedBy)
	}
	if m.enabled != nil {
		fields = append(fields, namespaceregistry.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceRegistryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespaceregistry.FieldCreatedAt:
		return m.CreatedAt()
	case namespaceregistry.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespaceregistry.FieldName:
		return m.Name()
	case namespaceregistry.FieldEnvironment:
		return m.Environment()
	case namespaceregistry.FieldDescription:
		return m.Description()
	case namespaceregistry.FieldCreatedBy:
		return m.CreatedBy()
	case namespaceregistry.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceRegistryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespaceregistry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespaceregistry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespaceregistry.FieldName:
		return m.OldName(ctx)
	case namespaceregistry.FieldEnvironment:
		return m.OldEnvironment(ctx)
	case namespaceregistry.FieldDescription:
		return m.OldDescription(ctx)
	case namespaceregistry.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case namespaceregistry.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown NamespaceRegistry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceRegistryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespaceregistry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespaceregistry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespaceregistry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case namespaceregistry.FieldEnvironment:
		v, ok := value.(namespaceregistry.Environment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	case namespaceregistry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case namespaceregistry.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case namespaceregistry.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown NamespaceRegistry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceRegistryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceRegistryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceRegistryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NamespaceRegistry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceRegistryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(namespaceregistry.FieldDescription) {
		fields = append(fields, namespaceregistry.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceRegistryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceRegistryMutation) ClearField(name string) error {
	switch name {
	case namespaceregistry.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown NamespaceRegistry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceRegistryMutation) ResetField(name string) error {
	switch name {
	case namespaceregistry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespaceregistry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespaceregistry.FieldName:
		m.ResetName()
		return nil
	case namespaceregistry.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	case namespaceregistry.FieldDescription:
		m.ResetDescription()
		return nil
	case namespaceregistry.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case namespaceregistry.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown NamespaceRegistry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceRegistryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceRegistryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceRegistryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceRegistryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceRegistryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceRegistryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceRegistryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NamespaceRegistry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceRegistryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NamespaceRegistry edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	_type         *notification.Type
	title         *string
	message       *string
	resource_type *string
	resource_id   *string
	read          *bool
	read_at       *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id string) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetType sets the "type" field.
func (m *NotificationMutation) SetType(n notification.Type) {
	m._type = &n
}

// GetType returns the value of the "type" field in the mutation.
func (m *NotificationMutation) GetType() (r notification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldType(ctx context.Context) (v notification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *NotificationMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetMessage sets the "message" field.
func (m *NotificationMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NotificationMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *NotificationMutation) ResetMessage() {
	m.message = nil
}

// SetResourceType sets the "resource_type" field.
func (m *NotificationMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *NotificationMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *NotificationMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[notification.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *NotificationMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[notification.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *NotificationMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, notification.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *NotificationMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *NotificationMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *NotificationMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[notification.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *NotificationMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[notification.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *NotificationMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, notification.FieldResourceID)
}

// SetRead sets the "read" field.
func (m *NotificationMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *NotificationMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *NotificationMutation) ResetRead() {
	m.read = nil
}

// SetReadAt sets the "read_at" field.
func (m *NotificationMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *NotificationMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *NotificationMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[notification.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *NotificationMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *NotificationMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, notification.FieldReadAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *NotificationMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotificationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NotificationMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m._type != nil {
		fields = append(fields, notification.FieldType)
	}
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, notification.FieldMessage)
	}
	if m.resource_type != nil {
		fields = append(fields, notification.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, notification.FieldResourceID)
	}
	if m.read != nil {
		fields = append(fields, notification.FieldRead)
	}
	if m.read_at != nil {
		fields = append(fields, notification.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldType:
		return m.GetType()
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldMessage:
		return m.Message()
	case notification.FieldResourceType:
		return m.ResourceType()
	case notification.FieldResourceID:
		return m.ResourceID()
	case notification.FieldRead:
		return m.Read()
	case notification.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldType:
		return m.OldType(ctx)
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldMessage:
		return m.OldMessage(ctx)
	case notification.FieldResourceType:
		return m.OldResourceType(ctx)
	case notification.FieldResourceID:
		return m.OldResourceID(ctx)
	case notification.FieldRead:
		return m.OldRead(ctx)
	case notification.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldType:
		v, ok := value.(notification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case notification.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case notification.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case notification.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	case notification.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldResourceType) {
		fields = append(fields, notification.FieldResourceType)
	}
	if m.FieldCleared(notification.FieldResourceID) {
		fields = append(fields, notification.FieldResourceID)
	}
	if m.FieldCleared(notification.FieldReadAt) {
		fields = append(fields, notification.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldResourceType:
		m.ClearResourceType()
		return nil
	case notification.FieldResourceID:
		m.ClearResourceID()
		return nil
	case notification.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldType:
		m.ResetType()
		return nil
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldMessage:
		m.ResetMessage()
		return nil
	case notification.FieldResourceType:
		m.ResetResourceType()
		return nil
	case notification.FieldResourceID:
		m.ResetResourceID()
		return nil
	case notification.FieldRead:
		m.ResetRead()
		return nil
	case notification.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, notification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, notification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PendingAdoptionMutation represents an operation that mutates the PendingAdoption nodes in the graph.
type PendingAdoptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	cluster_id    *string
	namespace     *string
	resource_name *string
	resource_type *string
	status        *pendingadoption.Status
	discovered_by *string
	labels        *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PendingAdoption, error)
	predicates    []predicate.PendingAdoption
}

var _ ent.Mutation = (*PendingAdoptionMutation)(nil)

// pendingadoptionOption allows management of the mutation configuration using functional options.
type pendingadoptionOption func(*PendingAdoptionMutation)

// newPendingAdoptionMutation creates new mutation for the PendingAdoption entity.
func newPendingAdoptionMutation(c config, op Op, opts ...pendingadoptionOption) *PendingAdoptionMutation {
	m := &PendingAdoptionMutation{
		config:        c,
		op:            op,
		typ:           TypePendingAdoption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingAdoptionID sets the ID field of the mutation.
func withPendingAdoptionID(id string) pendingadoptionOption {
	return func(m *PendingAdoptionMutation) {
		var (
			err   error
			once  sync.Once
			value *PendingAdoption
		)
		m.oldValue = func(ctx context.Context) (*PendingAdoption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PendingAdoption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingAdoption sets the old PendingAdoption of the mutation.
func withPendingAdoption(node *PendingAdoption) pendingadoptionOption {
	return func(m *PendingAdoptionMutation) {
		m.oldValue = func(context.Context) (*PendingAdoption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingAdoptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingAdoptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PendingAdoption entities.
func (m *PendingAdoptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PendingAdoptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PendingAdoptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PendingAdoption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PendingAdoptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PendingAdoptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PendingAdoptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PendingAdoptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PendingAdoptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PendingAdoptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClusterID sets the "cluster_id" field.
func (m *PendingAdoptionMutation) SetClusterID(s string) {
	m.cluster_id = &s
}

// ClusterID returns the value of the "cluster_id" field in the mutation.
func (m *PendingAdoptionMutation) ClusterID() (r string, exists bool) {
	v := m.cluster_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterID returns the old "cluster_id" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldClusterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterID: %w", err)
	}
	return oldValue.ClusterID, nil
}

// ResetClusterID resets all changes to the "cluster_id" field.
func (m *PendingAdoptionMutation) ResetClusterID() {
	m.cluster_id = nil
}

// SetNamespace sets the "namespace" field.
func (m *PendingAdoptionMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *PendingAdoptionMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *PendingAdoptionMutation) ResetNamespace() {
	m.namespace = nil
}

// SetResourceName sets the "resource_name" field.
func (m *PendingAdoptionMutation) SetResourceName(s string) {
	m.resource_name = &s
}

// ResourceName returns the value of the "resource_name" field in the mutation.
func (m *PendingAdoptionMutation) ResourceName() (r string, exists bool) {
	v := m.resource_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceName returns the old "resource_name" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldResourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceName: %w", err)
	}
	return oldValue.ResourceName, nil
}

// ResetResourceName resets all changes to the "resource_name" field.
func (m *PendingAdoptionMutation) ResetResourceName() {
	m.resource_name = nil
}

// SetResourceType sets the "resource_type" field.
func (m *PendingAdoptionMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *PendingAdoptionMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *PendingAdoptionMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetStatus sets the "status" field.
func (m *PendingAdoptionMutation) SetStatus(pe pendingadoption.Status) {
	m.status = &pe
}

// Status returns the value of the "status" field in the mutation.
func (m *PendingAdoptionMutation) Status() (r pendingadoption.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldStatus(ctx context.Context) (v pendingadoption.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PendingAdoptionMutation) ResetStatus() {
	m.status = nil
}

// SetDiscoveredBy sets the "discovered_by" field.
func (m *PendingAdoptionMutation) SetDiscoveredBy(s string) {
	m.discovered_by = &s
}

// DiscoveredBy returns the value of the "discovered_by" field in the mutation.
func (m *PendingAdoptionMutation) DiscoveredBy() (r string, exists bool) {
	v := m.discovered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredBy returns the old "discovered_by" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldDiscoveredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredBy: %w", err)
	}
	return oldValue.DiscoveredBy, nil
}

// ClearDiscoveredBy clears the value of the "discovered_by" field.
func (m *PendingAdoptionMutation) ClearDiscoveredBy() {
	m.discovered_by = nil
	m.clearedFields[pendingadoption.FieldDiscoveredBy] = struct{}{}
}

// DiscoveredByCleared returns if the "discovered_by" field was cleared in this mutation.
func (m *PendingAdoptionMutation) DiscoveredByCleared() bool {
	_, ok := m.clearedFields[pendingadoption.FieldDiscoveredBy]
	return ok
}

// ResetDiscoveredBy resets all changes to the "discovered_by" field.
func (m *PendingAdoptionMutation) ResetDiscoveredBy() {
	m.discovered_by = nil
	delete(m.clearedFields, pendingadoption.FieldDiscoveredBy)
}

// SetLabels sets the "labels" field.
func (m *PendingAdoptionMutation) SetLabels(value map[string]string) {
	m.labels = &value
}

// Labels returns the value of the "labels" field in the mutation.
func (m *PendingAdoptionMutation) Labels() (r map[string]string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the PendingAdoption entity.
// If the PendingAdoption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingAdoptionMutation) OldLabels(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// ClearLabels clears the value of the "labels" field.
func (m *PendingAdoptionMutation) ClearLabels() {
	m.labels = nil
	m.clearedFields[pendingadoption.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *PendingAdoptionMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[pendingadoption.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *PendingAdoptionMutation) ResetLabels() {
	m.labels = nil
	delete(m.clearedFields, pendingadoption.FieldLabels)
}

// Where appends a list predicates to the PendingAdoptionMutation builder.
func (m *PendingAdoptionMutation) Where(ps ...predicate.PendingAdoption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PendingAdoptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PendingAdoptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PendingAdoption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PendingAdoptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PendingAdoptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PendingAdoption).
func (m *PendingAdoptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingAdoptionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, pendingadoption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pendingadoption.FieldUpdatedAt)
	}
	if m.cluster_id != nil {
		fields = append(fields, pendingadoption.FieldClusterID)
	}
	if m.namespace != nil {
		fields = append(fields, pendingadoption.FieldNamespace)
	}
	if m.resource_name != nil {
		fields = append(fields, pendingadoption.FieldResourceName)
	}
	if m.resource_type != nil {
		fields = append(fields, pendingadoption.FieldResourceType)
	}
	if m.status != nil {
		fields = append(fields, pendingadoption.FieldStatus)
	}
	if m.discovered_by != nil {
		fields = append(fields, pendingadoption.FieldDiscoveredBy)
	}
	if m.labels != nil {
		fields = append(fields, pendingadoption.FieldLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingAdoptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingadoption.FieldCreatedAt:
		return m.CreatedAt()
	case pendingadoption.FieldUpdatedAt:
		return m.UpdatedAt()
	case pendingadoption.FieldClusterID:
		return m.ClusterID()
	case pendingadoption.FieldNamespace:
		return m.Namespace()
	case pendingadoption.FieldResourceName:
		return m.ResourceName()
	case pendingadoption.FieldResourceType:
		return m.ResourceType()
	case pendingadoption.FieldStatus:
		return m.Status()
	case pendingadoption.FieldDiscoveredBy:
		return m.DiscoveredBy()
	case pendingadoption.FieldLabels:
		return m.Labels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingAdoptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingadoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pendingadoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pendingadoption.FieldClusterID:
		return m.OldClusterID(ctx)
	case pendingadoption.FieldNamespace:
		return m.OldNamespace(ctx)
	case pendingadoption.FieldResourceName:
		return m.OldResourceName(ctx)
	case pendingadoption.FieldResourceType:
		return m.OldResourceType(ctx)
	case pendingadoption.FieldStatus:
		return m.OldStatus(ctx)
	case pendingadoption.FieldDiscoveredBy:
		return m.OldDiscoveredBy(ctx)
	case pendingadoption.FieldLabels:
		return m.OldLabels(ctx)
	}
	return nil, fmt.Errorf("unknown PendingAdoption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingAdoptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingadoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pendingadoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pendingadoption.FieldClusterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterID(v)
		return nil
	case pendingadoption.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case pendingadoption.FieldResourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceName(v)
		return nil
	case pendingadoption.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case pendingadoption.FieldStatus:
		v, ok := value.(pendingadoption.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pendingadoption.FieldDiscoveredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredBy(v)
		return nil
	case pendingadoption.FieldLabels:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	}
	return fmt.Errorf("unknown PendingAdoption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingAdoptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingAdoptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingAdoptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PendingAdoption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingAdoptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pendingadoption.FieldDiscoveredBy) {
		fields = append(fields, pendingadoption.FieldDiscoveredBy)
	}
	if m.FieldCleared(pendingadoption.FieldLabels) {
		fields = append(fields, pendingadoption.FieldLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingAdoptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingAdoptionMutation) ClearField(name string) error {
	switch name {
	case pendingadoption.FieldDiscoveredBy:
		m.ClearDiscoveredBy()
		return nil
	case pendingadoption.FieldLabels:
		m.ClearLabels()
		return nil
	}
	return fmt.Errorf("unknown PendingAdoption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingAdoptionMutation) ResetField(name string) error {
	switch name {
	case pendingadoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pendingadoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pendingadoption.FieldClusterID:
		m.ResetClusterID()
		return nil
	case pendingadoption.FieldNamespace:
		m.ResetNamespace()
		return nil
	case pendingadoption.FieldResourceName:
		m.ResetResourceName()
		return nil
	case pendingadoption.FieldResourceType:
		m.ResetResourceType()
		return nil
	case pendingadoption.FieldStatus:
		m.ResetStatus()
		return nil
	case pendingadoption.FieldDiscoveredBy:
		m.ResetDiscoveredBy()
		return nil
	case pendingadoption.FieldLabels:
		m.ResetLabels()
		return nil
	}
	return fmt.Errorf("unknown PendingAdoption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingAdoptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingAdoptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingAdoptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingAdoptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingAdoptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingAdoptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingAdoptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PendingAdoption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingAdoptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PendingAdoption edge %s", name)
}

// RateLimitExemptionMutation represents an operation that mutates the RateLimitExemption nodes in the graph.
type RateLimitExemptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	exempted_by   *string
	reason        *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RateLimitExemption, error)
	predicates    []predicate.RateLimitExemption
}

var _ ent.Mutation = (*RateLimitExemptionMutation)(nil)

// ratelimitexemptionOption allows management of the mutation configuration using functional options.
type ratelimitexemptionOption func(*RateLimitExemptionMutation)

// newRateLimitExemptionMutation creates new mutation for the RateLimitExemption entity.
func newRateLimitExemptionMutation(c config, op Op, opts ...ratelimitexemptionOption) *RateLimitExemptionMutation {
	m := &RateLimitExemptionMutation{
		config:        c,
		op:            op,
		typ:           TypeRateLimitExemption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRateLimitExemptionID sets the ID field of the mutation.
func withRateLimitExemptionID(id string) ratelimitexemptionOption {
	return func(m *RateLimitExemptionMutation) {
		var (
			err   error
			once  sync.Once
			value *RateLimitExemption
		)
		m.oldValue = func(ctx context.Context) (*RateLimitExemption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RateLimitExemption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRateLimitExemption sets the old RateLimitExemption of the mutation.
func withRateLimitExemption(node *RateLimitExemption) ratelimitexemptionOption {
	return func(m *RateLimitExemptionMutation) {
		m.oldValue = func(context.Context) (*RateLimitExemption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RateLimitExemptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RateLimitExemptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RateLimitExemption entities.
func (m *RateLimitExemptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RateLimitExemptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RateLimitExemptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RateLimitExemption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RateLimitExemptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RateLimitExemptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RateLimitExemption entity.
// If the RateLimitExemption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitExemptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RateLimitExemptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RateLimitExemptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RateLimitExemptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RateLimitExemption entity.
// If the RateLimitExemption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitExemptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RateLimitExemptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExemptedBy sets the "exempted_by" field.
func (m *RateLimitExemptionMutation) SetExemptedBy(s string) {
	m.exempted_by = &s
}

// ExemptedBy returns the value of the "exempted_by" field in the mutation.
func (m *RateLimitExemptionMutation) ExemptedBy() (r string, exists bool) {
	v := m.exempted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptedBy returns the old "exempted_by" field's value of the RateLimitExemption entity.
// If the RateLimitExemption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitExemptionMutation) OldExemptedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExemptedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExemptedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptedBy: %w", err)
	}
	return oldValue.ExemptedBy, nil
}

// ResetExemptedBy resets all changes to the "exempted_by" field.
func (m *RateLimitExemptionMutation) ResetExemptedBy() {
	m.exempted_by = nil
}

// SetReason sets the "reason" field.
func (m *RateLimitExemptionMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RateLimitExemptionMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the RateLimitExemption entity.
// If the RateLimitExemption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitExemptionMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *RateLimitExemptionMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[ratelimitexemption.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *RateLimitExemptionMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[ratelimitexemption.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *RateLimitExemptionMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, ratelimitexemption.FieldReason)
}

// SetExpiresAt sets the "expires_at" field.
func (m *RateLimitExemptionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *RateLimitExemptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the RateLimitExemption entity.
// If the RateLimitExemption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitExemptionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *RateLimitExemptionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[ratelimitexemption.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *RateLimitExemptionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[ratelimitexemption.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *RateLimitExemptionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, ratelimitexemption.FieldExpiresAt)
}

// Where appends a list predicates to the RateLimitExemptionMutation builder.
func (m *RateLimitExemptionMutation) Where(ps ...predicate.RateLimitExemption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RateLimitExemptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RateLimitExemptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RateLimitExemption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RateLimitExemptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RateLimitExemptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RateLimitExemption).
func (m *RateLimitExemptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RateLimitExemptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, ratelimitexemption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ratelimitexemption.FieldUpdatedAt)
	}
	if m.exempted_by != nil {
		fields = append(fields, ratelimitexemption.FieldExemptedBy)
	}
	if m.reason != nil {
		fields = append(fields, ratelimitexemption.FieldReason)
	}
	if m.expires_at != nil {
		fields = append(fields, ratelimitexemption.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RateLimitExemptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ratelimitexemption.FieldCreatedAt:
		return m.CreatedAt()
	case ratelimitexemption.FieldUpdatedAt:
		return m.UpdatedAt()
	case ratelimitexemption.FieldExemptedBy:
		return m.ExemptedBy()
	case ratelimitexemption.FieldReason:
		return m.Reason()
	case ratelimitexemption.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RateLimitExemptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ratelimitexemption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ratelimitexemption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ratelimitexemption.FieldExemptedBy:
		return m.OldExemptedBy(ctx)
	case ratelimitexemption.FieldReason:
		return m.OldReason(ctx)
	case ratelimitexemption.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown RateLimitExemption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RateLimitExemptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ratelimitexemption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ratelimitexemption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ratelimitexemption.FieldExemptedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptedBy(v)
		return nil
	case ratelimitexemption.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case ratelimitexemption.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown RateLimitExemption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RateLimitExemptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RateLimitExemptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RateLimitExemptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RateLimitExemption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RateLimitExemptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ratelimitexemption.FieldReason) {
		fields = append(fields, ratelimitexemption.FieldReason)
	}
	if m.FieldCleared(ratelimitexemption.FieldExpiresAt) {
		fields = append(fields, ratelimitexemption.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RateLimitExemptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RateLimitExemptionMutation) ClearField(name string) error {
	switch name {
	case ratelimitexemption.FieldReason:
		m.ClearReason()
		return nil
	case ratelimitexemption.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown RateLimitExemption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RateLimitExemptionMutation) ResetField(name string) error {
	switch name {
	case ratelimitexemption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ratelimitexemption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ratelimitexemption.FieldExemptedBy:
		m.ResetExemptedBy()
		return nil
	case ratelimitexemption.FieldReason:
		m.ResetReason()
		return nil
	case ratelimitexemption.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown RateLimitExemption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RateLimitExemptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RateLimitExemptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RateLimitExemptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RateLimitExemptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RateLimitExemptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RateLimitExemptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RateLimitExemptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RateLimitExemption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RateLimitExemptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RateLimitExemption edge %s", name)
}

// RateLimitUserOverrideMutation represents an operation that mutates the RateLimitUserOverride nodes in the graph.
type RateLimitUserOverrideMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	max_pending_parents     *int
	addmax_pending_parents  *int
	max_pending_children    *int
	addmax_pending_children *int
	cooldown_seconds        *int
	addcooldown_seconds     *int
	reason                  *string
	updated_by              *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*RateLimitUserOverride, error)
	predicates              []predicate.RateLimitUserOverride
}

var _ ent.Mutation = (*RateLimitUserOverrideMutation)(nil)

// ratelimituseroverrideOption allows management of the mutation configuration using functional options.
type ratelimituseroverrideOption func(*RateLimitUserOverrideMutation)

// newRateLimitUserOverrideMutation creates new mutation for the RateLimitUserOverride entity.
func newRateLimitUserOverrideMutation(c config, op Op, opts ...ratelimituseroverrideOption) *RateLimitUserOverrideMutation {
	m := &RateLimitUserOverrideMutation{
		config:        c,
		op:            op,
		typ:           TypeRateLimitUserOverride,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRateLimitUserOverrideID sets the ID field of the mutation.
func withRateLimitUserOverrideID(id string) ratelimituseroverrideOption {
	return func(m *RateLimitUserOverrideMutation) {
		var (
			err   error
			once  sync.Once
			value *RateLimitUserOverride
		)
		m.oldValue = func(ctx context.Context) (*RateLimitUserOverride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RateLimitUserOverride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRateLimitUserOverride sets the old RateLimitUserOverride of the mutation.
func withRateLimitUserOverride(node *RateLimitUserOverride) ratelimituseroverrideOption {
	return func(m *RateLimitUserOverrideMutation) {
		m.oldValue = func(context.Context) (*RateLimitUserOverride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RateLimitUserOverrideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RateLimitUserOverrideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RateLimitUserOverride entities.
func (m *RateLimitUserOverrideMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RateLimitUserOverrideMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RateLimitUserOverrideMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RateLimitUserOverride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RateLimitUserOverrideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RateLimitUserOverrideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RateLimitUserOverrideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RateLimitUserOverrideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RateLimitUserOverrideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RateLimitUserOverrideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMaxPendingParents sets the "max_pending_parents" field.
func (m *RateLimitUserOverrideMutation) SetMaxPendingParents(i int) {
	m.max_pending_parents = &i
	m.addmax_pending_parents = nil
}

// MaxPendingParents returns the value of the "max_pending_parents" field in the mutation.
func (m *RateLimitUserOverrideMutation) MaxPendingParents() (r int, exists bool) {
	v := m.max_pending_parents
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxPendingParents returns the old "max_pending_parents" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldMaxPendingParents(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxPendingParents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxPendingParents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxPendingParents: %w", err)
	}
	return oldValue.MaxPendingParents, nil
}

// AddMaxPendingParents adds i to the "max_pending_parents" field.
func (m *RateLimitUserOverrideMutation) AddMaxPendingParents(i int) {
	if m.addmax_pending_parents != nil {
		*m.addmax_pending_parents += i
	} else {
		m.addmax_pending_parents = &i
	}
}

// AddedMaxPendingParents returns the value that was added to the "max_pending_parents" field in this mutation.
func (m *RateLimitUserOverrideMutation) AddedMaxPendingParents() (r int, exists bool) {
	v := m.addmax_pending_parents
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxPendingParents clears the value of the "max_pending_parents" field.
func (m *RateLimitUserOverrideMutation) ClearMaxPendingParents() {
	m.max_pending_parents = nil
	m.addmax_pending_parents = nil
	m.clearedFields[ratelimituseroverride.FieldMaxPendingParents] = struct{}{}
}

// MaxPendingParentsCleared returns if the "max_pending_parents" field was cleared in this mutation.
func (m *RateLimitUserOverrideMutation) MaxPendingParentsCleared() bool {
	_, ok := m.clearedFields[ratelimituseroverride.FieldMaxPendingParents]
	return ok
}

// ResetMaxPendingParents resets all changes to the "max_pending_parents" field.
func (m *RateLimitUserOverrideMutation) ResetMaxPendingParents() {
	m.max_pending_parents = nil
	m.addmax_pending_parents = nil
	delete(m.clearedFields, ratelimituseroverride.FieldMaxPendingParents)
}

// SetMaxPendingChildren sets the "max_pending_children" field.
func (m *RateLimitUserOverrideMutation) SetMaxPendingChildren(i int) {
	m.max_pending_children = &i
	m.addmax_pending_children = nil
}

// MaxPendingChildren returns the value of the "max_pending_children" field in the mutation.
func (m *RateLimitUserOverrideMutation) MaxPendingChildren() (r int, exists bool) {
	v := m.max_pending_children
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxPendingChildren returns the old "max_pending_children" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldMaxPendingChildren(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxPendingChildren is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxPendingChildren requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxPendingChildren: %w", err)
	}
	return oldValue.MaxPendingChildren, nil
}

// AddMaxPendingChildren adds i to the "max_pending_children" field.
func (m *RateLimitUserOverrideMutation) AddMaxPendingChildren(i int) {
	if m.addmax_pending_children != nil {
		*m.addmax_pending_children += i
	} else {
		m.addmax_pending_children = &i
	}
}

// AddedMaxPendingChildren returns the value that was added to the "max_pending_children" field in this mutation.
func (m *RateLimitUserOverrideMutation) AddedMaxPendingChildren() (r int, exists bool) {
	v := m.addmax_pending_children
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxPendingChildren clears the value of the "max_pending_children" field.
func (m *RateLimitUserOverrideMutation) ClearMaxPendingChildren() {
	m.max_pending_children = nil
	m.addmax_pending_children = nil
	m.clearedFields[ratelimituseroverride.FieldMaxPendingChildren] = struct{}{}
}

// MaxPendingChildrenCleared returns if the "max_pending_children" field was cleared in this mutation.
func (m *RateLimitUserOverrideMutation) MaxPendingChildrenCleared() bool {
	_, ok := m.clearedFields[ratelimituseroverride.FieldMaxPendingChildren]
	return ok
}

// ResetMaxPendingChildren resets all changes to the "max_pending_children" field.
func (m *RateLimitUserOverrideMutation) ResetMaxPendingChildren() {
	m.max_pending_children = nil
	m.addmax_pending_children = nil
	delete(m.clearedFields, ratelimituseroverride.FieldMaxPendingChildren)
}

// SetCooldownSeconds sets the "cooldown_seconds" field.
func (m *RateLimitUserOverrideMutation) SetCooldownSeconds(i int) {
	m.cooldown_seconds = &i
	m.addcooldown_seconds = nil
}

// CooldownSeconds returns the value of the "cooldown_seconds" field in the mutation.
func (m *RateLimitUserOverrideMutation) CooldownSeconds() (r int, exists bool) {
	v := m.cooldown_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldownSeconds returns the old "cooldown_seconds" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldCooldownSeconds(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldownSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldownSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldownSeconds: %w", err)
	}
	return oldValue.CooldownSeconds, nil
}

// AddCooldownSeconds adds i to the "cooldown_seconds" field.
func (m *RateLimitUserOverrideMutation) AddCooldownSeconds(i int) {
	if m.addcooldown_seconds != nil {
		*m.addcooldown_seconds += i
	} else {
		m.addcooldown_seconds = &i
	}
}

// AddedCooldownSeconds returns the value that was added to the "cooldown_seconds" field in this mutation.
func (m *RateLimitUserOverrideMutation) AddedCooldownSeconds() (r int, exists bool) {
	v := m.addcooldown_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearCooldownSeconds clears the value of the "cooldown_seconds" field.
func (m *RateLimitUserOverrideMutation) ClearCooldownSeconds() {
	m.cooldown_seconds = nil
	m.addcooldown_seconds = nil
	m.clearedFields[ratelimituseroverride.FieldCooldownSeconds] = struct{}{}
}

// CooldownSecondsCleared returns if the "cooldown_seconds" field was cleared in this mutation.
func (m *RateLimitUserOverrideMutation) CooldownSecondsCleared() bool {
	_, ok := m.clearedFields[ratelimituseroverride.FieldCooldownSeconds]
	return ok
}

// ResetCooldownSeconds resets all changes to the "cooldown_seconds" field.
func (m *RateLimitUserOverrideMutation) ResetCooldownSeconds() {
	m.cooldown_seconds = nil
	m.addcooldown_seconds = nil
	delete(m.clearedFields, ratelimituseroverride.FieldCooldownSeconds)
}

// SetReason sets the "reason" field.
func (m *RateLimitUserOverrideMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RateLimitUserOverrideMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *RateLimitUserOverrideMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[ratelimituseroverride.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *RateLimitUserOverrideMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[ratelimituseroverride.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *RateLimitUserOverrideMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, ratelimituseroverride.FieldReason)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RateLimitUserOverrideMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RateLimitUserOverrideMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RateLimitUserOverride entity.
// If the RateLimitUserOverride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RateLimitUserOverrideMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RateLimitUserOverrideMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// Where appends a list predicates to the RateLimitUserOverrideMutation builder.
func (m *RateLimitUserOverrideMutation) Where(ps ...predicate.RateLimitUserOverride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RateLimitUserOverrideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RateLimitUserOverrideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RateLimitUserOverride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RateLimitUserOverrideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RateLimitUserOverrideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RateLimitUserOverride).
func (m *RateLimitUserOverrideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RateLimitUserOverrideMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ratelimituseroverride.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ratelimituseroverride.FieldUpdatedAt)
	}
	if m.max_pending_parents != nil {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingParents)
	}
	if m.max_pending_children != nil {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingChildren)
	}
	if m.cooldown_seconds != nil {
		fields = append(fields, ratelimituseroverride.FieldCooldownSeconds)
	}
	if m.reason != nil {
		fields = append(fields, ratelimituseroverride.FieldReason)
	}
	if m.updated_by != nil {
		fields = append(fields, ratelimituseroverride.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RateLimitUserOverrideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ratelimituseroverride.FieldCreatedAt:
		return m.CreatedAt()
	case ratelimituseroverride.FieldUpdatedAt:
		return m.UpdatedAt()
	case ratelimituseroverride.FieldMaxPendingParents:
		return m.MaxPendingParents()
	case ratelimituseroverride.FieldMaxPendingChildren:
		return m.MaxPendingChildren()
	case ratelimituseroverride.FieldCooldownSeconds:
		return m.CooldownSeconds()
	case ratelimituseroverride.FieldReason:
		return m.Reason()
	case ratelimituseroverride.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RateLimitUserOverrideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ratelimituseroverride.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ratelimituseroverride.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ratelimituseroverride.FieldMaxPendingParents:
		return m.OldMaxPendingParents(ctx)
	case ratelimituseroverride.FieldMaxPendingChildren:
		return m.OldMaxPendingChildren(ctx)
	case ratelimituseroverride.FieldCooldownSeconds:
		return m.OldCooldownSeconds(ctx)
	case ratelimituseroverride.FieldReason:
		return m.OldReason(ctx)
	case ratelimituseroverride.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown RateLimitUserOverride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RateLimitUserOverrideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ratelimituseroverride.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ratelimituseroverride.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ratelimituseroverride.FieldMaxPendingParents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxPendingParents(v)
		return nil
	case ratelimituseroverride.FieldMaxPendingChildren:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxPendingChildren(v)
		return nil
	case ratelimituseroverride.FieldCooldownSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldownSeconds(v)
		return nil
	case ratelimituseroverride.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case ratelimituseroverride.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RateLimitUserOverride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RateLimitUserOverrideMutation) AddedFields() []string {
	var fields []string
	if m.addmax_pending_parents != nil {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingParents)
	}
	if m.addmax_pending_children != nil {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingChildren)
	}
	if m.addcooldown_seconds != nil {
		fields = append(fields, ratelimituseroverride.FieldCooldownSeconds)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RateLimitUserOverrideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ratelimituseroverride.FieldMaxPendingParents:
		return m.AddedMaxPendingParents()
	case ratelimituseroverride.FieldMaxPendingChildren:
		return m.AddedMaxPendingChildren()
	case ratelimituseroverride.FieldCooldownSeconds:
		return m.AddedCooldownSeconds()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RateLimitUserOverrideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ratelimituseroverride.FieldMaxPendingParents:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxPendingParents(v)
		return nil
	case ratelimituseroverride.FieldMaxPendingChildren:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxPendingChildren(v)
		return nil
	case ratelimituseroverride.FieldCooldownSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldownSeconds(v)
		return nil
	}
	return fmt.Errorf("unknown RateLimitUserOverride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RateLimitUserOverrideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ratelimituseroverride.FieldMaxPendingParents) {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingParents)
	}
	if m.FieldCleared(ratelimituseroverride.FieldMaxPendingChildren) {
		fields = append(fields, ratelimituseroverride.FieldMaxPendingChildren)
	}
	if m.FieldCleared(ratelimituseroverride.FieldCooldownSeconds) {
		fields = append(fields, ratelimituseroverride.FieldCooldownSeconds)
	}
	if m.FieldCleared(ratelimituseroverride.FieldReason) {
		fields = append(fields, ratelimituseroverride.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RateLimitUserOverrideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RateLimitUserOverrideMutation) ClearField(name string) error {
	switch name {
	case ratelimituseroverride.FieldMaxPendingParents:
		m.ClearMaxPendingParents()
		return nil
	case ratelimituseroverride.FieldMaxPendingChildren:
		m.ClearMaxPendingChildren()
		return nil
	case ratelimituseroverride.FieldCooldownSeconds:
		m.ClearCooldownSeconds()
		return nil
	case ratelimituseroverride.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown RateLimitUserOverride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RateLimitUserOverrideMutation) ResetField(name string) error {
	switch name {
	case ratelimituseroverride.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ratelimituseroverride.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ratelimituseroverride.FieldMaxPendingParents:
		m.ResetMaxPendingParents()
		return nil
	case ratelimituseroverride.FieldMaxPendingChildren:
		m.ResetMaxPendingChildren()
		return nil
	case ratelimituseroverride.FieldCooldownSeconds:
		m.ResetCooldownSeconds()
		return nil
	case ratelimituseroverride.FieldReason:
		m.ResetReason()
		return nil
	case ratelimituseroverride.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown RateLimitUserOverride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RateLimitUserOverrideMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RateLimitUserOverrideMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RateLimitUserOverrideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RateLimitUserOverrideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RateLimitUserOverrideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RateLimitUserOverrideMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RateLimitUserOverrideMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RateLimitUserOverride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RateLimitUserOverrideMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RateLimitUserOverride edge %s", name)
}

// ResourceRoleBindingMutation represents an operation that mutates the ResourceRoleBinding nodes in the graph.
type ResourceRoleBindingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *string
	resource_type *string
	resource_id   *string
	role          *resourcerolebinding.Role
	created_by    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ResourceRoleBinding, error)
	predicates    []predicate.ResourceRoleBinding
}

var _ ent.Mutation = (*ResourceRoleBindingMutation)(nil)

// resourcerolebindingOption allows management of the mutation configuration using functional options.
type resourcerolebindingOption func(*ResourceRoleBindingMutation)

// newResourceRoleBindingMutation creates new mutation for the ResourceRoleBinding entity.
func newResourceRoleBindingMutation(c config, op Op, opts ...resourcerolebindingOption) *ResourceRoleBindingMutation {
	m := &ResourceRoleBindingMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceRoleBinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceRoleBindingID sets the ID field of the mutation.
func withResourceRoleBindingID(id string) resourcerolebindingOption {
	return func(m *ResourceRoleBindingMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceRoleBinding
		)
		m.oldValue = func(ctx context.Context) (*ResourceRoleBinding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceRoleBinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceRoleBinding sets the old ResourceRoleBinding of the mutation.
func withResourceRoleBinding(node *ResourceRoleBinding) resourcerolebindingOption {
	return func(m *ResourceRoleBindingMutation) {
		m.oldValue = func(context.Context) (*ResourceRoleBinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceRoleBindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceRoleBindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResourceRoleBinding entities.
func (m *ResourceRoleBindingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceRoleBindingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceRoleBindingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResourceRoleBinding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceRoleBindingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceRoleBindingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceRoleBindingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceRoleBindingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceRoleBindingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceRoleBindingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ResourceRoleBindingMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ResourceRoleBindingMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ResourceRoleBindingMutation) ResetUserID() {
	m.user_id = nil
}

// SetResourceType sets the "resource_type" field.
func (m *ResourceRoleBindingMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *ResourceRoleBindingMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *ResourceRoleBindingMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *ResourceRoleBindingMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ResourceRoleBindingMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ResourceRoleBindingMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetRole sets the "role" field.
func (m *ResourceRoleBindingMutation) SetRole(r resourcerolebinding.Role) {
	m.role = &r
}

// Role returns the value of the "role" field in the mutation.
func (m *ResourceRoleBindingMutation) Role() (r resourcerolebinding.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldRole(ctx context.Context) (v resourcerolebinding.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ResourceRoleBindingMutation) ResetRole() {
	m.role = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ResourceRoleBindingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ResourceRoleBindingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ResourceRoleBinding entity.
// If the ResourceRoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceRoleBindingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ResourceRoleBindingMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the ResourceRoleBindingMutation builder.
func (m *ResourceRoleBindingMutation) Where(ps ...predicate.ResourceRoleBinding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceRoleBindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceRoleBindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResourceRoleBinding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceRoleBindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceRoleBindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResourceRoleBinding).
func (m *ResourceRoleBindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceRoleBindingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, resourcerolebinding.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resourcerolebinding.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, resourcerolebinding.FieldUserID)
	}
	if m.resource_type != nil {
		fields = append(fields, resourcerolebinding.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, resourcerolebinding.FieldResourceID)
	}
	if m.role != nil {
		fields = append(fields, resourcerolebinding.FieldRole)
	}
	if m.created_by != nil {
		fields = append(fields, resourcerolebinding.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceRoleBindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcerolebinding.FieldCreatedAt:
		return m.CreatedAt()
	case resourcerolebinding.FieldUpdatedAt:
		return m.UpdatedAt()
	case resourcerolebinding.FieldUserID:
		return m.UserID()
	case resourcerolebinding.FieldResourceType:
		return m.ResourceType()
	case resourcerolebinding.FieldResourceID:
		return m.ResourceID()
	case resourcerolebinding.FieldRole:
		return m.Role()
	case resourcerolebinding.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceRoleBindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcerolebinding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resourcerolebinding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resourcerolebinding.FieldUserID:
		return m.OldUserID(ctx)
	case resourcerolebinding.FieldResourceType:
		return m.OldResourceType(ctx)
	case resourcerolebinding.FieldResourceID:
		return m.OldResourceID(ctx)
	case resourcerolebinding.FieldRole:
		return m.OldRole(ctx)
	case resourcerolebinding.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceRoleBinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRoleBindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcerolebinding.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resourcerolebinding.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resourcerolebinding.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case resourcerolebinding.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case resourcerolebinding.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case resourcerolebinding.FieldRole:
		v, ok := value.(resourcerolebinding.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case resourcerolebinding.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceRoleBinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceRoleBindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceRoleBindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceRoleBindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceRoleBinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceRoleBindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceRoleBindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceRoleBindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceRoleBinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceRoleBindingMutation) ResetField(name string) error {
	switch name {
	case resourcerolebinding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resourcerolebinding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resourcerolebinding.FieldUserID:
		m.ResetUserID()
		return nil
	case resourcerolebinding.FieldResourceType:
		m.ResetResourceType()
		return nil
	case resourcerolebinding.FieldResourceID:
		m.ResetResourceID()
		return nil
	case resourcerolebinding.FieldRole:
		m.ResetRole()
		return nil
	case resourcerolebinding.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ResourceRoleBinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceRoleBindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceRoleBindingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceRoleBindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceRoleBindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceRoleBindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceRoleBindingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceRoleBindingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResourceRoleBinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceRoleBindingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResourceRoleBinding edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	display_name         *string
	description          *string
	permissions          *[]string
	appendpermissions    []string
	built_in             *bool
	enabled              *bool
	clearedFields        map[string]struct{}
	role_bindings        map[string]struct{}
	removedrole_bindings map[string]struct{}
	clearedrole_bindings bool
	done                 bool
	oldValue             func(context.Context) (*Role, error)
	predicates           []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *RoleMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *RoleMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *RoleMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[role.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *RoleMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[role.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *RoleMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, role.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetPermissions sets the "permissions" field.
func (m *RoleMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *RoleMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *RoleMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *RoleMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *RoleMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[role.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *RoleMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[role.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, role.FieldPermissions)
}

// SetBuiltIn sets the "built_in" field.
func (m *RoleMutation) SetBuiltIn(b bool) {
	m.built_in = &b
}

// BuiltIn returns the value of the "built_in" field in the mutation.
func (m *RoleMutation) BuiltIn() (r bool, exists bool) {
	v := m.built_in
	if v == nil {
		return
	}
	return *v, true
}

// OldBuiltIn returns the old "built_in" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBuiltIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuiltIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuiltIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuiltIn: %w", err)
	}
	return oldValue.BuiltIn, nil
}

// ResetBuiltIn resets all changes to the "built_in" field.
func (m *RoleMutation) ResetBuiltIn() {
	m.built_in = nil
}

// SetEnabled sets the "enabled" field.
func (m *RoleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *RoleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *RoleMutation) ResetEnabled() {
	m.enabled = nil
}

// AddRoleBindingIDs adds the "role_bindings" edge to the RoleBinding entity by ids.
func (m *RoleMutation) AddRoleBindingIDs(ids ...string) {
	if m.role_bindings == nil {
		m.role_bindings = make(map[string]struct{})
	}
	for i := range ids {
		m.role_bindings[ids[i]] = struct{}{}
	}
}

// ClearRoleBindings clears the "role_bindings" edge to the RoleBinding entity.
func (m *RoleMutation) ClearRoleBindings() {
	m.clearedrole_bindings = true
}

// RoleBindingsCleared reports if the "role_bindings" edge to the RoleBinding entity was cleared.
func (m *RoleMutation) RoleBindingsCleared() bool {
	return m.clearedrole_bindings
}

// RemoveRoleBindingIDs removes the "role_bindings" edge to the RoleBinding entity by IDs.
func (m *RoleMutation) RemoveRoleBindingIDs(ids ...string) {
	if m.removedrole_bindings == nil {
		m.removedrole_bindings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.role_bindings, ids[i])
		m.removedrole_bindings[ids[i]] = struct{}{}
	}
}

// RemovedRoleBindings returns the removed IDs of the "role_bindings" edge to the RoleBinding entity.
func (m *RoleMutation) RemovedRoleBindingsIDs() (ids []string) {
	for id := range m.removedrole_bindings {
		ids = append(ids, id)
	}
	return
}

// RoleBindingsIDs returns the "role_bindings" edge IDs in the mutation.
func (m *RoleMutation) RoleBindingsIDs() (ids []string) {
	for id := range m.role_bindings {
		ids = append(ids, id)
	}
	return
}

// ResetRoleBindings resets all changes to the "role_bindings" edge.
func (m *RoleMutation) ResetRoleBindings() {
	m.role_bindings = nil
	m.clearedrole_bindings = false
	m.removedrole_bindings = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, role.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.permissions != nil {
		fields = append(fields, role.FieldPermissions)
	}
	if m.built_in != nil {
		fields = append(fields, role.FieldBuiltIn)
	}
	if m.enabled != nil {
		fields = append(fields, role.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDisplayName:
		return m.DisplayName()
	case role.FieldDescription:
		return m.Description()
	case role.FieldPermissions:
		return m.Permissions()
	case role.FieldBuiltIn:
		return m.BuiltIn()
	case role.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldPermissions:
		return m.OldPermissions(ctx)
	case role.FieldBuiltIn:
		return m.OldBuiltIn(ctx)
	case role.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case role.FieldBuiltIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuiltIn(v)
		return nil
	case role.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDisplayName) {
		fields = append(fields, role.FieldDisplayName)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldPermissions) {
		fields = append(fields, role.FieldPermissions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldPermissions:
		m.ClearPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldPermissions:
		m.ResetPermissions()
		return nil
	case role.FieldBuiltIn:
		m.ResetBuiltIn()
		return nil
	case role.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role_bindings != nil {
		edges = append(edges, role.EdgeRoleBindings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleBindings:
		ids := make([]ent.Value, 0, len(m.role_bindings))
		for id := range m.role_bindings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrole_bindings != nil {
		edges = append(edges, role.EdgeRoleBindings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRoleBindings:
		ids := make([]ent.Value, 0, len(m.removedrole_bindings))
		for id := range m.removedrole_bindings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole_bindings {
		edges = append(edges, role.EdgeRoleBindings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeRoleBindings:
		return m.clearedrole_bindings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRoleBindings:
		m.ResetRoleBindings()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleBindingMutation represents an operation that mutates the RoleBinding nodes in the graph.
type RoleBindingMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	scope_type                 *string
	scope_id                   *string
	allowed_environments       *[]string
	appendallowed_environments []string
	created_by                 *string
	clearedFields              map[string]struct{}
	user                       *string
	cleareduser                bool
	role                       *string
	clearedrole                bool
	done                       bool
	oldValue                   func(context.Context) (*RoleBinding, error)
	predicates                 []predicate.RoleBinding
}

var _ ent.Mutation = (*RoleBindingMutation)(nil)

// rolebindingOption allows management of the mutation configuration using functional options.
type rolebindingOption func(*RoleBindingMutation)

// newRoleBindingMutation creates new mutation for the RoleBinding entity.
func newRoleBindingMutation(c config, op Op, opts ...rolebindingOption) *RoleBindingMutation {
	m := &RoleBindingMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleBinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleBindingID sets the ID field of the mutation.
func withRoleBindingID(id string) rolebindingOption {
	return func(m *RoleBindingMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleBinding
		)
		m.oldValue = func(ctx context.Context) (*RoleBinding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleBinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleBinding sets the old RoleBinding of the mutation.
func withRoleBinding(node *RoleBinding) rolebindingOption {
	return func(m *RoleBindingMutation) {
		m.oldValue = func(context.Context) (*RoleBinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleBindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleBindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RoleBinding entities.
func (m *RoleBindingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleBindingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleBindingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RoleBinding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleBindingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleBindingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleBindingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleBindingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleBindingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleBindingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetScopeType sets the "scope_type" field.
func (m *RoleBindingMutation) SetScopeType(s string) {
	m.scope_type = &s
}

// ScopeType returns the value of the "scope_type" field in the mutation.
func (m *RoleBindingMutation) ScopeType() (r string, exists bool) {
	v := m.scope_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeType returns the old "scope_type" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldScopeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeType: %w", err)
	}
	return oldValue.ScopeType, nil
}

// ClearScopeType clears the value of the "scope_type" field.
func (m *RoleBindingMutation) ClearScopeType() {
	m.scope_type = nil
	m.clearedFields[rolebinding.FieldScopeType] = struct{}{}
}

// ScopeTypeCleared returns if the "scope_type" field was cleared in this mutation.
func (m *RoleBindingMutation) ScopeTypeCleared() bool {
	_, ok := m.clearedFields[rolebinding.FieldScopeType]
	return ok
}

// ResetScopeType resets all changes to the "scope_type" field.
func (m *RoleBindingMutation) ResetScopeType() {
	m.scope_type = nil
	delete(m.clearedFields, rolebinding.FieldScopeType)
}

// SetScopeID sets the "scope_id" field.
func (m *RoleBindingMutation) SetScopeID(s string) {
	m.scope_id = &s
}

// ScopeID returns the value of the "scope_id" field in the mutation.
func (m *RoleBindingMutation) ScopeID() (r string, exists bool) {
	v := m.scope_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeID returns the old "scope_id" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldScopeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeID: %w", err)
	}
	return oldValue.ScopeID, nil
}

// ClearScopeID clears the value of the "scope_id" field.
func (m *RoleBindingMutation) ClearScopeID() {
	m.scope_id = nil
	m.clearedFields[rolebinding.FieldScopeID] = struct{}{}
}

// ScopeIDCleared returns if the "scope_id" field was cleared in this mutation.
func (m *RoleBindingMutation) ScopeIDCleared() bool {
	_, ok := m.clearedFields[rolebinding.FieldScopeID]
	return ok
}

// ResetScopeID resets all changes to the "scope_id" field.
func (m *RoleBindingMutation) ResetScopeID() {
	m.scope_id = nil
	delete(m.clearedFields, rolebinding.FieldScopeID)
}

// SetAllowedEnvironments sets the "allowed_environments" field.
func (m *RoleBindingMutation) SetAllowedEnvironments(s []string) {
	m.allowed_environments = &s
	m.appendallowed_environments = nil
}

// AllowedEnvironments returns the value of the "allowed_environments" field in the mutation.
func (m *RoleBindingMutation) AllowedEnvironments() (r []string, exists bool) {
	v := m.allowed_environments
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedEnvironments returns the old "allowed_environments" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldAllowedEnvironments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedEnvironments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedEnvironments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedEnvironments: %w", err)
	}
	return oldValue.AllowedEnvironments, nil
}

// AppendAllowedEnvironments adds s to the "allowed_environments" field.
func (m *RoleBindingMutation) AppendAllowedEnvironments(s []string) {
	m.appendallowed_environments = append(m.appendallowed_environments, s...)
}

// AppendedAllowedEnvironments returns the list of values that were appended to the "allowed_environments" field in this mutation.
func (m *RoleBindingMutation) AppendedAllowedEnvironments() ([]string, bool) {
	if len(m.appendallowed_environments) == 0 {
		return nil, false
	}
	return m.appendallowed_environments, true
}

// ClearAllowedEnvironments clears the value of the "allowed_environments" field.
func (m *RoleBindingMutation) ClearAllowedEnvironments() {
	m.allowed_environments = nil
	m.appendallowed_environments = nil
	m.clearedFields[rolebinding.FieldAllowedEnvironments] = struct{}{}
}

// AllowedEnvironmentsCleared returns if the "allowed_environments" field was cleared in this mutation.
func (m *RoleBindingMutation) AllowedEnvironmentsCleared() bool {
	_, ok := m.clearedFields[rolebinding.FieldAllowedEnvironments]
	return ok
}

// ResetAllowedEnvironments resets all changes to the "allowed_environments" field.
func (m *RoleBindingMutation) ResetAllowedEnvironments() {
	m.allowed_environments = nil
	m.appendallowed_environments = nil
	delete(m.clearedFields, rolebinding.FieldAllowedEnvironments)
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleBindingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleBindingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RoleBinding entity.
// If the RoleBinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleBindingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleBindingMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RoleBindingMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RoleBindingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RoleBindingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RoleBindingMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RoleBindingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RoleBindingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *RoleBindingMutation) SetRoleID(id string) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *RoleBindingMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *RoleBindingMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *RoleBindingMutation) RoleID() (id string, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *RoleBindingMutation) RoleIDs() (ids []string) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *RoleBindingMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the RoleBindingMutation builder.
func (m *RoleBindingMutation) Where(ps ...predicate.RoleBinding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleBindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleBindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RoleBinding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleBindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleBindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RoleBinding).
func (m *RoleBindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleBindingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, rolebinding.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rolebinding.FieldUpdatedAt)
	}
	if m.scope_type != nil {
		fields = append(fields, rolebinding.FieldScopeType)
	}
	if m.scope_id != nil {
		fields = append(fields, rolebinding.FieldScopeID)
	}
	if m.allowed_environments != nil {
		fields = append(fields, rolebinding.FieldAllowedEnvironments)
	}
	if m.created_by != nil {
		fields = append(fields, rolebinding.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleBindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolebinding.FieldCreatedAt:
		return m.CreatedAt()
	case rolebinding.FieldUpdatedAt:
		return m.UpdatedAt()
	case rolebinding.FieldScopeType:
		return m.ScopeType()
	case rolebinding.FieldScopeID:
		return m.ScopeID()
	case rolebinding.FieldAllowedEnvironments:
		return m.AllowedEnvironments()
	case rolebinding.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleBindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolebinding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rolebinding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rolebinding.FieldScopeType:
		return m.OldScopeType(ctx)
	case rolebinding.FieldScopeID:
		return m.OldScopeID(ctx)
	case rolebinding.FieldAllowedEnvironments:
		return m.OldAllowedEnvironments(ctx)
	case rolebinding.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown RoleBinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleBindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolebinding.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rolebinding.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rolebinding.FieldScopeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeType(v)
		return nil
	case rolebinding.FieldScopeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeID(v)
		return nil
	case rolebinding.FieldAllowedEnvironments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedEnvironments(v)
		return nil
	case rolebinding.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RoleBinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleBindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleBindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleBindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleBinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleBindingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rolebinding.FieldScopeType) {
		fields = append(fields, rolebinding.FieldScopeType)
	}
	if m.FieldCleared(rolebinding.FieldScopeID) {
		fields = append(fields, rolebinding.FieldScopeID)
	}
	if m.FieldCleared(rolebinding.FieldAllowedEnvironments) {
		fields = append(fields, rolebinding.FieldAllowedEnvironments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleBindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleBindingMutation) ClearField(name string) error {
	switch name {
	case rolebinding.FieldScopeType:
		m.ClearScopeType()
		return nil
	case rolebinding.FieldScopeID:
		m.ClearScopeID()
		return nil
	case rolebinding.FieldAllowedEnvironments:
		m.ClearAllowedEnvironments()
		return nil
	}
	return fmt.Errorf("unknown RoleBinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleBindingMutation) ResetField(name string) error {
	switch name {
	case rolebinding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rolebinding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rolebinding.FieldScopeType:
		m.ResetScopeType()
		return nil
	case rolebinding.FieldScopeID:
		m.ResetScopeID()
		return nil
	case rolebinding.FieldAllowedEnvironments:
		m.ResetAllowedEnvironments()
		return nil
	case rolebinding.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown RoleBinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleBindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, rolebinding.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, rolebinding.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleBindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolebinding.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rolebinding.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleBindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleBindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleBindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, rolebinding.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, rolebinding.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleBindingMutation) EdgeCleared(name string) bool {
	switch name {
	case rolebinding.EdgeUser:
		return m.cleareduser
	case rolebinding.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleBindingMutation) ClearEdge(name string) error {
	switch name {
	case rolebinding.EdgeUser:
		m.ClearUser()
		return nil
	case rolebinding.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown RoleBinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleBindingMutation) ResetEdge(name string) error {
	switch name {
	case rolebinding.EdgeUser:
		m.ResetUser()
		return nil
	case rolebinding.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown RoleBinding edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	name                   *string
	description            *string
	next_instance_index    *int
	addnext_instance_index *int
	clearedFields          map[string]struct{}
	system                 *string
	clearedsystem          bool
	vms                    map[string]struct{}
	removedvms             map[string]struct{}
	clearedvms             bool
	done                   bool
	oldValue               func(context.Context) (*Service, error)
	predicates             []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id string) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ServiceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[service.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[service.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, service.FieldDescription)
}

// SetNextInstanceIndex sets the "next_instance_index" field.
func (m *ServiceMutation) SetNextInstanceIndex(i int) {
	m.next_instance_index = &i
	m.addnext_instance_index = nil
}

// NextInstanceIndex returns the value of the "next_instance_index" field in the mutation.
func (m *ServiceMutation) NextInstanceIndex() (r int, exists bool) {
	v := m.next_instance_index
	if v == nil {
		return
	}
	return *v, true
}

// OldNextInstanceIndex returns the old "next_instance_index" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldNextInstanceIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextInstanceIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextInstanceIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextInstanceIndex: %w", err)
	}
	return oldValue.NextInstanceIndex, nil
}

// AddNextInstanceIndex adds i to the "next_instance_index" field.
func (m *ServiceMutation) AddNextInstanceIndex(i int) {
	if m.addnext_instance_index != nil {
		*m.addnext_instance_index += i
	} else {
		m.addnext_instance_index = &i
	}
}

// AddedNextInstanceIndex returns the value that was added to the "next_instance_index" field in this mutation.
func (m *ServiceMutation) AddedNextInstanceIndex() (r int, exists bool) {
	v := m.addnext_instance_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetNextInstanceIndex resets all changes to the "next_instance_index" field.
func (m *ServiceMutation) ResetNextInstanceIndex() {
	m.next_instance_index = nil
	m.addnext_instance_index = nil
}

// SetSystemID sets the "system" edge to the System entity by id.
func (m *ServiceMutation) SetSystemID(id string) {
	m.system = &id
}

// ClearSystem clears the "system" edge to the System entity.
func (m *ServiceMutation) ClearSystem() {
	m.clearedsystem = true
}

// SystemCleared reports if the "system" edge to the System entity was cleared.
func (m *ServiceMutation) SystemCleared() bool {
	return m.clearedsystem
}

// SystemID returns the "system" edge ID in the mutation.
func (m *ServiceMutation) SystemID() (id string, exists bool) {
	if m.system != nil {
		return *m.system, true
	}
	return
}

// SystemIDs returns the "system" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) SystemIDs() (ids []string) {
	if id := m.system; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystem resets all changes to the "system" edge.
func (m *ServiceMutation) ResetSystem() {
	m.system = nil
	m.clearedsystem = false
}

// AddVMIDs adds the "vms" edge to the VM entity by ids.
func (m *ServiceMutation) AddVMIDs(ids ...string) {
	if m.vms == nil {
		m.vms = make(map[string]struct{})
	}
	for i := range ids {
		m.vms[ids[i]] = struct{}{}
	}
}

// ClearVms clears the "vms" edge to the VM entity.
func (m *ServiceMutation) ClearVms() {
	m.clearedvms = true
}

// VmsCleared reports if the "vms" edge to the VM entity was cleared.
func (m *ServiceMutation) VmsCleared() bool {
	return m.clearedvms
}

// RemoveVMIDs removes the "vms" edge to the VM entity by IDs.
func (m *ServiceMutation) RemoveVMIDs(ids ...string) {
	if m.removedvms == nil {
		m.removedvms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vms, ids[i])
		m.removedvms[ids[i]] = struct{}{}
	}
}

// RemovedVms returns the removed IDs of the "vms" edge to the VM entity.
func (m *ServiceMutation) RemovedVmsIDs() (ids []string) {
	for id := range m.removedvms {
		ids = append(ids, id)
	}
	return
}

// VmsIDs returns the "vms" edge IDs in the mutation.
func (m *ServiceMutation) VmsIDs() (ids []string) {
	for id := range m.vms {
		ids = append(ids, id)
	}
	return
}

// ResetVms resets all changes to the "vms" edge.
func (m *ServiceMutation) ResetVms() {
	m.vms = nil
	m.clearedvms = false
	m.removedvms = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, service.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, service.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.description != nil {
		fields = append(fields, service.FieldDescription)
	}
	if m.next_instance_index != nil {
		fields = append(fields, service.FieldNextInstanceIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldCreatedAt:
		return m.CreatedAt()
	case service.FieldUpdatedAt:
		return m.UpdatedAt()
	case service.FieldName:
		return m.Name()
	case service.FieldDescription:
		return m.Description()
	case service.FieldNextInstanceIndex:
		return m.NextInstanceIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case service.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDescription:
		return m.OldDescription(ctx)
	case service.FieldNextInstanceIndex:
		return m.OldNextInstanceIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case service.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case service.FieldNextInstanceIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextInstanceIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	var fields []string
	if m.addnext_instance_index != nil {
		fields = append(fields, service.FieldNextInstanceIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case service.FieldNextInstanceIndex:
		return m.AddedNextInstanceIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case service.FieldNextInstanceIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNextInstanceIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldDescription) {
		fields = append(fields, service.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case service.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDescription:
		m.ResetDescription()
		return nil
	case service.FieldNextInstanceIndex:
		m.ResetNextInstanceIndex()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.system != nil {
		edges = append(edges, service.EdgeSystem)
	}
	if m.vms != nil {
		edges = append(edges, service.EdgeVms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeSystem:
		if id := m.system; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeVms:
		ids := make([]ent.Value, 0, len(m.vms))
		for id := range m.vms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvms != nil {
		edges = append(edges, service.EdgeVms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeVms:
		ids := make([]ent.Value, 0, len(m.removedvms))
		for id := range m.removedvms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsystem {
		edges = append(edges, service.EdgeSystem)
	}
	if m.clearedvms {
		edges = append(edges, service.EdgeVms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeSystem:
		return m.clearedsystem
	case service.EdgeVms:
		return m.clearedvms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeSystem:
		m.ClearSystem()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeSystem:
		m.ResetSystem()
		return nil
	case service.EdgeVms:
		m.ResetVms()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	description     *string
	created_by      *string
	tenant_id       *string
	clearedFields   map[string]struct{}
	services        map[string]struct{}
	removedservices map[string]struct{}
	clearedservices bool
	done            bool
	oldValue        func(context.Context) (*System, error)
	predicates      []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id string) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of System entities.
func (m *SystemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().System.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *SystemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SystemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SystemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[system.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SystemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[system.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, system.FieldDescription)
}

// SetCreatedBy sets the "created_by" field.
func (m *SystemMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SystemMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SystemMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemMutation) ResetTenantID() {
	m.tenant_id = nil
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *SystemMutation) AddServiceIDs(ids ...string) {
	if m.services == nil {
		m.services = make(map[string]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *SystemMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *SystemMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *SystemMutation) RemoveServiceIDs(ids ...string) {
	if m.removedservices == nil {
		m.removedservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *SystemMutation) RemovedServicesIDs() (ids []string) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *SystemMutation) ServicesIDs() (ids []string) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *SystemMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.System, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, system.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, system.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, system.FieldName)
	}
	if m.description != nil {
		fields = append(fields, system.FieldDescription)
	}
	if m.created_by != nil {
		fields = append(fields, system.FieldCreatedBy)
	}
	if m.tenant_id != nil {
		fields = append(fields, system.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreatedAt:
		return m.CreatedAt()
	case system.FieldUpdatedAt:
		return m.UpdatedAt()
	case system.FieldName:
		return m.Name()
	case system.FieldDescription:
		return m.Description()
	case system.FieldCreatedBy:
		return m.CreatedBy()
	case system.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case system.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case system.FieldName:
		return m.OldName(ctx)
	case system.FieldDescription:
		return m.OldDescription(ctx)
	case system.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case system.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case system.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case system.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case system.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case system.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case system.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(system.FieldDescription) {
		fields = append(fields, system.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	switch name {
	case system.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case system.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case system.FieldName:
		m.ResetName()
		return nil
	case system.FieldDescription:
		m.ResetDescription()
		return nil
	case system.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case system.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.services != nil {
		edges = append(edges, system.EdgeServices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case system.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservices != nil {
		edges = append(edges, system.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case system.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservices {
		edges = append(edges, system.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	switch name {
	case system.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	switch name {
	case system.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown System edge %s", name)
}

// SystemSecretMutation represents an operation that mutates the SystemSecret nodes in the graph.
type SystemSecretMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	key_name      *string
	key_value     *string
	source        *systemsecret.Source
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemSecret, error)
	predicates    []predicate.SystemSecret
}

var _ ent.Mutation = (*SystemSecretMutation)(nil)

// systemsecretOption allows management of the mutation configuration using functional options.
type systemsecretOption func(*SystemSecretMutation)

// newSystemSecretMutation creates new mutation for the SystemSecret entity.
func newSystemSecretMutation(c config, op Op, opts ...systemsecretOption) *SystemSecretMutation {
	m := &SystemSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemSecretID sets the ID field of the mutation.
func withSystemSecretID(id string) systemsecretOption {
	return func(m *SystemSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemSecret
		)
		m.oldValue = func(ctx context.Context) (*SystemSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemSecret sets the old SystemSecret of the mutation.
func withSystemSecret(node *SystemSecret) systemsecretOption {
	return func(m *SystemSecretMutation) {
		m.oldValue = func(context.Context) (*SystemSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemSecret entities.
func (m *SystemSecretMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemSecretMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemSecretMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemSecretMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemSecretMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemSecret entity.
// If the SystemSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemSecretMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemSecretMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemSecretMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemSecretMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemSecret entity.
// If the SystemSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemSecretMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKeyName sets the "key_name" field.
func (m *SystemSecretMutation) SetKeyName(s string) {
	m.key_name = &s
}

// KeyName returns the value of the "key_name" field in the mutation.
func (m *SystemSecretMutation) KeyName() (r string, exists bool) {
	v := m.key_name
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyName returns the old "key_name" field's value of the SystemSecret entity.
// If the SystemSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemSecretMutation) OldKeyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyName: %w", err)
	}
	return oldValue.KeyName, nil
}

// ResetKeyName resets all changes to the "key_name" field.
func (m *SystemSecretMutation) ResetKeyName() {
	m.key_name = nil
}

// SetKeyValue sets the "key_value" field.
func (m *SystemSecretMutation) SetKeyValue(s string) {
	m.key_value = &s
}

// KeyValue returns the value of the "key_value" field in the mutation.
func (m *SystemSecretMutation) KeyValue() (r string, exists bool) {
	v := m.key_value
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyValue returns the old "key_value" field's value of the SystemSecret entity.
// If the SystemSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemSecretMutation) OldKeyValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyValue: %w", err)
	}
	return oldValue.KeyValue, nil
}

// ResetKeyValue resets all changes to the "key_value" field.
func (m *SystemSecretMutation) ResetKeyValue() {
	m.key_value = nil
}

// SetSource sets the "source" field.
func (m *SystemSecretMutation) SetSource(s systemsecret.Source) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *SystemSecretMutation) Source() (r systemsecret.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the SystemSecret entity.
// If the SystemSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemSecretMutation) OldSource(ctx context.Context) (v systemsecret.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *SystemSecretMutation) ResetSource() {
	m.source = nil
}

// Where appends a list predicates to the SystemSecretMutation builder.
func (m *SystemSecretMutation) Where(ps ...predicate.SystemSecret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemSecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemSecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemSecret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemSecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemSecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemSecret).
func (m *SystemSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemSecretMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, systemsecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, systemsecret.FieldUpdatedAt)
	}
	if m.key_name != nil {
		fields = append(fields, systemsecret.FieldKeyName)
	}
	if m.key_value != nil {
		fields = append(fields, systemsecret.FieldKeyValue)
	}
	if m.source != nil {
		fields = append(fields, systemsecret.FieldSource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemsecret.FieldCreatedAt:
		return m.CreatedAt()
	case systemsecret.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemsecret.FieldKeyName:
		return m.KeyName()
	case systemsecret.FieldKeyValue:
		return m.KeyValue()
	case systemsecret.FieldSource:
		return m.Source()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemsecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemsecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemsecret.FieldKeyName:
		return m.OldKeyName(ctx)
	case systemsecret.FieldKeyValue:
		return m.OldKeyValue(ctx)
	case systemsecret.FieldSource:
		return m.OldSource(ctx)
	}
	return nil, fmt.Errorf("unknown SystemSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemsecret.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemsecret.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemsecret.FieldKeyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyName(v)
		return nil
	case systemsecret.FieldKeyValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyValue(v)
		return nil
	case systemsecret.FieldSource:
		v, ok := value.(systemsecret.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	}
	return fmt.Errorf("unknown SystemSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemSecretMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemSecretMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemSecretMutation) ResetField(name string) error {
	switch name {
	case systemsecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemsecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemsecret.FieldKeyName:
		m.ResetKeyName()
		return nil
	case systemsecret.FieldKeyValue:
		m.ResetKeyValue()
		return nil
	case systemsecret.FieldSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown SystemSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemSecret edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	display_name  *string
	description   *string
	version       *int
	addversion    *int
	spec          *map[string]interface{}
	os_family     *string
	os_version    *string
	enabled       *bool
	created_by    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Template, error)
	predicates    []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *TemplateMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TemplateMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *TemplateMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[template.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *TemplateMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[template.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TemplateMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, template.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *TemplateMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TemplateMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TemplateMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TemplateMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TemplateMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetSpec sets the "spec" field.
func (m *TemplateMutation) SetSpec(value map[string]interface{}) {
	m.spec = &value
}

// Spec returns the value of the "spec" field in the mutation.
func (m *TemplateMutation) Spec() (r map[string]interface{}, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldSpec(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ClearSpec clears the value of the "spec" field.
func (m *TemplateMutation) ClearSpec() {
	m.spec = nil
	m.clearedFields[template.FieldSpec] = struct{}{}
}

// SpecCleared returns if the "spec" field was cleared in this mutation.
func (m *TemplateMutation) SpecCleared() bool {
	_, ok := m.clearedFields[template.FieldSpec]
	return ok
}

// ResetSpec resets all changes to the "spec" field.
func (m *TemplateMutation) ResetSpec() {
	m.spec = nil
	delete(m.clearedFields, template.FieldSpec)
}

// SetOsFamily sets the "os_family" field.
func (m *TemplateMutation) SetOsFamily(s string) {
	m.os_family = &s
}

// OsFamily returns the value of the "os_family" field in the mutation.
func (m *TemplateMutation) OsFamily() (r string, exists bool) {
	v := m.os_family
	if v == nil {
		return
	}
	return *v, true
}

// OldOsFamily returns the old "os_family" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldOsFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsFamily: %w", err)
	}
	return oldValue.OsFamily, nil
}

// ClearOsFamily clears the value of the "os_family" field.
func (m *TemplateMutation) ClearOsFamily() {
	m.os_family = nil
	m.clearedFields[template.FieldOsFamily] = struct{}{}
}

// OsFamilyCleared returns if the "os_family" field was cleared in this mutation.
func (m *TemplateMutation) OsFamilyCleared() bool {
	_, ok := m.clearedFields[template.FieldOsFamily]
	return ok
}

// ResetOsFamily resets all changes to the "os_family" field.
func (m *TemplateMutation) ResetOsFamily() {
	m.os_family = nil
	delete(m.clearedFields, template.FieldOsFamily)
}

// SetOsVersion sets the "os_version" field.
func (m *TemplateMutation) SetOsVersion(s string) {
	m.os_version = &s
}

// OsVersion returns the value of the "os_version" field in the mutation.
func (m *TemplateMutation) OsVersion() (r string, exists bool) {
	v := m.os_version
	if v == nil {
		return
	}
	return *v, true
}

// OldOsVersion returns the old "os_version" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldOsVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsVersion: %w", err)
	}
	return oldValue.OsVersion, nil
}

// ClearOsVersion clears the value of the "os_version" field.
func (m *TemplateMutation) ClearOsVersion() {
	m.os_version = nil
	m.clearedFields[template.FieldOsVersion] = struct{}{}
}

// OsVersionCleared returns if the "os_version" field was cleared in this mutation.
func (m *TemplateMutation) OsVersionCleared() bool {
	_, ok := m.clearedFields[template.FieldOsVersion]
	return ok
}

// ResetOsVersion resets all changes to the "os_version" field.
func (m *TemplateMutation) ResetOsVersion() {
	m.os_version = nil
	delete(m.clearedFields, template.FieldOsVersion)
}

// SetEnabled sets the "enabled" field.
func (m *TemplateMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *TemplateMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *TemplateMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TemplateMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemplateMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemplateMutation) ResetCreatedBy() {
	m.created_by = nil
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, template.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, template.FieldVersion)
	}
	if m.spec != nil {
		fields = append(fields, template.FieldSpec)
	}
	if m.os_family != nil {
		fields = append(fields, template.FieldOsFamily)
	}
	if m.os_version != nil {
		fields = append(fields, template.FieldOsVersion)
	}
	if m.enabled != nil {
		fields = append(fields, template.FieldEnabled)
	}
	if m.created_by != nil {
		fields = append(fields, template.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldCreatedAt:
		return m.CreatedAt()
	case template.FieldUpdatedAt:
		return m.UpdatedAt()
	case template.FieldName:
		return m.Name()
	case template.FieldDisplayName:
		return m.DisplayName()
	case template.FieldDescription:
		return m.Description()
	case template.FieldVersion:
		return m.Version()
	case template.FieldSpec:
		return m.Spec()
	case template.FieldOsFamily:
		return m.OsFamily()
	case template.FieldOsVersion:
		return m.OsVersion()
	case template.FieldEnabled:
		return m.Enabled()
	case template.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case template.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldVersion:
		return m.OldVersion(ctx)
	case template.FieldSpec:
		return m.OldSpec(ctx)
	case template.FieldOsFamily:
		return m.OldOsFamily(ctx)
	case template.FieldOsVersion:
		return m.OldOsVersion(ctx)
	case template.FieldEnabled:
		return m.OldEnabled(ctx)
	case template.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case template.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case template.FieldSpec:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case template.FieldOsFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsFamily(v)
		return nil
	case template.FieldOsVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsVersion(v)
		return nil
	case template.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case template.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, template.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case template.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case template.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDisplayName) {
		fields = append(fields, template.FieldDisplayName)
	}
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldSpec) {
		fields = append(fields, template.FieldSpec)
	}
	if m.FieldCleared(template.FieldOsFamily) {
		fields = append(fields, template.FieldOsFamily)
	}
	if m.FieldCleared(template.FieldOsVersion) {
		fields = append(fields, template.FieldOsVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldSpec:
		m.ClearSpec()
		return nil
	case template.FieldOsFamily:
		m.ClearOsFamily()
		return nil
	case template.FieldOsVersion:
		m.ClearOsVersion()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldVersion:
		m.ResetVersion()
		return nil
	case template.FieldSpec:
		m.ResetSpec()
		return nil
	case template.FieldOsFamily:
		m.ResetOsFamily()
		return nil
	case template.FieldOsVersion:
		m.ResetOsVersion()
		return nil
	case template.FieldEnabled:
		m.ResetEnabled()
		return nil
	case template.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Template edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	username              *string
	email                 *string
	display_name          *string
	password_hash         *string
	force_password_change *bool
	auth_provider_id      *string
	external_id           *string
	enabled               *bool
	last_login_at         *time.Time
	clearedFields         map[string]struct{}
	role_bindings         map[string]struct{}
	removedrole_bindings  map[string]struct{}
	clearedrole_bindings  bool
	notifications         map[string]struct{}
	removednotifications  map[string]struct{}
	clearednotifications  bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetForcePasswordChange sets the "force_password_change" field.
func (m *UserMutation) SetForcePasswordChange(b bool) {
	m.force_password_change = &b
}

// ForcePasswordChange returns the value of the "force_password_change" field in the mutation.
func (m *UserMutation) ForcePasswordChange() (r bool, exists bool) {
	v := m.force_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldForcePasswordChange returns the old "force_password_change" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldForcePasswordChange(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForcePasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForcePasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForcePasswordChange: %w", err)
	}
	return oldValue.ForcePasswordChange, nil
}

// ResetForcePasswordChange resets all changes to the "force_password_change" field.
func (m *UserMutation) ResetForcePasswordChange() {
	m.force_password_change = nil
}

// SetAuthProviderID sets the "auth_provider_id" field.
func (m *UserMutation) SetAuthProviderID(s string) {
	m.auth_provider_id = &s
}

// AuthProviderID returns the value of the "auth_provider_id" field in the mutation.
func (m *UserMutation) AuthProviderID() (r string, exists bool) {
	v := m.auth_provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProviderID returns the old "auth_provider_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProviderID: %w", err)
	}
	return oldValue.AuthProviderID, nil
}

// ClearAuthProviderID clears the value of the "auth_provider_id" field.
func (m *UserMutation) ClearAuthProviderID() {
	m.auth_provider_id = nil
	m.clearedFields[user.FieldAuthProviderID] = struct{}{}
}

// AuthProviderIDCleared returns if the "auth_provider_id" field was cleared in this mutation.
func (m *UserMutation) AuthProviderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAuthProviderID]
	return ok
}

// ResetAuthProviderID resets all changes to the "auth_provider_id" field.
func (m *UserMutation) ResetAuthProviderID() {
	m.auth_provider_id = nil
	delete(m.clearedFields, user.FieldAuthProviderID)
}

// SetExternalID sets the "external_id" field.
func (m *UserMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *UserMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *UserMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[user.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *UserMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *UserMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, user.FieldExternalID)
}

// SetEnabled sets the "enabled" field.
func (m *UserMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *UserMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *UserMutation) ResetEnabled() {
	m.enabled = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// AddRoleBindingIDs adds the "role_bindings" edge to the RoleBinding entity by ids.
func (m *UserMutation) AddRoleBindingIDs(ids ...string) {
	if m.role_bindings == nil {
		m.role_bindings = make(map[string]struct{})
	}
	for i := range ids {
		m.role_bindings[ids[i]] = struct{}{}
	}
}

// ClearRoleBindings clears the "role_bindings" edge to the RoleBinding entity.
func (m *UserMutation) ClearRoleBindings() {
	m.clearedrole_bindings = true
}

// RoleBindingsCleared reports if the "role_bindings" edge to the RoleBinding entity was cleared.
func (m *UserMutation) RoleBindingsCleared() bool {
	return m.clearedrole_bindings
}

// RemoveRoleBindingIDs removes the "role_bindings" edge to the RoleBinding entity by IDs.
func (m *UserMutation) RemoveRoleBindingIDs(ids ...string) {
	if m.removedrole_bindings == nil {
		m.removedrole_bindings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.role_bindings, ids[i])
		m.removedrole_bindings[ids[i]] = struct{}{}
	}
}

// RemovedRoleBindings returns the removed IDs of the "role_bindings" edge to the RoleBinding entity.
func (m *UserMutation) RemovedRoleBindingsIDs() (ids []string) {
	for id := range m.removedrole_bindings {
		ids = append(ids, id)
	}
	return
}

// RoleBindingsIDs returns the "role_bindings" edge IDs in the mutation.
func (m *UserMutation) RoleBindingsIDs() (ids []string) {
	for id := range m.role_bindings {
		ids = append(ids, id)
	}
	return
}

// ResetRoleBindings resets all changes to the "role_bindings" edge.
func (m *UserMutation) ResetRoleBindings() {
	m.role_bindings = nil
	m.clearedrole_bindings = false
	m.removedrole_bindings = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *UserMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *UserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *UserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *UserMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *UserMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *UserMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *UserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.force_password_change != nil {
		fields = append(fields, user.FieldForcePasswordChange)
	}
	if m.auth_provider_id != nil {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.external_id != nil {
		fields = append(fields, user.FieldExternalID)
	}
	if m.enabled != nil {
		fields = append(fields, user.FieldEnabled)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldForcePasswordChange:
		return m.ForcePasswordChange()
	case user.FieldAuthProviderID:
		return m.AuthProviderID()
	case user.FieldExternalID:
		return m.ExternalID()
	case user.FieldEnabled:
		return m.Enabled()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldForcePasswordChange:
		return m.OldForcePasswordChange(ctx)
	case user.FieldAuthProviderID:
		return m.OldAuthProviderID(ctx)
	case user.FieldExternalID:
		return m.OldExternalID(ctx)
	case user.FieldEnabled:
		return m.OldEnabled(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldForcePasswordChange:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForcePasswordChange(v)
		return nil
	case user.FieldAuthProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProviderID(v)
		return nil
	case user.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case user.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldAuthProviderID) {
		fields = append(fields, user.FieldAuthProviderID)
	}
	if m.FieldCleared(user.FieldExternalID) {
		fields = append(fields, user.FieldExternalID)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldAuthProviderID:
		m.ClearAuthProviderID()
		return nil
	case user.FieldExternalID:
		m.ClearExternalID()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldForcePasswordChange:
		m.ResetForcePasswordChange()
		return nil
	case user.FieldAuthProviderID:
		m.ResetAuthProviderID()
		return nil
	case user.FieldExternalID:
		m.ResetExternalID()
		return nil
	case user.FieldEnabled:
		m.ResetEnabled()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role_bindings != nil {
		edges = append(edges, user.EdgeRoleBindings)
	}
	if m.notifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoleBindings:
		ids := make([]ent.Value, 0, len(m.role_bindings))
		for id := range m.role_bindings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrole_bindings != nil {
		edges = append(edges, user.EdgeRoleBindings)
	}
	if m.removednotifications != nil {
		edges = append(edges, user.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoleBindings:
		ids := make([]ent.Value, 0, len(m.removedrole_bindings))
		for id := range m.removedrole_bindings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole_bindings {
		edges = append(edges, user.EdgeRoleBindings)
	}
	if m.clearednotifications {
		edges = append(edges, user.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoleBindings:
		return m.clearedrole_bindings
	case user.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoleBindings:
		m.ResetRoleBindings()
		return nil
	case user.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VMMutation represents an operation that mutates the VM nodes in the graph.
type VMMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	instance         *string
	namespace        *string
	cluster_id       *string
	status           *vm.Status
	hostname         *string
	created_by       *string
	ticket_id        *string
	clearedFields    map[string]struct{}
	service          *string
	clearedservice   bool
	revisions        map[string]struct{}
	removedrevisions map[string]struct{}
	clearedrevisions bool
	done             bool
	oldValue         func(context.Context) (*VM, error)
	predicates       []predicate.VM
}

var _ ent.Mutation = (*VMMutation)(nil)

// vmOption allows management of the mutation configuration using functional options.
type vmOption func(*VMMutation)

// newVMMutation creates new mutation for the VM entity.
func newVMMutation(c config, op Op, opts ...vmOption) *VMMutation {
	m := &VMMutation{
		config:        c,
		op:            op,
		typ:           TypeVM,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVMID sets the ID field of the mutation.
func withVMID(id string) vmOption {
	return func(m *VMMutation) {
		var (
			err   error
			once  sync.Once
			value *VM
		)
		m.oldValue = func(ctx context.Context) (*VM, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VM.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVM sets the old VM of the mutation.
func withVM(node *VM) vmOption {
	return func(m *VMMutation) {
		m.oldValue = func(context.Context) (*VM, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VMMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VMMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VM entities.
func (m *VMMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VMMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VMMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VM.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VMMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VMMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VMMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VMMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VMMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VMMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VMMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VMMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VMMutation) ResetName() {
	m.name = nil
}

// SetInstance sets the "instance" field.
func (m *VMMutation) SetInstance(s string) {
	m.instance = &s
}

// Instance returns the value of the "instance" field in the mutation.
func (m *VMMutation) Instance() (r string, exists bool) {
	v := m.instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstance returns the old "instance" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldInstance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstance: %w", err)
	}
	return oldValue.Instance, nil
}

// ResetInstance resets all changes to the "instance" field.
func (m *VMMutation) ResetInstance() {
	m.instance = nil
}

// SetNamespace sets the "namespace" field.
func (m *VMMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *VMMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *VMMutation) ResetNamespace() {
	m.namespace = nil
}

// SetClusterID sets the "cluster_id" field.
func (m *VMMutation) SetClusterID(s string) {
	m.cluster_id = &s
}

// ClusterID returns the value of the "cluster_id" field in the mutation.
func (m *VMMutation) ClusterID() (r string, exists bool) {
	v := m.cluster_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterID returns the old "cluster_id" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldClusterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterID: %w", err)
	}
	return oldValue.ClusterID, nil
}

// ClearClusterID clears the value of the "cluster_id" field.
func (m *VMMutation) ClearClusterID() {
	m.cluster_id = nil
	m.clearedFields[vm.FieldClusterID] = struct{}{}
}

// ClusterIDCleared returns if the "cluster_id" field was cleared in this mutation.
func (m *VMMutation) ClusterIDCleared() bool {
	_, ok := m.clearedFields[vm.FieldClusterID]
	return ok
}

// ResetClusterID resets all changes to the "cluster_id" field.
func (m *VMMutation) ResetClusterID() {
	m.cluster_id = nil
	delete(m.clearedFields, vm.FieldClusterID)
}

// SetStatus sets the "status" field.
func (m *VMMutation) SetStatus(v vm.Status) {
	m.status = &v
}

// Status returns the value of the "status" field in the mutation.
func (m *VMMutation) Status() (r vm.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldStatus(ctx context.Context) (v vm.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VMMutation) ResetStatus() {
	m.status = nil
}

// SetHostname sets the "hostname" field.
func (m *VMMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *VMMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *VMMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[vm.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *VMMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[vm.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *VMMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, vm.FieldHostname)
}

// SetCreatedBy sets the "created_by" field.
func (m *VMMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VMMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VMMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetTicketID sets the "ticket_id" field.
func (m *VMMutation) SetTicketID(s string) {
	m.ticket_id = &s
}

// TicketID returns the value of the "ticket_id" field in the mutation.
func (m *VMMutation) TicketID() (r string, exists bool) {
	v := m.ticket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketID returns the old "ticket_id" field's value of the VM entity.
// If the VM object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMMutation) OldTicketID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketID: %w", err)
	}
	return oldValue.TicketID, nil
}

// ClearTicketID clears the value of the "ticket_id" field.
func (m *VMMutation) ClearTicketID() {
	m.ticket_id = nil
	m.clearedFields[vm.FieldTicketID] = struct{}{}
}

// TicketIDCleared returns if the "ticket_id" field was cleared in this mutation.
func (m *VMMutation) TicketIDCleared() bool {
	_, ok := m.clearedFields[vm.FieldTicketID]
	return ok
}

// ResetTicketID resets all changes to the "ticket_id" field.
func (m *VMMutation) ResetTicketID() {
	m.ticket_id = nil
	delete(m.clearedFields, vm.FieldTicketID)
}

// SetServiceID sets the "service" edge to the Service entity by id.
func (m *VMMutation) SetServiceID(id string) {
	m.service = &id
}

// ClearService clears the "service" edge to the Service entity.
func (m *VMMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *VMMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceID returns the "service" edge ID in the mutation.
func (m *VMMutation) ServiceID() (id string, exists bool) {
	if m.service != nil {
		return *m.service, true
	}
	return
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *VMMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *VMMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// AddRevisionIDs adds the "revisions" edge to the VMRevision entity by ids.
func (m *VMMutation) AddRevisionIDs(ids ...string) {
	if m.revisions == nil {
		m.revisions = make(map[string]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the VMRevision entity.
func (m *VMMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the VMRevision entity was cleared.
func (m *VMMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the VMRevision entity by IDs.
func (m *VMMutation) RemoveRevisionIDs(ids ...string) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the VMRevision entity.
func (m *VMMutation) RemovedRevisionsIDs() (ids []string) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *VMMutation) RevisionsIDs() (ids []string) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *VMMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// Where appends a list predicates to the VMMutation builder.
func (m *VMMutation) Where(ps ...predicate.VM) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VMMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VMMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VM, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VMMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VMMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VM).
func (m *VMMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VMMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, vm.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vm.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, vm.FieldName)
	}
	if m.instance != nil {
		fields = append(fields, vm.FieldInstance)
	}
	if m.namespace != nil {
		fields = append(fields, vm.FieldNamespace)
	}
	if m.cluster_id != nil {
		fields = append(fields, vm.FieldClusterID)
	}
	if m.status != nil {
		fields = append(fields, vm.FieldStatus)
	}
	if m.hostname != nil {
		fields = append(fields, vm.FieldHostname)
	}
	if m.created_by != nil {
		fields = append(fields, vm.FieldCreatedBy)
	}
	if m.ticket_id != nil {
		fields = append(fields, vm.FieldTicketID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VMMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vm.FieldCreatedAt:
		return m.CreatedAt()
	case vm.FieldUpdatedAt:
		return m.UpdatedAt()
	case vm.FieldName:
		return m.Name()
	case vm.FieldInstance:
		return m.Instance()
	case vm.FieldNamespace:
		return m.Namespace()
	case vm.FieldClusterID:
		return m.ClusterID()
	case vm.FieldStatus:
		return m.Status()
	case vm.FieldHostname:
		return m.Hostname()
	case vm.FieldCreatedBy:
		return m.CreatedBy()
	case vm.FieldTicketID:
		return m.TicketID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VMMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vm.FieldName:
		return m.OldName(ctx)
	case vm.FieldInstance:
		return m.OldInstance(ctx)
	case vm.FieldNamespace:
		return m.OldNamespace(ctx)
	case vm.FieldClusterID:
		return m.OldClusterID(ctx)
	case vm.FieldStatus:
		return m.OldStatus(ctx)
	case vm.FieldHostname:
		return m.OldHostname(ctx)
	case vm.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case vm.FieldTicketID:
		return m.OldTicketID(ctx)
	}
	return nil, fmt.Errorf("unknown VM field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VMMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vm.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vm.FieldInstance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstance(v)
		return nil
	case vm.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case vm.FieldClusterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterID(v)
		return nil
	case vm.FieldStatus:
		v, ok := value.(vm.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vm.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case vm.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case vm.FieldTicketID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketID(v)
		return nil
	}
	return fmt.Errorf("unknown VM field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VMMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VMMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VMMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VM numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VMMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vm.FieldClusterID) {
		fields = append(fields, vm.FieldClusterID)
	}
	if m.FieldCleared(vm.FieldHostname) {
		fields = append(fields, vm.FieldHostname)
	}
	if m.FieldCleared(vm.FieldTicketID) {
		fields = append(fields, vm.FieldTicketID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VMMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VMMutation) ClearField(name string) error {
	switch name {
	case vm.FieldClusterID:
		m.ClearClusterID()
		return nil
	case vm.FieldHostname:
		m.ClearHostname()
		return nil
	case vm.FieldTicketID:
		m.ClearTicketID()
		return nil
	}
	return fmt.Errorf("unknown VM nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VMMutation) ResetField(name string) error {
	switch name {
	case vm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vm.FieldName:
		m.ResetName()
		return nil
	case vm.FieldInstance:
		m.ResetInstance()
		return nil
	case vm.FieldNamespace:
		m.ResetNamespace()
		return nil
	case vm.FieldClusterID:
		m.ResetClusterID()
		return nil
	case vm.FieldStatus:
		m.ResetStatus()
		return nil
	case vm.FieldHostname:
		m.ResetHostname()
		return nil
	case vm.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case vm.FieldTicketID:
		m.ResetTicketID()
		return nil
	}
	return fmt.Errorf("unknown VM field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VMMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.service != nil {
		edges = append(edges, vm.EdgeService)
	}
	if m.revisions != nil {
		edges = append(edges, vm.EdgeRevisions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VMMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vm.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case vm.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VMMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrevisions != nil {
		edges = append(edges, vm.EdgeRevisions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VMMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vm.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VMMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedservice {
		edges = append(edges, vm.EdgeService)
	}
	if m.clearedrevisions {
		edges = append(edges, vm.EdgeRevisions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VMMutation) EdgeCleared(name string) bool {
	switch name {
	case vm.EdgeService:
		return m.clearedservice
	case vm.EdgeRevisions:
		return m.clearedrevisions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VMMutation) ClearEdge(name string) error {
	switch name {
	case vm.EdgeService:
		m.ClearService()
		return nil
	}
	return fmt.Errorf("unknown VM unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VMMutation) ResetEdge(name string) error {
	switch name {
	case vm.EdgeService:
		m.ResetService()
		return nil
	case vm.EdgeRevisions:
		m.ResetRevisions()
		return nil
	}
	return fmt.Errorf("unknown VM edge %s", name)
}

// VMRevisionMutation represents an operation that mutates the VMRevision nodes in the graph.
type VMRevisionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	revision      *int
	addrevision   *int
	spec          *map[string]interface{}
	change_reason *string
	changed_by    *string
	clearedFields map[string]struct{}
	vm            *string
	clearedvm     bool
	done          bool
	oldValue      func(context.Context) (*VMRevision, error)
	predicates    []predicate.VMRevision
}

var _ ent.Mutation = (*VMRevisionMutation)(nil)

// vmrevisionOption allows management of the mutation configuration using functional options.
type vmrevisionOption func(*VMRevisionMutation)

// newVMRevisionMutation creates new mutation for the VMRevision entity.
func newVMRevisionMutation(c config, op Op, opts ...vmrevisionOption) *VMRevisionMutation {
	m := &VMRevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeVMRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVMRevisionID sets the ID field of the mutation.
func withVMRevisionID(id string) vmrevisionOption {
	return func(m *VMRevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *VMRevision
		)
		m.oldValue = func(ctx context.Context) (*VMRevision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VMRevision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVMRevision sets the old VMRevision of the mutation.
func withVMRevision(node *VMRevision) vmrevisionOption {
	return func(m *VMRevisionMutation) {
		m.oldValue = func(context.Context) (*VMRevision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VMRevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VMRevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VMRevision entities.
func (m *VMRevisionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VMRevisionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VMRevisionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VMRevision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VMRevisionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VMRevisionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VMRevision entity.
// If the VMRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMRevisionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VMRevisionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRevision sets the "revision" field.
func (m *VMRevisionMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *VMRevisionMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the VMRevision entity.
// If the VMRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMRevisionMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *VMRevisionMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *VMRevisionMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *VMRevisionMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetSpec sets the "spec" field.
func (m *VMRevisionMutation) SetSpec(value map[string]interface{}) {
	m.spec = &value
}

// Spec returns the value of the "spec" field in the mutation.
func (m *VMRevisionMutation) Spec() (r map[string]interface{}, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the VMRevision entity.
// If the VMRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMRevisionMutation) OldSpec(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ClearSpec clears the value of the "spec" field.
func (m *VMRevisionMutation) ClearSpec() {
	m.spec = nil
	m.clearedFields[vmrevision.FieldSpec] = struct{}{}
}

// SpecCleared returns if the "spec" field was cleared in this mutation.
func (m *VMRevisionMutation) SpecCleared() bool {
	_, ok := m.clearedFields[vmrevision.FieldSpec]
	return ok
}

// ResetSpec resets all changes to the "spec" field.
func (m *VMRevisionMutation) ResetSpec() {
	m.spec = nil
	delete(m.clearedFields, vmrevision.FieldSpec)
}

// SetChangeReason sets the "change_reason" field.
func (m *VMRevisionMutation) SetChangeReason(s string) {
	m.change_reason = &s
}

// ChangeReason returns the value of the "change_reason" field in the mutation.
func (m *VMRevisionMutation) ChangeReason() (r string, exists bool) {
	v := m.change_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeReason returns the old "change_reason" field's value of the VMRevision entity.
// If the VMRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMRevisionMutation) OldChangeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeReason: %w", err)
	}
	return oldValue.ChangeReason, nil
}

// ClearChangeReason clears the value of the "change_reason" field.
func (m *VMRevisionMutation) ClearChangeReason() {
	m.change_reason = nil
	m.clearedFields[vmrevision.FieldChangeReason] = struct{}{}
}

// ChangeReasonCleared returns if the "change_reason" field was cleared in this mutation.
func (m *VMRevisionMutation) ChangeReasonCleared() bool {
	_, ok := m.clearedFields[vmrevision.FieldChangeReason]
	return ok
}

// ResetChangeReason resets all changes to the "change_reason" field.
func (m *VMRevisionMutation) ResetChangeReason() {
	m.change_reason = nil
	delete(m.clearedFields, vmrevision.FieldChangeReason)
}

// SetChangedBy sets the "changed_by" field.
func (m *VMRevisionMutation) SetChangedBy(s string) {
	m.changed_by = &s
}

// ChangedBy returns the value of the "changed_by" field in the mutation.
func (m *VMRevisionMutation) ChangedBy() (r string, exists bool) {
	v := m.changed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldChangedBy returns the old "changed_by" field's value of the VMRevision entity.
// If the VMRevision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VMRevisionMutation) OldChangedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangedBy: %w", err)
	}
	return oldValue.ChangedBy, nil
}

// ResetChangedBy resets all changes to the "changed_by" field.
func (m *VMRevisionMutation) ResetChangedBy() {
	m.changed_by = nil
}

// SetVMID sets the "vm" edge to the VM entity by id.
func (m *VMRevisionMutation) SetVMID(id string) {
	m.vm = &id
}

// ClearVM clears the "vm" edge to the VM entity.
func (m *VMRevisionMutation) ClearVM() {
	m.clearedvm = true
}

// VMCleared reports if the "vm" edge to the VM entity was cleared.
func (m *VMRevisionMutation) VMCleared() bool {
	return m.clearedvm
}

// VMID returns the "vm" edge ID in the mutation.
func (m *VMRevisionMutation) VMID() (id string, exists bool) {
	if m.vm != nil {
		return *m.vm, true
	}
	return
}

// VMIDs returns the "vm" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VMID instead. It exists only for internal usage by the builders.
func (m *VMRevisionMutation) VMIDs() (ids []string) {
	if id := m.vm; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVM resets all changes to the "vm" edge.
func (m *VMRevisionMutation) ResetVM() {
	m.vm = nil
	m.clearedvm = false
}

// Where appends a list predicates to the VMRevisionMutation builder.
func (m *VMRevisionMutation) Where(ps ...predicate.VMRevision) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VMRevisionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VMRevisionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VMRevision, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VMRevisionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VMRevisionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VMRevision).
func (m *VMRevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VMRevisionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, vmrevision.FieldCreatedAt)
	}
	if m.revision != nil {
		fields = append(fields, vmrevision.FieldRevision)
	}
	if m.spec != nil {
		fields = append(fields, vmrevision.FieldSpec)
	}
	if m.change_reason != nil {
		fields = append(fields, vmrevision.FieldChangeReason)
	}
	if m.changed_by != nil {
		fields = append(fields, vmrevision.FieldChangedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VMRevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vmrevision.FieldCreatedAt:
		return m.CreatedAt()
	case vmrevision.FieldRevision:
		return m.Revision()
	case vmrevision.FieldSpec:
		return m.Spec()
	case vmrevision.FieldChangeReason:
		return m.ChangeReason()
	case vmrevision.FieldChangedBy:
		return m.ChangedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VMRevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vmrevision.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vmrevision.FieldRevision:
		return m.OldRevision(ctx)
	case vmrevision.FieldSpec:
		return m.OldSpec(ctx)
	case vmrevision.FieldChangeReason:
		return m.OldChangeReason(ctx)
	case vmrevision.FieldChangedBy:
		return m.OldChangedBy(ctx)
	}
	return nil, fmt.Errorf("unknown VMRevision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VMRevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vmrevision.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vmrevision.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case vmrevision.FieldSpec:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case vmrevision.FieldChangeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeReason(v)
		return nil
	case vmrevision.FieldChangedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangedBy(v)
		return nil
	}
	return fmt.Errorf("unknown VMRevision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VMRevisionMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, vmrevision.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VMRevisionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vmrevision.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VMRevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vmrevision.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown VMRevision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VMRevisionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vmrevision.FieldSpec) {
		fields = append(fields, vmrevision.FieldSpec)
	}
	if m.FieldCleared(vmrevision.FieldChangeReason) {
		fields = append(fields, vmrevision.FieldChangeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VMRevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VMRevisionMutation) ClearField(name string) error {
	switch name {
	case vmrevision.FieldSpec:
		m.ClearSpec()
		return nil
	case vmrevision.FieldChangeReason:
		m.ClearChangeReason()
		return nil
	}
	return fmt.Errorf("unknown VMRevision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VMRevisionMutation) ResetField(name string) error {
	switch name {
	case vmrevision.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vmrevision.FieldRevision:
		m.ResetRevision()
		return nil
	case vmrevision.FieldSpec:
		m.ResetSpec()
		return nil
	case vmrevision.FieldChangeReason:
		m.ResetChangeReason()
		return nil
	case vmrevision.FieldChangedBy:
		m.ResetChangedBy()
		return nil
	}
	return fmt.Errorf("unknown VMRevision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VMRevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vm != nil {
		edges = append(edges, vmrevision.EdgeVM)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VMRevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vmrevision.EdgeVM:
		if id := m.vm; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VMRevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VMRevisionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VMRevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvm {
		edges = append(edges, vmrevision.EdgeVM)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VMRevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case vmrevision.EdgeVM:
		return m.clearedvm
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VMRevisionMutation) ClearEdge(name string) error {
	switch name {
	case vmrevision.EdgeVM:
		m.ClearVM()
		return nil
	}
	return fmt.Errorf("unknown VMRevision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VMRevisionMutation) ResetEdge(name string) error {
	switch name {
	case vmrevision.EdgeVM:
		m.ResetVM()
		return nil
	}
	return fmt.Errorf("unknown VMRevision edge %s", name)
}
