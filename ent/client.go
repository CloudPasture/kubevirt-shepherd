// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"kv-shepherd.io/shepherd/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"kv-shepherd.io/shepherd/ent/approvalpolicy"
	"kv-shepherd.io/shepherd/ent/approvalticket"
	"kv-shepherd.io/shepherd/ent/auditlog"
	"kv-shepherd.io/shepherd/ent/authprovider"
	"kv-shepherd.io/shepherd/ent/cluster"
	"kv-shepherd.io/shepherd/ent/domainevent"
	"kv-shepherd.io/shepherd/ent/externalapprovalsystem"
	"kv-shepherd.io/shepherd/ent/idpgroupmapping"
	"kv-shepherd.io/shepherd/ent/idpsyncedgroup"
	"kv-shepherd.io/shepherd/ent/instancesize"
	"kv-shepherd.io/shepherd/ent/namespaceregistry"
	"kv-shepherd.io/shepherd/ent/notification"
	"kv-shepherd.io/shepherd/ent/pendingadoption"
	"kv-shepherd.io/shepherd/ent/resourcerolebinding"
	"kv-shepherd.io/shepherd/ent/role"
	"kv-shepherd.io/shepherd/ent/rolebinding"
	"kv-shepherd.io/shepherd/ent/service"
	"kv-shepherd.io/shepherd/ent/system"
	"kv-shepherd.io/shepherd/ent/systemsecret"
	"kv-shepherd.io/shepherd/ent/template"
	"kv-shepherd.io/shepherd/ent/user"
	"kv-shepherd.io/shepherd/ent/vm"
	"kv-shepherd.io/shepherd/ent/vmrevision"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ApprovalPolicy is the client for interacting with the ApprovalPolicy builders.
	ApprovalPolicy *ApprovalPolicyClient
	// ApprovalTicket is the client for interacting with the ApprovalTicket builders.
	ApprovalTicket *ApprovalTicketClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// AuthProvider is the client for interacting with the AuthProvider builders.
	AuthProvider *AuthProviderClient
	// Cluster is the client for interacting with the Cluster builders.
	Cluster *ClusterClient
	// DomainEvent is the client for interacting with the DomainEvent builders.
	DomainEvent *DomainEventClient
	// ExternalApprovalSystem is the client for interacting with the ExternalApprovalSystem builders.
	ExternalApprovalSystem *ExternalApprovalSystemClient
	// IdPGroupMapping is the client for interacting with the IdPGroupMapping builders.
	IdPGroupMapping *IdPGroupMappingClient
	// IdPSyncedGroup is the client for interacting with the IdPSyncedGroup builders.
	IdPSyncedGroup *IdPSyncedGroupClient
	// InstanceSize is the client for interacting with the InstanceSize builders.
	InstanceSize *InstanceSizeClient
	// NamespaceRegistry is the client for interacting with the NamespaceRegistry builders.
	NamespaceRegistry *NamespaceRegistryClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// PendingAdoption is the client for interacting with the PendingAdoption builders.
	PendingAdoption *PendingAdoptionClient
	// ResourceRoleBinding is the client for interacting with the ResourceRoleBinding builders.
	ResourceRoleBinding *ResourceRoleBindingClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// RoleBinding is the client for interacting with the RoleBinding builders.
	RoleBinding *RoleBindingClient
	// Service is the client for interacting with the Service builders.
	Service *ServiceClient
	// System is the client for interacting with the System builders.
	System *SystemClient
	// SystemSecret is the client for interacting with the SystemSecret builders.
	SystemSecret *SystemSecretClient
	// Template is the client for interacting with the Template builders.
	Template *TemplateClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VM is the client for interacting with the VM builders.
	VM *VMClient
	// VMRevision is the client for interacting with the VMRevision builders.
	VMRevision *VMRevisionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ApprovalPolicy = NewApprovalPolicyClient(c.config)
	c.ApprovalTicket = NewApprovalTicketClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.AuthProvider = NewAuthProviderClient(c.config)
	c.Cluster = NewClusterClient(c.config)
	c.DomainEvent = NewDomainEventClient(c.config)
	c.ExternalApprovalSystem = NewExternalApprovalSystemClient(c.config)
	c.IdPGroupMapping = NewIdPGroupMappingClient(c.config)
	c.IdPSyncedGroup = NewIdPSyncedGroupClient(c.config)
	c.InstanceSize = NewInstanceSizeClient(c.config)
	c.NamespaceRegistry = NewNamespaceRegistryClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.PendingAdoption = NewPendingAdoptionClient(c.config)
	c.ResourceRoleBinding = NewResourceRoleBindingClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.RoleBinding = NewRoleBindingClient(c.config)
	c.Service = NewServiceClient(c.config)
	c.System = NewSystemClient(c.config)
	c.SystemSecret = NewSystemSecretClient(c.config)
	c.Template = NewTemplateClient(c.config)
	c.User = NewUserClient(c.config)
	c.VM = NewVMClient(c.config)
	c.VMRevision = NewVMRevisionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		ApprovalPolicy:         NewApprovalPolicyClient(cfg),
		ApprovalTicket:         NewApprovalTicketClient(cfg),
		AuditLog:               NewAuditLogClient(cfg),
		AuthProvider:           NewAuthProviderClient(cfg),
		Cluster:                NewClusterClient(cfg),
		DomainEvent:            NewDomainEventClient(cfg),
		ExternalApprovalSystem: NewExternalApprovalSystemClient(cfg),
		IdPGroupMapping:        NewIdPGroupMappingClient(cfg),
		IdPSyncedGroup:         NewIdPSyncedGroupClient(cfg),
		InstanceSize:           NewInstanceSizeClient(cfg),
		NamespaceRegistry:      NewNamespaceRegistryClient(cfg),
		Notification:           NewNotificationClient(cfg),
		PendingAdoption:        NewPendingAdoptionClient(cfg),
		ResourceRoleBinding:    NewResourceRoleBindingClient(cfg),
		Role:                   NewRoleClient(cfg),
		RoleBinding:            NewRoleBindingClient(cfg),
		Service:                NewServiceClient(cfg),
		System:                 NewSystemClient(cfg),
		SystemSecret:           NewSystemSecretClient(cfg),
		Template:               NewTemplateClient(cfg),
		User:                   NewUserClient(cfg),
		VM:                     NewVMClient(cfg),
		VMRevision:             NewVMRevisionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		ApprovalPolicy:         NewApprovalPolicyClient(cfg),
		ApprovalTicket:         NewApprovalTicketClient(cfg),
		AuditLog:               NewAuditLogClient(cfg),
		AuthProvider:           NewAuthProviderClient(cfg),
		Cluster:                NewClusterClient(cfg),
		DomainEvent:            NewDomainEventClient(cfg),
		ExternalApprovalSystem: NewExternalApprovalSystemClient(cfg),
		IdPGroupMapping:        NewIdPGroupMappingClient(cfg),
		IdPSyncedGroup:         NewIdPSyncedGroupClient(cfg),
		InstanceSize:           NewInstanceSizeClient(cfg),
		NamespaceRegistry:      NewNamespaceRegistryClient(cfg),
		Notification:           NewNotificationClient(cfg),
		PendingAdoption:        NewPendingAdoptionClient(cfg),
		ResourceRoleBinding:    NewResourceRoleBindingClient(cfg),
		Role:                   NewRoleClient(cfg),
		RoleBinding:            NewRoleBindingClient(cfg),
		Service:                NewServiceClient(cfg),
		System:                 NewSystemClient(cfg),
		SystemSecret:           NewSystemSecretClient(cfg),
		Template:               NewTemplateClient(cfg),
		User:                   NewUserClient(cfg),
		VM:                     NewVMClient(cfg),
		VMRevision:             NewVMRevisionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ApprovalPolicy.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ApprovalPolicy, c.ApprovalTicket, c.AuditLog, c.AuthProvider, c.Cluster,
		c.DomainEvent, c.ExternalApprovalSystem, c.IdPGroupMapping, c.IdPSyncedGroup,
		c.InstanceSize, c.NamespaceRegistry, c.Notification, c.PendingAdoption,
		c.ResourceRoleBinding, c.Role, c.RoleBinding, c.Service, c.System,
		c.SystemSecret, c.Template, c.User, c.VM, c.VMRevision,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ApprovalPolicy, c.ApprovalTicket, c.AuditLog, c.AuthProvider, c.Cluster,
		c.DomainEvent, c.ExternalApprovalSystem, c.IdPGroupMapping, c.IdPSyncedGroup,
		c.InstanceSize, c.NamespaceRegistry, c.Notification, c.PendingAdoption,
		c.ResourceRoleBinding, c.Role, c.RoleBinding, c.Service, c.System,
		c.SystemSecret, c.Template, c.User, c.VM, c.VMRevision,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ApprovalPolicyMutation:
		return c.ApprovalPolicy.mutate(ctx, m)
	case *ApprovalTicketMutation:
		return c.ApprovalTicket.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *AuthProviderMutation:
		return c.AuthProvider.mutate(ctx, m)
	case *ClusterMutation:
		return c.Cluster.mutate(ctx, m)
	case *DomainEventMutation:
		return c.DomainEvent.mutate(ctx, m)
	case *ExternalApprovalSystemMutation:
		return c.ExternalApprovalSystem.mutate(ctx, m)
	case *IdPGroupMappingMutation:
		return c.IdPGroupMapping.mutate(ctx, m)
	case *IdPSyncedGroupMutation:
		return c.IdPSyncedGroup.mutate(ctx, m)
	case *InstanceSizeMutation:
		return c.InstanceSize.mutate(ctx, m)
	case *NamespaceRegistryMutation:
		return c.NamespaceRegistry.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *PendingAdoptionMutation:
		return c.PendingAdoption.mutate(ctx, m)
	case *ResourceRoleBindingMutation:
		return c.ResourceRoleBinding.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *RoleBindingMutation:
		return c.RoleBinding.mutate(ctx, m)
	case *ServiceMutation:
		return c.Service.mutate(ctx, m)
	case *SystemMutation:
		return c.System.mutate(ctx, m)
	case *SystemSecretMutation:
		return c.SystemSecret.mutate(ctx, m)
	case *TemplateMutation:
		return c.Template.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VMMutation:
		return c.VM.mutate(ctx, m)
	case *VMRevisionMutation:
		return c.VMRevision.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ApprovalPolicyClient is a client for the ApprovalPolicy schema.
type ApprovalPolicyClient struct {
	config
}

// NewApprovalPolicyClient returns a client for the ApprovalPolicy from the given config.
func NewApprovalPolicyClient(c config) *ApprovalPolicyClient {
	return &ApprovalPolicyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `approvalpolicy.Hooks(f(g(h())))`.
func (c *ApprovalPolicyClient) Use(hooks ...Hook) {
	c.hooks.ApprovalPolicy = append(c.hooks.ApprovalPolicy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `approvalpolicy.Intercept(f(g(h())))`.
func (c *ApprovalPolicyClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApprovalPolicy = append(c.inters.ApprovalPolicy, interceptors...)
}

// Create returns a builder for creating a ApprovalPolicy entity.
func (c *ApprovalPolicyClient) Create() *ApprovalPolicyCreate {
	mutation := newApprovalPolicyMutation(c.config, OpCreate)
	return &ApprovalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApprovalPolicy entities.
func (c *ApprovalPolicyClient) CreateBulk(builders ...*ApprovalPolicyCreate) *ApprovalPolicyCreateBulk {
	return &ApprovalPolicyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApprovalPolicyClient) MapCreateBulk(slice any, setFunc func(*ApprovalPolicyCreate, int)) *ApprovalPolicyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApprovalPolicyCreateBulk{err: fmt.Errorf("calling to ApprovalPolicyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApprovalPolicyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApprovalPolicyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApprovalPolicy.
func (c *ApprovalPolicyClient) Update() *ApprovalPolicyUpdate {
	mutation := newApprovalPolicyMutation(c.config, OpUpdate)
	return &ApprovalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApprovalPolicyClient) UpdateOne(_m *ApprovalPolicy) *ApprovalPolicyUpdateOne {
	mutation := newApprovalPolicyMutation(c.config, OpUpdateOne, withApprovalPolicy(_m))
	return &ApprovalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApprovalPolicyClient) UpdateOneID(id string) *ApprovalPolicyUpdateOne {
	mutation := newApprovalPolicyMutation(c.config, OpUpdateOne, withApprovalPolicyID(id))
	return &ApprovalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApprovalPolicy.
func (c *ApprovalPolicyClient) Delete() *ApprovalPolicyDelete {
	mutation := newApprovalPolicyMutation(c.config, OpDelete)
	return &ApprovalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApprovalPolicyClient) DeleteOne(_m *ApprovalPolicy) *ApprovalPolicyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApprovalPolicyClient) DeleteOneID(id string) *ApprovalPolicyDeleteOne {
	builder := c.Delete().Where(approvalpolicy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApprovalPolicyDeleteOne{builder}
}

// Query returns a query builder for ApprovalPolicy.
func (c *ApprovalPolicyClient) Query() *ApprovalPolicyQuery {
	return &ApprovalPolicyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApprovalPolicy},
		inters: c.Interceptors(),
	}
}

// Get returns a ApprovalPolicy entity by its id.
func (c *ApprovalPolicyClient) Get(ctx context.Context, id string) (*ApprovalPolicy, error) {
	return c.Query().Where(approvalpolicy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApprovalPolicyClient) GetX(ctx context.Context, id string) *ApprovalPolicy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApprovalPolicyClient) Hooks() []Hook {
	return c.hooks.ApprovalPolicy
}

// Interceptors returns the client interceptors.
func (c *ApprovalPolicyClient) Interceptors() []Interceptor {
	return c.inters.ApprovalPolicy
}

func (c *ApprovalPolicyClient) mutate(ctx context.Context, m *ApprovalPolicyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApprovalPolicyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApprovalPolicyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApprovalPolicyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApprovalPolicyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApprovalPolicy mutation op: %q", m.Op())
	}
}

// ApprovalTicketClient is a client for the ApprovalTicket schema.
type ApprovalTicketClient struct {
	config
}

// NewApprovalTicketClient returns a client for the ApprovalTicket from the given config.
func NewApprovalTicketClient(c config) *ApprovalTicketClient {
	return &ApprovalTicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `approvalticket.Hooks(f(g(h())))`.
func (c *ApprovalTicketClient) Use(hooks ...Hook) {
	c.hooks.ApprovalTicket = append(c.hooks.ApprovalTicket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `approvalticket.Intercept(f(g(h())))`.
func (c *ApprovalTicketClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApprovalTicket = append(c.inters.ApprovalTicket, interceptors...)
}

// Create returns a builder for creating a ApprovalTicket entity.
func (c *ApprovalTicketClient) Create() *ApprovalTicketCreate {
	mutation := newApprovalTicketMutation(c.config, OpCreate)
	return &ApprovalTicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApprovalTicket entities.
func (c *ApprovalTicketClient) CreateBulk(builders ...*ApprovalTicketCreate) *ApprovalTicketCreateBulk {
	return &ApprovalTicketCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApprovalTicketClient) MapCreateBulk(slice any, setFunc func(*ApprovalTicketCreate, int)) *ApprovalTicketCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApprovalTicketCreateBulk{err: fmt.Errorf("calling to ApprovalTicketClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApprovalTicketCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApprovalTicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApprovalTicket.
func (c *ApprovalTicketClient) Update() *ApprovalTicketUpdate {
	mutation := newApprovalTicketMutation(c.config, OpUpdate)
	return &ApprovalTicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApprovalTicketClient) UpdateOne(_m *ApprovalTicket) *ApprovalTicketUpdateOne {
	mutation := newApprovalTicketMutation(c.config, OpUpdateOne, withApprovalTicket(_m))
	return &ApprovalTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApprovalTicketClient) UpdateOneID(id string) *ApprovalTicketUpdateOne {
	mutation := newApprovalTicketMutation(c.config, OpUpdateOne, withApprovalTicketID(id))
	return &ApprovalTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApprovalTicket.
func (c *ApprovalTicketClient) Delete() *ApprovalTicketDelete {
	mutation := newApprovalTicketMutation(c.config, OpDelete)
	return &ApprovalTicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApprovalTicketClient) DeleteOne(_m *ApprovalTicket) *ApprovalTicketDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApprovalTicketClient) DeleteOneID(id string) *ApprovalTicketDeleteOne {
	builder := c.Delete().Where(approvalticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApprovalTicketDeleteOne{builder}
}

// Query returns a query builder for ApprovalTicket.
func (c *ApprovalTicketClient) Query() *ApprovalTicketQuery {
	return &ApprovalTicketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApprovalTicket},
		inters: c.Interceptors(),
	}
}

// Get returns a ApprovalTicket entity by its id.
func (c *ApprovalTicketClient) Get(ctx context.Context, id string) (*ApprovalTicket, error) {
	return c.Query().Where(approvalticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApprovalTicketClient) GetX(ctx context.Context, id string) *ApprovalTicket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApprovalTicketClient) Hooks() []Hook {
	return c.hooks.ApprovalTicket
}

// Interceptors returns the client interceptors.
func (c *ApprovalTicketClient) Interceptors() []Interceptor {
	return c.inters.ApprovalTicket
}

func (c *ApprovalTicketClient) mutate(ctx context.Context, m *ApprovalTicketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApprovalTicketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApprovalTicketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApprovalTicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApprovalTicketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApprovalTicket mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id string) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id string) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id string) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id string) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// AuthProviderClient is a client for the AuthProvider schema.
type AuthProviderClient struct {
	config
}

// NewAuthProviderClient returns a client for the AuthProvider from the given config.
func NewAuthProviderClient(c config) *AuthProviderClient {
	return &AuthProviderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authprovider.Hooks(f(g(h())))`.
func (c *AuthProviderClient) Use(hooks ...Hook) {
	c.hooks.AuthProvider = append(c.hooks.AuthProvider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authprovider.Intercept(f(g(h())))`.
func (c *AuthProviderClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthProvider = append(c.inters.AuthProvider, interceptors...)
}

// Create returns a builder for creating a AuthProvider entity.
func (c *AuthProviderClient) Create() *AuthProviderCreate {
	mutation := newAuthProviderMutation(c.config, OpCreate)
	return &AuthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthProvider entities.
func (c *AuthProviderClient) CreateBulk(builders ...*AuthProviderCreate) *AuthProviderCreateBulk {
	return &AuthProviderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthProviderClient) MapCreateBulk(slice any, setFunc func(*AuthProviderCreate, int)) *AuthProviderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthProviderCreateBulk{err: fmt.Errorf("calling to AuthProviderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthProviderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthProviderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthProvider.
func (c *AuthProviderClient) Update() *AuthProviderUpdate {
	mutation := newAuthProviderMutation(c.config, OpUpdate)
	return &AuthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthProviderClient) UpdateOne(_m *AuthProvider) *AuthProviderUpdateOne {
	mutation := newAuthProviderMutation(c.config, OpUpdateOne, withAuthProvider(_m))
	return &AuthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthProviderClient) UpdateOneID(id string) *AuthProviderUpdateOne {
	mutation := newAuthProviderMutation(c.config, OpUpdateOne, withAuthProviderID(id))
	return &AuthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthProvider.
func (c *AuthProviderClient) Delete() *AuthProviderDelete {
	mutation := newAuthProviderMutation(c.config, OpDelete)
	return &AuthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthProviderClient) DeleteOne(_m *AuthProvider) *AuthProviderDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthProviderClient) DeleteOneID(id string) *AuthProviderDeleteOne {
	builder := c.Delete().Where(authprovider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthProviderDeleteOne{builder}
}

// Query returns a query builder for AuthProvider.
func (c *AuthProviderClient) Query() *AuthProviderQuery {
	return &AuthProviderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthProvider},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthProvider entity by its id.
func (c *AuthProviderClient) Get(ctx context.Context, id string) (*AuthProvider, error) {
	return c.Query().Where(authprovider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthProviderClient) GetX(ctx context.Context, id string) *AuthProvider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthProviderClient) Hooks() []Hook {
	return c.hooks.AuthProvider
}

// Interceptors returns the client interceptors.
func (c *AuthProviderClient) Interceptors() []Interceptor {
	return c.inters.AuthProvider
}

func (c *AuthProviderClient) mutate(ctx context.Context, m *AuthProviderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthProviderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthProviderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthProviderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthProviderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthProvider mutation op: %q", m.Op())
	}
}

// ClusterClient is a client for the Cluster schema.
type ClusterClient struct {
	config
}

// NewClusterClient returns a client for the Cluster from the given config.
func NewClusterClient(c config) *ClusterClient {
	return &ClusterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cluster.Hooks(f(g(h())))`.
func (c *ClusterClient) Use(hooks ...Hook) {
	c.hooks.Cluster = append(c.hooks.Cluster, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cluster.Intercept(f(g(h())))`.
func (c *ClusterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Cluster = append(c.inters.Cluster, interceptors...)
}

// Create returns a builder for creating a Cluster entity.
func (c *ClusterClient) Create() *ClusterCreate {
	mutation := newClusterMutation(c.config, OpCreate)
	return &ClusterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Cluster entities.
func (c *ClusterClient) CreateBulk(builders ...*ClusterCreate) *ClusterCreateBulk {
	return &ClusterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClusterClient) MapCreateBulk(slice any, setFunc func(*ClusterCreate, int)) *ClusterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClusterCreateBulk{err: fmt.Errorf("calling to ClusterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClusterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClusterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Cluster.
func (c *ClusterClient) Update() *ClusterUpdate {
	mutation := newClusterMutation(c.config, OpUpdate)
	return &ClusterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClusterClient) UpdateOne(_m *Cluster) *ClusterUpdateOne {
	mutation := newClusterMutation(c.config, OpUpdateOne, withCluster(_m))
	return &ClusterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClusterClient) UpdateOneID(id string) *ClusterUpdateOne {
	mutation := newClusterMutation(c.config, OpUpdateOne, withClusterID(id))
	return &ClusterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Cluster.
func (c *ClusterClient) Delete() *ClusterDelete {
	mutation := newClusterMutation(c.config, OpDelete)
	return &ClusterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClusterClient) DeleteOne(_m *Cluster) *ClusterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClusterClient) DeleteOneID(id string) *ClusterDeleteOne {
	builder := c.Delete().Where(cluster.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClusterDeleteOne{builder}
}

// Query returns a query builder for Cluster.
func (c *ClusterClient) Query() *ClusterQuery {
	return &ClusterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCluster},
		inters: c.Interceptors(),
	}
}

// Get returns a Cluster entity by its id.
func (c *ClusterClient) Get(ctx context.Context, id string) (*Cluster, error) {
	return c.Query().Where(cluster.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClusterClient) GetX(ctx context.Context, id string) *Cluster {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ClusterClient) Hooks() []Hook {
	return c.hooks.Cluster
}

// Interceptors returns the client interceptors.
func (c *ClusterClient) Interceptors() []Interceptor {
	return c.inters.Cluster
}

func (c *ClusterClient) mutate(ctx context.Context, m *ClusterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClusterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClusterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClusterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClusterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Cluster mutation op: %q", m.Op())
	}
}

// DomainEventClient is a client for the DomainEvent schema.
type DomainEventClient struct {
	config
}

// NewDomainEventClient returns a client for the DomainEvent from the given config.
func NewDomainEventClient(c config) *DomainEventClient {
	return &DomainEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `domainevent.Hooks(f(g(h())))`.
func (c *DomainEventClient) Use(hooks ...Hook) {
	c.hooks.DomainEvent = append(c.hooks.DomainEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `domainevent.Intercept(f(g(h())))`.
func (c *DomainEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.DomainEvent = append(c.inters.DomainEvent, interceptors...)
}

// Create returns a builder for creating a DomainEvent entity.
func (c *DomainEventClient) Create() *DomainEventCreate {
	mutation := newDomainEventMutation(c.config, OpCreate)
	return &DomainEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DomainEvent entities.
func (c *DomainEventClient) CreateBulk(builders ...*DomainEventCreate) *DomainEventCreateBulk {
	return &DomainEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DomainEventClient) MapCreateBulk(slice any, setFunc func(*DomainEventCreate, int)) *DomainEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DomainEventCreateBulk{err: fmt.Errorf("calling to DomainEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DomainEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DomainEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DomainEvent.
func (c *DomainEventClient) Update() *DomainEventUpdate {
	mutation := newDomainEventMutation(c.config, OpUpdate)
	return &DomainEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DomainEventClient) UpdateOne(_m *DomainEvent) *DomainEventUpdateOne {
	mutation := newDomainEventMutation(c.config, OpUpdateOne, withDomainEvent(_m))
	return &DomainEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DomainEventClient) UpdateOneID(id string) *DomainEventUpdateOne {
	mutation := newDomainEventMutation(c.config, OpUpdateOne, withDomainEventID(id))
	return &DomainEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DomainEvent.
func (c *DomainEventClient) Delete() *DomainEventDelete {
	mutation := newDomainEventMutation(c.config, OpDelete)
	return &DomainEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DomainEventClient) DeleteOne(_m *DomainEvent) *DomainEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DomainEventClient) DeleteOneID(id string) *DomainEventDeleteOne {
	builder := c.Delete().Where(domainevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DomainEventDeleteOne{builder}
}

// Query returns a query builder for DomainEvent.
func (c *DomainEventClient) Query() *DomainEventQuery {
	return &DomainEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDomainEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a DomainEvent entity by its id.
func (c *DomainEventClient) Get(ctx context.Context, id string) (*DomainEvent, error) {
	return c.Query().Where(domainevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DomainEventClient) GetX(ctx context.Context, id string) *DomainEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DomainEventClient) Hooks() []Hook {
	return c.hooks.DomainEvent
}

// Interceptors returns the client interceptors.
func (c *DomainEventClient) Interceptors() []Interceptor {
	return c.inters.DomainEvent
}

func (c *DomainEventClient) mutate(ctx context.Context, m *DomainEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DomainEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DomainEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DomainEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DomainEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DomainEvent mutation op: %q", m.Op())
	}
}

// ExternalApprovalSystemClient is a client for the ExternalApprovalSystem schema.
type ExternalApprovalSystemClient struct {
	config
}

// NewExternalApprovalSystemClient returns a client for the ExternalApprovalSystem from the given config.
func NewExternalApprovalSystemClient(c config) *ExternalApprovalSystemClient {
	return &ExternalApprovalSystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `externalapprovalsystem.Hooks(f(g(h())))`.
func (c *ExternalApprovalSystemClient) Use(hooks ...Hook) {
	c.hooks.ExternalApprovalSystem = append(c.hooks.ExternalApprovalSystem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `externalapprovalsystem.Intercept(f(g(h())))`.
func (c *ExternalApprovalSystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExternalApprovalSystem = append(c.inters.ExternalApprovalSystem, interceptors...)
}

// Create returns a builder for creating a ExternalApprovalSystem entity.
func (c *ExternalApprovalSystemClient) Create() *ExternalApprovalSystemCreate {
	mutation := newExternalApprovalSystemMutation(c.config, OpCreate)
	return &ExternalApprovalSystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExternalApprovalSystem entities.
func (c *ExternalApprovalSystemClient) CreateBulk(builders ...*ExternalApprovalSystemCreate) *ExternalApprovalSystemCreateBulk {
	return &ExternalApprovalSystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExternalApprovalSystemClient) MapCreateBulk(slice any, setFunc func(*ExternalApprovalSystemCreate, int)) *ExternalApprovalSystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExternalApprovalSystemCreateBulk{err: fmt.Errorf("calling to ExternalApprovalSystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExternalApprovalSystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExternalApprovalSystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExternalApprovalSystem.
func (c *ExternalApprovalSystemClient) Update() *ExternalApprovalSystemUpdate {
	mutation := newExternalApprovalSystemMutation(c.config, OpUpdate)
	return &ExternalApprovalSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExternalApprovalSystemClient) UpdateOne(_m *ExternalApprovalSystem) *ExternalApprovalSystemUpdateOne {
	mutation := newExternalApprovalSystemMutation(c.config, OpUpdateOne, withExternalApprovalSystem(_m))
	return &ExternalApprovalSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExternalApprovalSystemClient) UpdateOneID(id string) *ExternalApprovalSystemUpdateOne {
	mutation := newExternalApprovalSystemMutation(c.config, OpUpdateOne, withExternalApprovalSystemID(id))
	return &ExternalApprovalSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExternalApprovalSystem.
func (c *ExternalApprovalSystemClient) Delete() *ExternalApprovalSystemDelete {
	mutation := newExternalApprovalSystemMutation(c.config, OpDelete)
	return &ExternalApprovalSystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExternalApprovalSystemClient) DeleteOne(_m *ExternalApprovalSystem) *ExternalApprovalSystemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExternalApprovalSystemClient) DeleteOneID(id string) *ExternalApprovalSystemDeleteOne {
	builder := c.Delete().Where(externalapprovalsystem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExternalApprovalSystemDeleteOne{builder}
}

// Query returns a query builder for ExternalApprovalSystem.
func (c *ExternalApprovalSystemClient) Query() *ExternalApprovalSystemQuery {
	return &ExternalApprovalSystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExternalApprovalSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a ExternalApprovalSystem entity by its id.
func (c *ExternalApprovalSystemClient) Get(ctx context.Context, id string) (*ExternalApprovalSystem, error) {
	return c.Query().Where(externalapprovalsystem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExternalApprovalSystemClient) GetX(ctx context.Context, id string) *ExternalApprovalSystem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExternalApprovalSystemClient) Hooks() []Hook {
	return c.hooks.ExternalApprovalSystem
}

// Interceptors returns the client interceptors.
func (c *ExternalApprovalSystemClient) Interceptors() []Interceptor {
	return c.inters.ExternalApprovalSystem
}

func (c *ExternalApprovalSystemClient) mutate(ctx context.Context, m *ExternalApprovalSystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExternalApprovalSystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExternalApprovalSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExternalApprovalSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExternalApprovalSystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExternalApprovalSystem mutation op: %q", m.Op())
	}
}

// IdPGroupMappingClient is a client for the IdPGroupMapping schema.
type IdPGroupMappingClient struct {
	config
}

// NewIdPGroupMappingClient returns a client for the IdPGroupMapping from the given config.
func NewIdPGroupMappingClient(c config) *IdPGroupMappingClient {
	return &IdPGroupMappingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `idpgroupmapping.Hooks(f(g(h())))`.
func (c *IdPGroupMappingClient) Use(hooks ...Hook) {
	c.hooks.IdPGroupMapping = append(c.hooks.IdPGroupMapping, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `idpgroupmapping.Intercept(f(g(h())))`.
func (c *IdPGroupMappingClient) Intercept(interceptors ...Interceptor) {
	c.inters.IdPGroupMapping = append(c.inters.IdPGroupMapping, interceptors...)
}

// Create returns a builder for creating a IdPGroupMapping entity.
func (c *IdPGroupMappingClient) Create() *IdPGroupMappingCreate {
	mutation := newIdPGroupMappingMutation(c.config, OpCreate)
	return &IdPGroupMappingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IdPGroupMapping entities.
func (c *IdPGroupMappingClient) CreateBulk(builders ...*IdPGroupMappingCreate) *IdPGroupMappingCreateBulk {
	return &IdPGroupMappingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdPGroupMappingClient) MapCreateBulk(slice any, setFunc func(*IdPGroupMappingCreate, int)) *IdPGroupMappingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdPGroupMappingCreateBulk{err: fmt.Errorf("calling to IdPGroupMappingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdPGroupMappingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdPGroupMappingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IdPGroupMapping.
func (c *IdPGroupMappingClient) Update() *IdPGroupMappingUpdate {
	mutation := newIdPGroupMappingMutation(c.config, OpUpdate)
	return &IdPGroupMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdPGroupMappingClient) UpdateOne(_m *IdPGroupMapping) *IdPGroupMappingUpdateOne {
	mutation := newIdPGroupMappingMutation(c.config, OpUpdateOne, withIdPGroupMapping(_m))
	return &IdPGroupMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdPGroupMappingClient) UpdateOneID(id string) *IdPGroupMappingUpdateOne {
	mutation := newIdPGroupMappingMutation(c.config, OpUpdateOne, withIdPGroupMappingID(id))
	return &IdPGroupMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IdPGroupMapping.
func (c *IdPGroupMappingClient) Delete() *IdPGroupMappingDelete {
	mutation := newIdPGroupMappingMutation(c.config, OpDelete)
	return &IdPGroupMappingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdPGroupMappingClient) DeleteOne(_m *IdPGroupMapping) *IdPGroupMappingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdPGroupMappingClient) DeleteOneID(id string) *IdPGroupMappingDeleteOne {
	builder := c.Delete().Where(idpgroupmapping.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdPGroupMappingDeleteOne{builder}
}

// Query returns a query builder for IdPGroupMapping.
func (c *IdPGroupMappingClient) Query() *IdPGroupMappingQuery {
	return &IdPGroupMappingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdPGroupMapping},
		inters: c.Interceptors(),
	}
}

// Get returns a IdPGroupMapping entity by its id.
func (c *IdPGroupMappingClient) Get(ctx context.Context, id string) (*IdPGroupMapping, error) {
	return c.Query().Where(idpgroupmapping.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdPGroupMappingClient) GetX(ctx context.Context, id string) *IdPGroupMapping {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IdPGroupMappingClient) Hooks() []Hook {
	return c.hooks.IdPGroupMapping
}

// Interceptors returns the client interceptors.
func (c *IdPGroupMappingClient) Interceptors() []Interceptor {
	return c.inters.IdPGroupMapping
}

func (c *IdPGroupMappingClient) mutate(ctx context.Context, m *IdPGroupMappingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdPGroupMappingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdPGroupMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdPGroupMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdPGroupMappingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IdPGroupMapping mutation op: %q", m.Op())
	}
}

// IdPSyncedGroupClient is a client for the IdPSyncedGroup schema.
type IdPSyncedGroupClient struct {
	config
}

// NewIdPSyncedGroupClient returns a client for the IdPSyncedGroup from the given config.
func NewIdPSyncedGroupClient(c config) *IdPSyncedGroupClient {
	return &IdPSyncedGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `idpsyncedgroup.Hooks(f(g(h())))`.
func (c *IdPSyncedGroupClient) Use(hooks ...Hook) {
	c.hooks.IdPSyncedGroup = append(c.hooks.IdPSyncedGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `idpsyncedgroup.Intercept(f(g(h())))`.
func (c *IdPSyncedGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.IdPSyncedGroup = append(c.inters.IdPSyncedGroup, interceptors...)
}

// Create returns a builder for creating a IdPSyncedGroup entity.
func (c *IdPSyncedGroupClient) Create() *IdPSyncedGroupCreate {
	mutation := newIdPSyncedGroupMutation(c.config, OpCreate)
	return &IdPSyncedGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IdPSyncedGroup entities.
func (c *IdPSyncedGroupClient) CreateBulk(builders ...*IdPSyncedGroupCreate) *IdPSyncedGroupCreateBulk {
	return &IdPSyncedGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdPSyncedGroupClient) MapCreateBulk(slice any, setFunc func(*IdPSyncedGroupCreate, int)) *IdPSyncedGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdPSyncedGroupCreateBulk{err: fmt.Errorf("calling to IdPSyncedGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdPSyncedGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdPSyncedGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IdPSyncedGroup.
func (c *IdPSyncedGroupClient) Update() *IdPSyncedGroupUpdate {
	mutation := newIdPSyncedGroupMutation(c.config, OpUpdate)
	return &IdPSyncedGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdPSyncedGroupClient) UpdateOne(_m *IdPSyncedGroup) *IdPSyncedGroupUpdateOne {
	mutation := newIdPSyncedGroupMutation(c.config, OpUpdateOne, withIdPSyncedGroup(_m))
	return &IdPSyncedGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdPSyncedGroupClient) UpdateOneID(id string) *IdPSyncedGroupUpdateOne {
	mutation := newIdPSyncedGroupMutation(c.config, OpUpdateOne, withIdPSyncedGroupID(id))
	return &IdPSyncedGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IdPSyncedGroup.
func (c *IdPSyncedGroupClient) Delete() *IdPSyncedGroupDelete {
	mutation := newIdPSyncedGroupMutation(c.config, OpDelete)
	return &IdPSyncedGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdPSyncedGroupClient) DeleteOne(_m *IdPSyncedGroup) *IdPSyncedGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdPSyncedGroupClient) DeleteOneID(id string) *IdPSyncedGroupDeleteOne {
	builder := c.Delete().Where(idpsyncedgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdPSyncedGroupDeleteOne{builder}
}

// Query returns a query builder for IdPSyncedGroup.
func (c *IdPSyncedGroupClient) Query() *IdPSyncedGroupQuery {
	return &IdPSyncedGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdPSyncedGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a IdPSyncedGroup entity by its id.
func (c *IdPSyncedGroupClient) Get(ctx context.Context, id string) (*IdPSyncedGroup, error) {
	return c.Query().Where(idpsyncedgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdPSyncedGroupClient) GetX(ctx context.Context, id string) *IdPSyncedGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IdPSyncedGroupClient) Hooks() []Hook {
	return c.hooks.IdPSyncedGroup
}

// Interceptors returns the client interceptors.
func (c *IdPSyncedGroupClient) Interceptors() []Interceptor {
	return c.inters.IdPSyncedGroup
}

func (c *IdPSyncedGroupClient) mutate(ctx context.Context, m *IdPSyncedGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdPSyncedGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdPSyncedGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdPSyncedGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdPSyncedGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IdPSyncedGroup mutation op: %q", m.Op())
	}
}

// InstanceSizeClient is a client for the InstanceSize schema.
type InstanceSizeClient struct {
	config
}

// NewInstanceSizeClient returns a client for the InstanceSize from the given config.
func NewInstanceSizeClient(c config) *InstanceSizeClient {
	return &InstanceSizeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instancesize.Hooks(f(g(h())))`.
func (c *InstanceSizeClient) Use(hooks ...Hook) {
	c.hooks.InstanceSize = append(c.hooks.InstanceSize, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `instancesize.Intercept(f(g(h())))`.
func (c *InstanceSizeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InstanceSize = append(c.inters.InstanceSize, interceptors...)
}

// Create returns a builder for creating a InstanceSize entity.
func (c *InstanceSizeClient) Create() *InstanceSizeCreate {
	mutation := newInstanceSizeMutation(c.config, OpCreate)
	return &InstanceSizeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InstanceSize entities.
func (c *InstanceSizeClient) CreateBulk(builders ...*InstanceSizeCreate) *InstanceSizeCreateBulk {
	return &InstanceSizeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InstanceSizeClient) MapCreateBulk(slice any, setFunc func(*InstanceSizeCreate, int)) *InstanceSizeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InstanceSizeCreateBulk{err: fmt.Errorf("calling to InstanceSizeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InstanceSizeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InstanceSizeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InstanceSize.
func (c *InstanceSizeClient) Update() *InstanceSizeUpdate {
	mutation := newInstanceSizeMutation(c.config, OpUpdate)
	return &InstanceSizeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceSizeClient) UpdateOne(_m *InstanceSize) *InstanceSizeUpdateOne {
	mutation := newInstanceSizeMutation(c.config, OpUpdateOne, withInstanceSize(_m))
	return &InstanceSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceSizeClient) UpdateOneID(id string) *InstanceSizeUpdateOne {
	mutation := newInstanceSizeMutation(c.config, OpUpdateOne, withInstanceSizeID(id))
	return &InstanceSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InstanceSize.
func (c *InstanceSizeClient) Delete() *InstanceSizeDelete {
	mutation := newInstanceSizeMutation(c.config, OpDelete)
	return &InstanceSizeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InstanceSizeClient) DeleteOne(_m *InstanceSize) *InstanceSizeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InstanceSizeClient) DeleteOneID(id string) *InstanceSizeDeleteOne {
	builder := c.Delete().Where(instancesize.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceSizeDeleteOne{builder}
}

// Query returns a query builder for InstanceSize.
func (c *InstanceSizeClient) Query() *InstanceSizeQuery {
	return &InstanceSizeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInstanceSize},
		inters: c.Interceptors(),
	}
}

// Get returns a InstanceSize entity by its id.
func (c *InstanceSizeClient) Get(ctx context.Context, id string) (*InstanceSize, error) {
	return c.Query().Where(instancesize.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceSizeClient) GetX(ctx context.Context, id string) *InstanceSize {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InstanceSizeClient) Hooks() []Hook {
	return c.hooks.InstanceSize
}

// Interceptors returns the client interceptors.
func (c *InstanceSizeClient) Interceptors() []Interceptor {
	return c.inters.InstanceSize
}

func (c *InstanceSizeClient) mutate(ctx context.Context, m *InstanceSizeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InstanceSizeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InstanceSizeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InstanceSizeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InstanceSizeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InstanceSize mutation op: %q", m.Op())
	}
}

// NamespaceRegistryClient is a client for the NamespaceRegistry schema.
type NamespaceRegistryClient struct {
	config
}

// NewNamespaceRegistryClient returns a client for the NamespaceRegistry from the given config.
func NewNamespaceRegistryClient(c config) *NamespaceRegistryClient {
	return &NamespaceRegistryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `namespaceregistry.Hooks(f(g(h())))`.
func (c *NamespaceRegistryClient) Use(hooks ...Hook) {
	c.hooks.NamespaceRegistry = append(c.hooks.NamespaceRegistry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `namespaceregistry.Intercept(f(g(h())))`.
func (c *NamespaceRegistryClient) Intercept(interceptors ...Interceptor) {
	c.inters.NamespaceRegistry = append(c.inters.NamespaceRegistry, interceptors...)
}

// Create returns a builder for creating a NamespaceRegistry entity.
func (c *NamespaceRegistryClient) Create() *NamespaceRegistryCreate {
	mutation := newNamespaceRegistryMutation(c.config, OpCreate)
	return &NamespaceRegistryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NamespaceRegistry entities.
func (c *NamespaceRegistryClient) CreateBulk(builders ...*NamespaceRegistryCreate) *NamespaceRegistryCreateBulk {
	return &NamespaceRegistryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NamespaceRegistryClient) MapCreateBulk(slice any, setFunc func(*NamespaceRegistryCreate, int)) *NamespaceRegistryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NamespaceRegistryCreateBulk{err: fmt.Errorf("calling to NamespaceRegistryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NamespaceRegistryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NamespaceRegistryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NamespaceRegistry.
func (c *NamespaceRegistryClient) Update() *NamespaceRegistryUpdate {
	mutation := newNamespaceRegistryMutation(c.config, OpUpdate)
	return &NamespaceRegistryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NamespaceRegistryClient) UpdateOne(_m *NamespaceRegistry) *NamespaceRegistryUpdateOne {
	mutation := newNamespaceRegistryMutation(c.config, OpUpdateOne, withNamespaceRegistry(_m))
	return &NamespaceRegistryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NamespaceRegistryClient) UpdateOneID(id string) *NamespaceRegistryUpdateOne {
	mutation := newNamespaceRegistryMutation(c.config, OpUpdateOne, withNamespaceRegistryID(id))
	return &NamespaceRegistryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NamespaceRegistry.
func (c *NamespaceRegistryClient) Delete() *NamespaceRegistryDelete {
	mutation := newNamespaceRegistryMutation(c.config, OpDelete)
	return &NamespaceRegistryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NamespaceRegistryClient) DeleteOne(_m *NamespaceRegistry) *NamespaceRegistryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NamespaceRegistryClient) DeleteOneID(id string) *NamespaceRegistryDeleteOne {
	builder := c.Delete().Where(namespaceregistry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NamespaceRegistryDeleteOne{builder}
}

// Query returns a query builder for NamespaceRegistry.
func (c *NamespaceRegistryClient) Query() *NamespaceRegistryQuery {
	return &NamespaceRegistryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNamespaceRegistry},
		inters: c.Interceptors(),
	}
}

// Get returns a NamespaceRegistry entity by its id.
func (c *NamespaceRegistryClient) Get(ctx context.Context, id string) (*NamespaceRegistry, error) {
	return c.Query().Where(namespaceregistry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NamespaceRegistryClient) GetX(ctx context.Context, id string) *NamespaceRegistry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NamespaceRegistryClient) Hooks() []Hook {
	return c.hooks.NamespaceRegistry
}

// Interceptors returns the client interceptors.
func (c *NamespaceRegistryClient) Interceptors() []Interceptor {
	return c.inters.NamespaceRegistry
}

func (c *NamespaceRegistryClient) mutate(ctx context.Context, m *NamespaceRegistryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NamespaceRegistryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NamespaceRegistryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NamespaceRegistryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NamespaceRegistryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NamespaceRegistry mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(_m *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(_m))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id string) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(_m *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id string) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id string) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id string) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Notification.
func (c *NotificationClient) QueryUser(_m *Notification) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(notification.Table, notification.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, notification.UserTable, notification.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// PendingAdoptionClient is a client for the PendingAdoption schema.
type PendingAdoptionClient struct {
	config
}

// NewPendingAdoptionClient returns a client for the PendingAdoption from the given config.
func NewPendingAdoptionClient(c config) *PendingAdoptionClient {
	return &PendingAdoptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pendingadoption.Hooks(f(g(h())))`.
func (c *PendingAdoptionClient) Use(hooks ...Hook) {
	c.hooks.PendingAdoption = append(c.hooks.PendingAdoption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pendingadoption.Intercept(f(g(h())))`.
func (c *PendingAdoptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PendingAdoption = append(c.inters.PendingAdoption, interceptors...)
}

// Create returns a builder for creating a PendingAdoption entity.
func (c *PendingAdoptionClient) Create() *PendingAdoptionCreate {
	mutation := newPendingAdoptionMutation(c.config, OpCreate)
	return &PendingAdoptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PendingAdoption entities.
func (c *PendingAdoptionClient) CreateBulk(builders ...*PendingAdoptionCreate) *PendingAdoptionCreateBulk {
	return &PendingAdoptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PendingAdoptionClient) MapCreateBulk(slice any, setFunc func(*PendingAdoptionCreate, int)) *PendingAdoptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PendingAdoptionCreateBulk{err: fmt.Errorf("calling to PendingAdoptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PendingAdoptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PendingAdoptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PendingAdoption.
func (c *PendingAdoptionClient) Update() *PendingAdoptionUpdate {
	mutation := newPendingAdoptionMutation(c.config, OpUpdate)
	return &PendingAdoptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PendingAdoptionClient) UpdateOne(_m *PendingAdoption) *PendingAdoptionUpdateOne {
	mutation := newPendingAdoptionMutation(c.config, OpUpdateOne, withPendingAdoption(_m))
	return &PendingAdoptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PendingAdoptionClient) UpdateOneID(id string) *PendingAdoptionUpdateOne {
	mutation := newPendingAdoptionMutation(c.config, OpUpdateOne, withPendingAdoptionID(id))
	return &PendingAdoptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PendingAdoption.
func (c *PendingAdoptionClient) Delete() *PendingAdoptionDelete {
	mutation := newPendingAdoptionMutation(c.config, OpDelete)
	return &PendingAdoptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PendingAdoptionClient) DeleteOne(_m *PendingAdoption) *PendingAdoptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PendingAdoptionClient) DeleteOneID(id string) *PendingAdoptionDeleteOne {
	builder := c.Delete().Where(pendingadoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PendingAdoptionDeleteOne{builder}
}

// Query returns a query builder for PendingAdoption.
func (c *PendingAdoptionClient) Query() *PendingAdoptionQuery {
	return &PendingAdoptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePendingAdoption},
		inters: c.Interceptors(),
	}
}

// Get returns a PendingAdoption entity by its id.
func (c *PendingAdoptionClient) Get(ctx context.Context, id string) (*PendingAdoption, error) {
	return c.Query().Where(pendingadoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PendingAdoptionClient) GetX(ctx context.Context, id string) *PendingAdoption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PendingAdoptionClient) Hooks() []Hook {
	return c.hooks.PendingAdoption
}

// Interceptors returns the client interceptors.
func (c *PendingAdoptionClient) Interceptors() []Interceptor {
	return c.inters.PendingAdoption
}

func (c *PendingAdoptionClient) mutate(ctx context.Context, m *PendingAdoptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PendingAdoptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PendingAdoptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PendingAdoptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PendingAdoptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PendingAdoption mutation op: %q", m.Op())
	}
}

// ResourceRoleBindingClient is a client for the ResourceRoleBinding schema.
type ResourceRoleBindingClient struct {
	config
}

// NewResourceRoleBindingClient returns a client for the ResourceRoleBinding from the given config.
func NewResourceRoleBindingClient(c config) *ResourceRoleBindingClient {
	return &ResourceRoleBindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `resourcerolebinding.Hooks(f(g(h())))`.
func (c *ResourceRoleBindingClient) Use(hooks ...Hook) {
	c.hooks.ResourceRoleBinding = append(c.hooks.ResourceRoleBinding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `resourcerolebinding.Intercept(f(g(h())))`.
func (c *ResourceRoleBindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ResourceRoleBinding = append(c.inters.ResourceRoleBinding, interceptors...)
}

// Create returns a builder for creating a ResourceRoleBinding entity.
func (c *ResourceRoleBindingClient) Create() *ResourceRoleBindingCreate {
	mutation := newResourceRoleBindingMutation(c.config, OpCreate)
	return &ResourceRoleBindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ResourceRoleBinding entities.
func (c *ResourceRoleBindingClient) CreateBulk(builders ...*ResourceRoleBindingCreate) *ResourceRoleBindingCreateBulk {
	return &ResourceRoleBindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ResourceRoleBindingClient) MapCreateBulk(slice any, setFunc func(*ResourceRoleBindingCreate, int)) *ResourceRoleBindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ResourceRoleBindingCreateBulk{err: fmt.Errorf("calling to ResourceRoleBindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ResourceRoleBindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ResourceRoleBindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ResourceRoleBinding.
func (c *ResourceRoleBindingClient) Update() *ResourceRoleBindingUpdate {
	mutation := newResourceRoleBindingMutation(c.config, OpUpdate)
	return &ResourceRoleBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResourceRoleBindingClient) UpdateOne(_m *ResourceRoleBinding) *ResourceRoleBindingUpdateOne {
	mutation := newResourceRoleBindingMutation(c.config, OpUpdateOne, withResourceRoleBinding(_m))
	return &ResourceRoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResourceRoleBindingClient) UpdateOneID(id string) *ResourceRoleBindingUpdateOne {
	mutation := newResourceRoleBindingMutation(c.config, OpUpdateOne, withResourceRoleBindingID(id))
	return &ResourceRoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ResourceRoleBinding.
func (c *ResourceRoleBindingClient) Delete() *ResourceRoleBindingDelete {
	mutation := newResourceRoleBindingMutation(c.config, OpDelete)
	return &ResourceRoleBindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ResourceRoleBindingClient) DeleteOne(_m *ResourceRoleBinding) *ResourceRoleBindingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ResourceRoleBindingClient) DeleteOneID(id string) *ResourceRoleBindingDeleteOne {
	builder := c.Delete().Where(resourcerolebinding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResourceRoleBindingDeleteOne{builder}
}

// Query returns a query builder for ResourceRoleBinding.
func (c *ResourceRoleBindingClient) Query() *ResourceRoleBindingQuery {
	return &ResourceRoleBindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeResourceRoleBinding},
		inters: c.Interceptors(),
	}
}

// Get returns a ResourceRoleBinding entity by its id.
func (c *ResourceRoleBindingClient) Get(ctx context.Context, id string) (*ResourceRoleBinding, error) {
	return c.Query().Where(resourcerolebinding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResourceRoleBindingClient) GetX(ctx context.Context, id string) *ResourceRoleBinding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ResourceRoleBindingClient) Hooks() []Hook {
	return c.hooks.ResourceRoleBinding
}

// Interceptors returns the client interceptors.
func (c *ResourceRoleBindingClient) Interceptors() []Interceptor {
	return c.inters.ResourceRoleBinding
}

func (c *ResourceRoleBindingClient) mutate(ctx context.Context, m *ResourceRoleBindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ResourceRoleBindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ResourceRoleBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ResourceRoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ResourceRoleBindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ResourceRoleBinding mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id string) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id string) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id string) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id string) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoleBindings queries the role_bindings edge of a Role.
func (c *RoleClient) QueryRoleBindings(_m *Role) *RoleBindingQuery {
	query := (&RoleBindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(rolebinding.Table, rolebinding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RoleBindingsTable, role.RoleBindingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// RoleBindingClient is a client for the RoleBinding schema.
type RoleBindingClient struct {
	config
}

// NewRoleBindingClient returns a client for the RoleBinding from the given config.
func NewRoleBindingClient(c config) *RoleBindingClient {
	return &RoleBindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rolebinding.Hooks(f(g(h())))`.
func (c *RoleBindingClient) Use(hooks ...Hook) {
	c.hooks.RoleBinding = append(c.hooks.RoleBinding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rolebinding.Intercept(f(g(h())))`.
func (c *RoleBindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.RoleBinding = append(c.inters.RoleBinding, interceptors...)
}

// Create returns a builder for creating a RoleBinding entity.
func (c *RoleBindingClient) Create() *RoleBindingCreate {
	mutation := newRoleBindingMutation(c.config, OpCreate)
	return &RoleBindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RoleBinding entities.
func (c *RoleBindingClient) CreateBulk(builders ...*RoleBindingCreate) *RoleBindingCreateBulk {
	return &RoleBindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleBindingClient) MapCreateBulk(slice any, setFunc func(*RoleBindingCreate, int)) *RoleBindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleBindingCreateBulk{err: fmt.Errorf("calling to RoleBindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleBindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleBindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RoleBinding.
func (c *RoleBindingClient) Update() *RoleBindingUpdate {
	mutation := newRoleBindingMutation(c.config, OpUpdate)
	return &RoleBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleBindingClient) UpdateOne(_m *RoleBinding) *RoleBindingUpdateOne {
	mutation := newRoleBindingMutation(c.config, OpUpdateOne, withRoleBinding(_m))
	return &RoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleBindingClient) UpdateOneID(id string) *RoleBindingUpdateOne {
	mutation := newRoleBindingMutation(c.config, OpUpdateOne, withRoleBindingID(id))
	return &RoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RoleBinding.
func (c *RoleBindingClient) Delete() *RoleBindingDelete {
	mutation := newRoleBindingMutation(c.config, OpDelete)
	return &RoleBindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleBindingClient) DeleteOne(_m *RoleBinding) *RoleBindingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleBindingClient) DeleteOneID(id string) *RoleBindingDeleteOne {
	builder := c.Delete().Where(rolebinding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleBindingDeleteOne{builder}
}

// Query returns a query builder for RoleBinding.
func (c *RoleBindingClient) Query() *RoleBindingQuery {
	return &RoleBindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoleBinding},
		inters: c.Interceptors(),
	}
}

// Get returns a RoleBinding entity by its id.
func (c *RoleBindingClient) Get(ctx context.Context, id string) (*RoleBinding, error) {
	return c.Query().Where(rolebinding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleBindingClient) GetX(ctx context.Context, id string) *RoleBinding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a RoleBinding.
func (c *RoleBindingClient) QueryUser(_m *RoleBinding) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolebinding.Table, rolebinding.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolebinding.UserTable, rolebinding.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRole queries the role edge of a RoleBinding.
func (c *RoleBindingClient) QueryRole(_m *RoleBinding) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolebinding.Table, rolebinding.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolebinding.RoleTable, rolebinding.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleBindingClient) Hooks() []Hook {
	return c.hooks.RoleBinding
}

// Interceptors returns the client interceptors.
func (c *RoleBindingClient) Interceptors() []Interceptor {
	return c.inters.RoleBinding
}

func (c *RoleBindingClient) mutate(ctx context.Context, m *RoleBindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleBindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleBindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleBindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleBindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RoleBinding mutation op: %q", m.Op())
	}
}

// ServiceClient is a client for the Service schema.
type ServiceClient struct {
	config
}

// NewServiceClient returns a client for the Service from the given config.
func NewServiceClient(c config) *ServiceClient {
	return &ServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `service.Hooks(f(g(h())))`.
func (c *ServiceClient) Use(hooks ...Hook) {
	c.hooks.Service = append(c.hooks.Service, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `service.Intercept(f(g(h())))`.
func (c *ServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Service = append(c.inters.Service, interceptors...)
}

// Create returns a builder for creating a Service entity.
func (c *ServiceClient) Create() *ServiceCreate {
	mutation := newServiceMutation(c.config, OpCreate)
	return &ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Service entities.
func (c *ServiceClient) CreateBulk(builders ...*ServiceCreate) *ServiceCreateBulk {
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceClient) MapCreateBulk(slice any, setFunc func(*ServiceCreate, int)) *ServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceCreateBulk{err: fmt.Errorf("calling to ServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Service.
func (c *ServiceClient) Update() *ServiceUpdate {
	mutation := newServiceMutation(c.config, OpUpdate)
	return &ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceClient) UpdateOne(_m *Service) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withService(_m))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceClient) UpdateOneID(id string) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withServiceID(id))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Service.
func (c *ServiceClient) Delete() *ServiceDelete {
	mutation := newServiceMutation(c.config, OpDelete)
	return &ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceClient) DeleteOne(_m *Service) *ServiceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceClient) DeleteOneID(id string) *ServiceDeleteOne {
	builder := c.Delete().Where(service.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDeleteOne{builder}
}

// Query returns a query builder for Service.
func (c *ServiceClient) Query() *ServiceQuery {
	return &ServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeService},
		inters: c.Interceptors(),
	}
}

// Get returns a Service entity by its id.
func (c *ServiceClient) Get(ctx context.Context, id string) (*Service, error) {
	return c.Query().Where(service.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceClient) GetX(ctx context.Context, id string) *Service {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySystem queries the system edge of a Service.
func (c *ServiceClient) QuerySystem(_m *Service) *SystemQuery {
	query := (&SystemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(system.Table, system.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, service.SystemTable, service.SystemColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVms queries the vms edge of a Service.
func (c *ServiceClient) QueryVms(_m *Service) *VMQuery {
	query := (&VMClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(vm.Table, vm.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, service.VmsTable, service.VmsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceClient) Hooks() []Hook {
	return c.hooks.Service
}

// Interceptors returns the client interceptors.
func (c *ServiceClient) Interceptors() []Interceptor {
	return c.inters.Service
}

func (c *ServiceClient) mutate(ctx context.Context, m *ServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Service mutation op: %q", m.Op())
	}
}

// SystemClient is a client for the System schema.
type SystemClient struct {
	config
}

// NewSystemClient returns a client for the System from the given config.
func NewSystemClient(c config) *SystemClient {
	return &SystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `system.Hooks(f(g(h())))`.
func (c *SystemClient) Use(hooks ...Hook) {
	c.hooks.System = append(c.hooks.System, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `system.Intercept(f(g(h())))`.
func (c *SystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.System = append(c.inters.System, interceptors...)
}

// Create returns a builder for creating a System entity.
func (c *SystemClient) Create() *SystemCreate {
	mutation := newSystemMutation(c.config, OpCreate)
	return &SystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of System entities.
func (c *SystemClient) CreateBulk(builders ...*SystemCreate) *SystemCreateBulk {
	return &SystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemClient) MapCreateBulk(slice any, setFunc func(*SystemCreate, int)) *SystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemCreateBulk{err: fmt.Errorf("calling to SystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for System.
func (c *SystemClient) Update() *SystemUpdate {
	mutation := newSystemMutation(c.config, OpUpdate)
	return &SystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemClient) UpdateOne(_m *System) *SystemUpdateOne {
	mutation := newSystemMutation(c.config, OpUpdateOne, withSystem(_m))
	return &SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemClient) UpdateOneID(id string) *SystemUpdateOne {
	mutation := newSystemMutation(c.config, OpUpdateOne, withSystemID(id))
	return &SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for System.
func (c *SystemClient) Delete() *SystemDelete {
	mutation := newSystemMutation(c.config, OpDelete)
	return &SystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemClient) DeleteOne(_m *System) *SystemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemClient) DeleteOneID(id string) *SystemDeleteOne {
	builder := c.Delete().Where(system.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemDeleteOne{builder}
}

// Query returns a query builder for System.
func (c *SystemClient) Query() *SystemQuery {
	return &SystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a System entity by its id.
func (c *SystemClient) Get(ctx context.Context, id string) (*System, error) {
	return c.Query().Where(system.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemClient) GetX(ctx context.Context, id string) *System {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServices queries the services edge of a System.
func (c *SystemClient) QueryServices(_m *System) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(system.Table, system.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, system.ServicesTable, system.ServicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemClient) Hooks() []Hook {
	return c.hooks.System
}

// Interceptors returns the client interceptors.
func (c *SystemClient) Interceptors() []Interceptor {
	return c.inters.System
}

func (c *SystemClient) mutate(ctx context.Context, m *SystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown System mutation op: %q", m.Op())
	}
}

// SystemSecretClient is a client for the SystemSecret schema.
type SystemSecretClient struct {
	config
}

// NewSystemSecretClient returns a client for the SystemSecret from the given config.
func NewSystemSecretClient(c config) *SystemSecretClient {
	return &SystemSecretClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemsecret.Hooks(f(g(h())))`.
func (c *SystemSecretClient) Use(hooks ...Hook) {
	c.hooks.SystemSecret = append(c.hooks.SystemSecret, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemsecret.Intercept(f(g(h())))`.
func (c *SystemSecretClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemSecret = append(c.inters.SystemSecret, interceptors...)
}

// Create returns a builder for creating a SystemSecret entity.
func (c *SystemSecretClient) Create() *SystemSecretCreate {
	mutation := newSystemSecretMutation(c.config, OpCreate)
	return &SystemSecretCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemSecret entities.
func (c *SystemSecretClient) CreateBulk(builders ...*SystemSecretCreate) *SystemSecretCreateBulk {
	return &SystemSecretCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemSecretClient) MapCreateBulk(slice any, setFunc func(*SystemSecretCreate, int)) *SystemSecretCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemSecretCreateBulk{err: fmt.Errorf("calling to SystemSecretClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemSecretCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemSecretCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemSecret.
func (c *SystemSecretClient) Update() *SystemSecretUpdate {
	mutation := newSystemSecretMutation(c.config, OpUpdate)
	return &SystemSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemSecretClient) UpdateOne(_m *SystemSecret) *SystemSecretUpdateOne {
	mutation := newSystemSecretMutation(c.config, OpUpdateOne, withSystemSecret(_m))
	return &SystemSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemSecretClient) UpdateOneID(id string) *SystemSecretUpdateOne {
	mutation := newSystemSecretMutation(c.config, OpUpdateOne, withSystemSecretID(id))
	return &SystemSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemSecret.
func (c *SystemSecretClient) Delete() *SystemSecretDelete {
	mutation := newSystemSecretMutation(c.config, OpDelete)
	return &SystemSecretDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemSecretClient) DeleteOne(_m *SystemSecret) *SystemSecretDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemSecretClient) DeleteOneID(id string) *SystemSecretDeleteOne {
	builder := c.Delete().Where(systemsecret.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemSecretDeleteOne{builder}
}

// Query returns a query builder for SystemSecret.
func (c *SystemSecretClient) Query() *SystemSecretQuery {
	return &SystemSecretQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemSecret},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemSecret entity by its id.
func (c *SystemSecretClient) Get(ctx context.Context, id string) (*SystemSecret, error) {
	return c.Query().Where(systemsecret.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemSecretClient) GetX(ctx context.Context, id string) *SystemSecret {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemSecretClient) Hooks() []Hook {
	return c.hooks.SystemSecret
}

// Interceptors returns the client interceptors.
func (c *SystemSecretClient) Interceptors() []Interceptor {
	return c.inters.SystemSecret
}

func (c *SystemSecretClient) mutate(ctx context.Context, m *SystemSecretMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemSecretCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemSecretUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemSecretUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemSecretDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemSecret mutation op: %q", m.Op())
	}
}

// TemplateClient is a client for the Template schema.
type TemplateClient struct {
	config
}

// NewTemplateClient returns a client for the Template from the given config.
func NewTemplateClient(c config) *TemplateClient {
	return &TemplateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `template.Hooks(f(g(h())))`.
func (c *TemplateClient) Use(hooks ...Hook) {
	c.hooks.Template = append(c.hooks.Template, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `template.Intercept(f(g(h())))`.
func (c *TemplateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Template = append(c.inters.Template, interceptors...)
}

// Create returns a builder for creating a Template entity.
func (c *TemplateClient) Create() *TemplateCreate {
	mutation := newTemplateMutation(c.config, OpCreate)
	return &TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Template entities.
func (c *TemplateClient) CreateBulk(builders ...*TemplateCreate) *TemplateCreateBulk {
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplateClient) MapCreateBulk(slice any, setFunc func(*TemplateCreate, int)) *TemplateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplateCreateBulk{err: fmt.Errorf("calling to TemplateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Template.
func (c *TemplateClient) Update() *TemplateUpdate {
	mutation := newTemplateMutation(c.config, OpUpdate)
	return &TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplateClient) UpdateOne(_m *Template) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplate(_m))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplateClient) UpdateOneID(id string) *TemplateUpdateOne {
	mutation := newTemplateMutation(c.config, OpUpdateOne, withTemplateID(id))
	return &TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Template.
func (c *TemplateClient) Delete() *TemplateDelete {
	mutation := newTemplateMutation(c.config, OpDelete)
	return &TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplateClient) DeleteOne(_m *Template) *TemplateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplateClient) DeleteOneID(id string) *TemplateDeleteOne {
	builder := c.Delete().Where(template.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplateDeleteOne{builder}
}

// Query returns a query builder for Template.
func (c *TemplateClient) Query() *TemplateQuery {
	return &TemplateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemplate},
		inters: c.Interceptors(),
	}
}

// Get returns a Template entity by its id.
func (c *TemplateClient) Get(ctx context.Context, id string) (*Template, error) {
	return c.Query().Where(template.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplateClient) GetX(ctx context.Context, id string) *Template {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemplateClient) Hooks() []Hook {
	return c.hooks.Template
}

// Interceptors returns the client interceptors.
func (c *TemplateClient) Interceptors() []Interceptor {
	return c.inters.Template
}

func (c *TemplateClient) mutate(ctx context.Context, m *TemplateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Template mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoleBindings queries the role_bindings edge of a User.
func (c *UserClient) QueryRoleBindings(_m *User) *RoleBindingQuery {
	query := (&RoleBindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(rolebinding.Table, rolebinding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RoleBindingsTable, user.RoleBindingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNotifications queries the notifications edge of a User.
func (c *UserClient) QueryNotifications(_m *User) *NotificationQuery {
	query := (&NotificationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(notification.Table, notification.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NotificationsTable, user.NotificationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VMClient is a client for the VM schema.
type VMClient struct {
	config
}

// NewVMClient returns a client for the VM from the given config.
func NewVMClient(c config) *VMClient {
	return &VMClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vm.Hooks(f(g(h())))`.
func (c *VMClient) Use(hooks ...Hook) {
	c.hooks.VM = append(c.hooks.VM, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vm.Intercept(f(g(h())))`.
func (c *VMClient) Intercept(interceptors ...Interceptor) {
	c.inters.VM = append(c.inters.VM, interceptors...)
}

// Create returns a builder for creating a VM entity.
func (c *VMClient) Create() *VMCreate {
	mutation := newVMMutation(c.config, OpCreate)
	return &VMCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VM entities.
func (c *VMClient) CreateBulk(builders ...*VMCreate) *VMCreateBulk {
	return &VMCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VMClient) MapCreateBulk(slice any, setFunc func(*VMCreate, int)) *VMCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VMCreateBulk{err: fmt.Errorf("calling to VMClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VMCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VMCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VM.
func (c *VMClient) Update() *VMUpdate {
	mutation := newVMMutation(c.config, OpUpdate)
	return &VMUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VMClient) UpdateOne(_m *VM) *VMUpdateOne {
	mutation := newVMMutation(c.config, OpUpdateOne, withVM(_m))
	return &VMUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VMClient) UpdateOneID(id string) *VMUpdateOne {
	mutation := newVMMutation(c.config, OpUpdateOne, withVMID(id))
	return &VMUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VM.
func (c *VMClient) Delete() *VMDelete {
	mutation := newVMMutation(c.config, OpDelete)
	return &VMDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VMClient) DeleteOne(_m *VM) *VMDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VMClient) DeleteOneID(id string) *VMDeleteOne {
	builder := c.Delete().Where(vm.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VMDeleteOne{builder}
}

// Query returns a query builder for VM.
func (c *VMClient) Query() *VMQuery {
	return &VMQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVM},
		inters: c.Interceptors(),
	}
}

// Get returns a VM entity by its id.
func (c *VMClient) Get(ctx context.Context, id string) (*VM, error) {
	return c.Query().Where(vm.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VMClient) GetX(ctx context.Context, id string) *VM {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryService queries the service edge of a VM.
func (c *VMClient) QueryService(_m *VM) *ServiceQuery {
	query := (&ServiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vm.Table, vm.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vm.ServiceTable, vm.ServiceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRevisions queries the revisions edge of a VM.
func (c *VMClient) QueryRevisions(_m *VM) *VMRevisionQuery {
	query := (&VMRevisionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vm.Table, vm.FieldID, id),
			sqlgraph.To(vmrevision.Table, vmrevision.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vm.RevisionsTable, vm.RevisionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VMClient) Hooks() []Hook {
	return c.hooks.VM
}

// Interceptors returns the client interceptors.
func (c *VMClient) Interceptors() []Interceptor {
	return c.inters.VM
}

func (c *VMClient) mutate(ctx context.Context, m *VMMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VMCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VMUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VMUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VMDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VM mutation op: %q", m.Op())
	}
}

// VMRevisionClient is a client for the VMRevision schema.
type VMRevisionClient struct {
	config
}

// NewVMRevisionClient returns a client for the VMRevision from the given config.
func NewVMRevisionClient(c config) *VMRevisionClient {
	return &VMRevisionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vmrevision.Hooks(f(g(h())))`.
func (c *VMRevisionClient) Use(hooks ...Hook) {
	c.hooks.VMRevision = append(c.hooks.VMRevision, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vmrevision.Intercept(f(g(h())))`.
func (c *VMRevisionClient) Intercept(interceptors ...Interceptor) {
	c.inters.VMRevision = append(c.inters.VMRevision, interceptors...)
}

// Create returns a builder for creating a VMRevision entity.
func (c *VMRevisionClient) Create() *VMRevisionCreate {
	mutation := newVMRevisionMutation(c.config, OpCreate)
	return &VMRevisionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VMRevision entities.
func (c *VMRevisionClient) CreateBulk(builders ...*VMRevisionCreate) *VMRevisionCreateBulk {
	return &VMRevisionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VMRevisionClient) MapCreateBulk(slice any, setFunc func(*VMRevisionCreate, int)) *VMRevisionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VMRevisionCreateBulk{err: fmt.Errorf("calling to VMRevisionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VMRevisionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VMRevisionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VMRevision.
func (c *VMRevisionClient) Update() *VMRevisionUpdate {
	mutation := newVMRevisionMutation(c.config, OpUpdate)
	return &VMRevisionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VMRevisionClient) UpdateOne(_m *VMRevision) *VMRevisionUpdateOne {
	mutation := newVMRevisionMutation(c.config, OpUpdateOne, withVMRevision(_m))
	return &VMRevisionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VMRevisionClient) UpdateOneID(id string) *VMRevisionUpdateOne {
	mutation := newVMRevisionMutation(c.config, OpUpdateOne, withVMRevisionID(id))
	return &VMRevisionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VMRevision.
func (c *VMRevisionClient) Delete() *VMRevisionDelete {
	mutation := newVMRevisionMutation(c.config, OpDelete)
	return &VMRevisionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VMRevisionClient) DeleteOne(_m *VMRevision) *VMRevisionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VMRevisionClient) DeleteOneID(id string) *VMRevisionDeleteOne {
	builder := c.Delete().Where(vmrevision.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VMRevisionDeleteOne{builder}
}

// Query returns a query builder for VMRevision.
func (c *VMRevisionClient) Query() *VMRevisionQuery {
	return &VMRevisionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVMRevision},
		inters: c.Interceptors(),
	}
}

// Get returns a VMRevision entity by its id.
func (c *VMRevisionClient) Get(ctx context.Context, id string) (*VMRevision, error) {
	return c.Query().Where(vmrevision.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VMRevisionClient) GetX(ctx context.Context, id string) *VMRevision {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVM queries the vm edge of a VMRevision.
func (c *VMRevisionClient) QueryVM(_m *VMRevision) *VMQuery {
	query := (&VMClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vmrevision.Table, vmrevision.FieldID, id),
			sqlgraph.To(vm.Table, vm.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vmrevision.VMTable, vmrevision.VMColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VMRevisionClient) Hooks() []Hook {
	return c.hooks.VMRevision
}

// Interceptors returns the client interceptors.
func (c *VMRevisionClient) Interceptors() []Interceptor {
	return c.inters.VMRevision
}

func (c *VMRevisionClient) mutate(ctx context.Context, m *VMRevisionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VMRevisionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VMRevisionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VMRevisionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VMRevisionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VMRevision mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ApprovalPolicy, ApprovalTicket, AuditLog, AuthProvider, Cluster, DomainEvent,
		ExternalApprovalSystem, IdPGroupMapping, IdPSyncedGroup, InstanceSize,
		NamespaceRegistry, Notification, PendingAdoption, ResourceRoleBinding, Role,
		RoleBinding, Service, System, SystemSecret, Template, User, VM,
		VMRevision []ent.Hook
	}
	inters struct {
		ApprovalPolicy, ApprovalTicket, AuditLog, AuthProvider, Cluster, DomainEvent,
		ExternalApprovalSystem, IdPGroupMapping, IdPSyncedGroup, InstanceSize,
		NamespaceRegistry, Notification, PendingAdoption, ResourceRoleBinding, Role,
		RoleBinding, Service, System, SystemSecret, Template, User, VM,
		VMRevision []ent.Interceptor
	}
)
